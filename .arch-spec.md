# Event-Driven Architecture Principles

## Core Tenets
1. **StateCoordinator (actor) is the ONLY source of truth** - All state changes flow through it
2. **EventCoordinator is the ONLY communication channel** - No direct component-to-component calls
3. **Handlers are pure reactors** - Stateless, no bidirectional dependencies
4. **LLM I/O surfaces as events** - Never direct calls into UI
5. **Tool execution in Tool Handler only** - Not sprinkled in UI

## Component Responsibilities

### StateCoordinator (actor)
- **OWNS**: currentSystemPrompt, allowedTools, currentPhase, nextPhase, objective ledger
- **APPLIES**: Phase scripts and emits transition events
- **SUBSCRIBES**: State.set(..), LLM.userMessageSent, Objective.ledger.update
- **PUBLISHES**: State.snapshot, State.allowedTools, Phase.transition.*, Objective.status.changed

### EventCoordinator (actor)
- **ONLY PUB/SUB MECHANISM** - All inter-component communication
- AsyncStream-based with topic filtering
- Topics: llm, toolpane, artifact, userInput, state, phase, objective, tool, timeline, processing

### Handlers (UI/Business)
- **MUST BE STATELESS** - No internal state storage
- **PURE REACTORS** - Subscribe to events, publish responses
- **NO DIRECT CALLS** - Between handlers or to UI
- Examples: LLM Messenger, Tool Handler, ToolPane Handler, Artifact Handler, Chatbox Handler

## Prohibited Patterns

### ❌ CRITICAL VIOLATIONS (Block commit):
```swift
// Direct state mutation
class MyHandler {
    var localState: String = "" // ❌ Handlers must be stateless
    currentPhase = .phase2 // ❌ Only StateCoordinator mutates state
}

// Direct UI calls from business logic
func onLLMResponse() {
    chatboxView.update() // ❌ Must publish event instead
}

// Tool execution in UI
Button("Execute") {
    toolService.execute() // ❌ Must go through Tool Handler
}

// Direct handler calls
llmHandler.sendMessage() // ❌ Must publish event to EventCoordinator

// Bidirectional dependencies
class HandlerA {
    let handlerB: HandlerB // ❌ Creates coupling
}

// Synchronous blocking in actor
actor StateCoordinator {
    func update() {
        heavyWork() // ❌ Use async/await
    }
}
```

### ✅ CORRECT PATTERNS:
```swift
// State changes through StateCoordinator
await stateCoordinator.apply(.setState(.phase2))

// Event-driven UI updates
await eventCoordinator.publish(.llmMessageReceived(text))

// Tool execution through event
await eventCoordinator.publish(.toolCallReceived(tool))

// Handler communication via events
for await event in eventCoordinator.stream(topic: .llm) {
    // React to event
}

// Stateless handler
@MainActor
class ChatboxHandler {
    func handleEvent(_ event: OnboardingEvent) async {
        // Pure reaction, no stored state
        await eventCoordinator.publish(response)
    }
}
```

## Data Contracts
- Use typed payloads (MessagePayload, OnboardingPhaseSpec, ToolPaneCardDescriptor)
- Avoid `Any` in event payloads
- Events specify their topic explicitly

## Phase & Tool Validation
- Tool calls MUST validate against StateCoordinator.allowedTools
- Phase transitions emit Phase.transition.requested → Phase.transition.applied
- All state updates are idempotent

## References
- StateCoordinator: Section 4.1
- EventCoordinator: Section 4.2  
- AsyncStream architecture: Implementation notes 2025-11-03
- Core sequences: Section 7
