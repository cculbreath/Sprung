# Hybrid Event-Driven + Reactive Architecture

## Core Tenets
1. **StateCoordinator (actor) is the ONLY source of truth** - All state changes flow through it
2. **EventCoordinator for process orchestration** - Cross-component coordination uses events
3. **@Observable for UI reactivity** - SwiftUI's native reactivity for view state (best of both worlds)
4. **Handlers react to events** - Process coordination via events, UI updates via @Observable
5. **Tool execution in Tool Handler only** - Not sprinkled in UI

## Hybrid Pattern: Events + @Observable
**Use Events For:**
- Process orchestration (LLM request/response cycles)
- Cross-component coordination (state → multiple handlers)
- Business logic workflows (objective completion → next phase)
- Async operations (tool execution, API calls)

**Use @Observable For:**
- UI state that drives view updates
- Parent-child component data flow
- Form state, pending requests, active cards
- Any state consumed directly by SwiftUI views

**Why Hybrid?**
Events prevent tight coupling in business logic. @Observable prevents "CB radio"
UI updates. Each pattern plays to its strengths.

## Component Responsibilities

### StateCoordinator (actor)
- **OWNS**: currentSystemPrompt, allowedTools, currentPhase, nextPhase, objective ledger
- **APPLIES**: Phase scripts and emits transition events
- **SUBSCRIBES**: State.set(..), LLM.userMessageSent, Objective.ledger.update
- **PUBLISHES**: State.snapshot, State.allowedTools, Phase.transition.*, Objective.status.changed

### EventCoordinator (actor)
- **ONLY PUB/SUB MECHANISM** - All inter-component communication
- AsyncStream-based with topic filtering
- Topics: llm, toolpane, artifact, userInput, state, phase, objective, tool, timeline, processing

### Handlers (UI/Business)
- **Process state via events** - Business logic coordination uses EventCoordinator
- **UI state via @Observable** - View-consumed state uses SwiftUI reactivity
- **NO CROSS-HANDLER CALLS** - Handlers communicate via events, not direct calls
- Examples: LLM Messenger (events), ProfileInteractionHandler (@Observable UI state)

## Prohibited Patterns

### ❌ CRITICAL VIOLATIONS (Block commit):
```swift
// Direct state mutation in wrong place
class MyHandler {
    currentPhase = .phase2 // ❌ Only StateCoordinator mutates global state
}

// Process coordination without events
func onObjectiveComplete() {
    llmHandler.sendNextMessage() // ❌ Must publish event to EventCoordinator
}

// Tool execution in UI
Button("Execute") {
    toolService.execute() // ❌ Must go through Tool Handler via event
}

// Cross-handler direct calls
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Must use events for handler coordination
    }
}

// Synchronous blocking in actor
actor StateCoordinator {
    func update() {
        heavyWork() // ❌ Use async/await
    }
}
```

### ✅ ALLOWED: @Observable UI State
```swift
// UI state in handler (NOT a violation)
@MainActor
@Observable
class ProfileInteractionHandler {
    private(set) var pendingProfileSummary: JSON? // ✅ UI state for views
    private(set) var pendingIntakeRequest: Request? // ✅ UI state for views

    func showProfileSummary(profile: JSON) {
        pendingProfileSummary = profile // ✅ SwiftUI reactivity handles updates
    }
}

// View consumes via @Observable chain
struct ToolPaneView: View {
    @Bindable var coordinator: Coordinator

    var body: some View {
        if let summary = coordinator.toolRouter.profileHandler.pendingProfileSummary {
            SummaryCard(summary) // ✅ Automatic UI updates via @Observable
        }
    }
}
```

### ✅ CORRECT PATTERNS:
```swift
// State changes through StateCoordinator
await stateCoordinator.apply(.setState(.phase2))

// Event-driven UI updates
await eventCoordinator.publish(.llmMessageReceived(text))

// Tool execution through event
await eventCoordinator.publish(.toolCallReceived(tool))

// Handler communication via events
for await event in eventCoordinator.stream(topic: .llm) {
    // React to event
}

// Stateless handler
@MainActor
class ChatboxHandler {
    func handleEvent(_ event: OnboardingEvent) async {
        // Pure reaction, no stored state
        await eventCoordinator.publish(response)
    }
}
```

## Data Contracts
- Use typed payloads (MessagePayload, OnboardingPhaseSpec, ToolPaneCardDescriptor)
- Avoid `Any` in event payloads
- Events specify their topic explicitly

## Phase & Tool Validation
- Tool calls MUST validate against StateCoordinator.allowedTools
- Phase transitions emit Phase.transition.requested → Phase.transition.applied
- All state updates are idempotent

## References
- StateCoordinator: Section 4.1
- EventCoordinator: Section 4.2  
- AsyncStream architecture: Implementation notes 2025-11-03
- Core sequences: Section 7
