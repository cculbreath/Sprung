# Hybrid Event-Driven + Reactive Architecture

## Core Tenets
1. **StateCoordinator for interview-scoped state** - Interview workflow state (phases, objectives, artifacts, chat) flows through StateCoordinator
2. **Persisted domain stores are independent** - KnowledgeCardStore, SkillStore, etc. are app-level repositories, not interview-scoped
3. **EventCoordinator for process orchestration** - Cross-component coordination uses events
4. **@Observable for UI reactivity** - SwiftUI's native reactivity for view state (best of both worlds)
5. **Handlers react to events** - Process coordination via events, UI updates via @Observable
6. **Tool execution in Tool Handler only** - Not sprinkled in UI

## Hybrid Pattern: Events + @Observable
**Use Events For:**
- Process orchestration (LLM request/response cycles)
- Cross-component coordination (state → multiple handlers)
- Business logic workflows (objective completion → next phase)
- Async operations (tool execution, API calls)

**Use @Observable For:**
- UI state that drives view updates
- Parent-child component data flow
- Form state, pending requests, active cards
- Any state consumed directly by SwiftUI views
- UI change detection tokens (version counters for triggering view updates)

**Why Hybrid?**
Events prevent tight coupling in business logic. @Observable prevents "CB radio"
UI updates. Each pattern plays to its strengths.

## Component Responsibilities

### StateCoordinator (actor) - Interview Workflow State
Manages **interview-scoped ephemeral state** that coordinates the onboarding workflow.

- **OWNS**: Interview workflow state (phases, objectives, artifacts, chat transcript)
- **ENCAPSULATES**: Interview-scoped stores (ObjectiveStore, ArtifactRepository, ChatTranscriptStore, StreamQueueManager, LLMStateManager, SessionUIState)
- **PROVIDES**: Delegation methods for interview state access
- **OWNS DIRECTLY**: currentPhase, wizardStep, evidenceRequirements (cross-cutting state)
- **APPLIES**: Phase scripts and emits transition events
- **SUBSCRIBES**: State.set(..), LLM.userMessageSent, Objective.ledger.update
- **PUBLISHES**: State.snapshot, State.allowedTools, Phase.transition.*, Objective.status.changed

### Interview-Scoped Stores (actors) - INTERNAL TO StateCoordinator
These stores manage ephemeral interview state and are encapsulated within StateCoordinator:

- **ObjectiveStore**: Objective ledger, status tracking, phase completion
- **ArtifactRepository**: Interview artifacts, enabled sections, custom field definitions
- **ChatTranscriptStore**: Message history, streaming state, response IDs
- **StreamQueueManager**: LLM request queue, tool response batching
- **LLMStateManager**: Allowed tools, model config, tool pane card state
- **SessionUIState**: Processing state, pending prompts, active flags

**Access Pattern for Interview State**:
- Interview state access SHOULD go through StateCoordinator's delegation methods
- Components receive `state: StateCoordinator` and use its public API
- This provides centralized coordination for workflow-affecting state changes

### Persisted Domain Stores - INDEPENDENT REPOSITORIES
These stores manage **persisted app-level data** that outlives the interview session.
They are NOT encapsulated by StateCoordinator - direct access is allowed.

- **KnowledgeCardStore**: Persisted knowledge cards (approved from interview or standalone ingestion)
- **SkillStore**: Persisted skills extracted from documents
- **ExperienceDefaultsStore**: Resume section defaults
- **ApplicantProfileStore**: User profile data

**Access Pattern for Persisted Stores**:
- **Reads**: Direct access allowed - components can query stores directly for display
- **Writes during interview**: Use events when mutations affect interview workflow
- **Writes outside interview**: Direct store mutations are fine (e.g., standalone KC browser)

**Why the distinction?**
- Interview-scoped state needs coordination (phase transitions, objective tracking)
- Persisted domain data is just CRUD - no workflow coordination needed
- SwiftData models are already @Observable - views react naturally to changes
- Forcing everything through StateCoordinator creates an unnecessary god object

### EventCoordinator (actor)
- **ONLY PUB/SUB MECHANISM** - All inter-component communication
- AsyncStream-based with topic filtering
- Topics: llm, toolpane, artifact, userInput, state, phase, objective, tool, timeline, processing

### Handlers (UI/Business)
- **Process state via events** - Business logic coordination uses EventCoordinator
- **UI state via @Observable** - View-consumed state uses SwiftUI reactivity
- **NO CROSS-HANDLER CALLS** - Handlers communicate via events, not direct calls
- Examples: LLM Messenger (events), ProfileInteractionHandler (@Observable UI state)

## Prohibited Patterns

### ❌ CRITICAL VIOLATIONS (Block commit):
```swift
// Direct mutation of INTERVIEW-SCOPED state outside StateCoordinator
class MyHandler {
    currentPhase = .phase2 // ❌ Only StateCoordinator coordinates interview workflow state
}

// Direct access to INTERVIEW-SCOPED stores (ObjectiveStore, ArtifactRepository, etc.)
class MyHandler {
    let objectiveStore: ObjectiveStore  // ❌ Interview-scoped store - should be in StateCoordinator
    func process() async {
        await objectiveStore.setStatus("id", .completed) // ❌ Use events for interview state
    }
}

// NOTE: This does NOT apply to persisted domain stores (KnowledgeCardStore, SkillStore)
// Those can be accessed directly - see "ALLOWED: Persisted Domain Store Access"

// Cross-component process coordination without events (Handler → Handler)
class HandlerA {
    func onObjectiveComplete() {
        llmHandler.sendNextMessage() // ❌ Must publish event to EventCoordinator
    }
}

// Direct tool service calls from UI (bypassing coordinator)
Button("Execute") {
    toolService.executeToolDirectly() // ❌ Must go through Coordinator, which uses events
}
// Note: UI → Coordinator methods for user actions are allowed (see ✅ ALLOWED section)

// Cross-handler direct calls
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Must use events for handler coordination
    }
}

// Synchronous blocking in actor
actor StateCoordinator {
    func update() {
        heavyWork() // ❌ Use async/await
    }
}
```

### ✅ ALLOWED: @Observable UI State
```swift
// UI state in handler (NOT a violation)
@MainActor
@Observable
class ProfileInteractionHandler {
    private(set) var pendingProfileSummary: JSON? // ✅ UI state for views
    private(set) var pendingIntakeRequest: Request? // ✅ UI state for views

    func showProfileSummary(profile: JSON) {
        pendingProfileSummary = profile // ✅ SwiftUI reactivity handles updates
    }
}

// UI change detection tokens (NOT a violation)
@Observable
class Coordinator {
    // ✅ ALLOWED: UI-only change tokens for SwiftUI reactivity
    private(set) var timelineUIChangeToken: Int = 0

    // When timeline events occur, update UI token for SwiftUI detection
    func handleEvent(_ event: Event) {
        switch event {
        case .timelineChanged:
            timelineUIChangeToken += 1 // ✅ UI state update for view reactivity
        }
    }
}

// View consumes via @Observable chain
struct ToolPaneView: View {
    @Bindable var coordinator: Coordinator

    var body: some View {
        if let summary = coordinator.toolRouter.profileHandler.pendingProfileSummary {
            SummaryCard(summary) // ✅ Automatic UI updates via @Observable
        }
    }
}
```

### ✅ ALLOWED: UI → Coordinator Method Calls
```swift
// User-initiated actions calling coordinator methods (NOT a violation)
struct ValidationCard: View {
    let coordinator: OnboardingInterviewCoordinator

    var body: some View {
        Button("Confirm") {
            Task {
                // ✅ ALLOWED: UI responding to user action by calling coordinator method
                await coordinator.submitValidationAndResume(
                    status: "confirmed",
                    updatedData: data,
                    changes: nil,
                    notes: nil
                )
            }
        }
    }
}

// Why this is allowed:
// 1. Not cross-handler communication (UI → Coordinator, not Handler → Handler)
// 2. User-initiated action (button click), not automatic workflow
// 3. Coordinator is @Observable with public API designed for UI interactions
// 4. Coordinator methods can still use events internally for cross-component coordination

// What's NOT allowed:
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Handler → Handler calls must use events
    }
}
```

### ✅ CORRECT PATTERNS:
```swift
// State changes through StateCoordinator
await stateCoordinator.apply(.setState(.phase2))

// Event-driven UI updates
await eventCoordinator.publish(.llmMessageReceived(text))

// Tool execution through event
await eventCoordinator.publish(.toolCallReceived(tool))

// Handler communication via events
for await event in eventCoordinator.stream(topic: .llm) {
    // React to event
}

// Stateless handler
@MainActor
class ChatboxHandler {
    func handleEvent(_ event: OnboardingEvent) async {
        // Pure reaction, no stored state
        await eventCoordinator.publish(response)
    }
}

// Direct store access via DependencyContainer for reads
class MyController {
    let container: OnboardingDependencyContainer

    // ✅ ALLOWED: Direct read access via container
    func checkStatus() async -> ObjectiveStatus? {
        await container.objectiveStore.getObjectiveStatus("applicant_profile")
    }
}

// StateCoordinator handles orchestration, not delegation
actor StateCoordinator {
    private let objectiveStore: ObjectiveStore

    // ✅ ALLOWED: Event-driven coordination
    private func handleObjectiveEvent(_ event: OnboardingEvent) async {
        switch event {
        case .objectiveStatusUpdateRequested(let id, let status, ...):
            await objectiveStore.setObjectiveStatus(id, status: status)
        }
    }
}
```

### ✅ ALLOWED: Persisted Domain Store Access
```swift
// Direct access to persisted domain stores (NOT a violation)
struct SkillsTabContent: View {
    let skillStore: SkillStore  // ✅ Persisted domain store

    var body: some View {
        // ✅ ALLOWED: Direct read from persisted store for display
        let approvedSkills = skillStore.fetchApproved()
        ForEach(approvedSkills) { skill in
            SkillRow(skill: skill)
        }
    }
}

class KnowledgeCardWorkflowService {
    let knowledgeCardStore: KnowledgeCardStore

    // ✅ ALLOWED: Direct CRUD on persisted domain data
    func approveCards(_ cards: [KnowledgeCard]) {
        for card in cards {
            card.status = .approved
        }
        knowledgeCardStore.save()
    }

    // ✅ ALLOWED: Direct deletion of persisted data
    func deleteCard(_ card: KnowledgeCard) {
        knowledgeCardStore.delete(card)
    }
}

// Why this is allowed:
// 1. KnowledgeCardStore, SkillStore are PERSISTED DOMAIN stores, not interview-scoped
// 2. They outlive the interview session - they're app-level repositories
// 3. SwiftData models are @Observable - views react to changes automatically
// 4. No workflow coordination needed for simple CRUD operations
// 5. StateCoordinator is for interview orchestration, not all data access

// When to STILL use events:
// - Mutations that affect interview workflow (e.g., card approval triggers objective completion)
// - Cross-component coordination during active interview
```

### ✅ ALLOWED: UI Handler Helper Methods
```swift
// ProfileInteractionHandler helper methods called from event handlers
class CoordinatorEventRouter {
    let toolRouter: ToolHandler

    // ✅ ALLOWED: Helper method calls for UI state cleanup
    func handleEvent(_ event: OnboardingEvent) async {
        switch event {
        case .objectiveStatusChanged(let id, _, let status, _, _, _, _):
            if id == "applicant_profile" && status == "completed" {
                // ✅ UI cleanup action triggered by event - not cross-handler coordination
                toolRouter.profileHandler.dismissProfileSummary()
            }
        }
    }
}

// Why this is allowed:
// 1. This is EVENT-DRIVEN - the handler is reacting to an event
// 2. dismissProfileSummary() is a UI cleanup helper, not process coordination
// 3. The pattern is: Event → Handler reacts → calls helper for UI state
// 4. NOT the same as Handler A calling Handler B to coordinate workflow
```

### ✅ ALLOWED: Event Handlers Updating @Observable UI State
```swift
// Event handler updating @Observable UI state directly (NOT a violation)
class CoordinatorEventRouter {
    let ui: OnboardingUIState  // @Observable UI state container

    func handleEvent(_ event: OnboardingEvent) async {
        switch event {
        case .planItemStatusChangeRequested(let itemId, let status):
            // ✅ ALLOWED: Event-driven update to @Observable UI state
            guard let index = ui.knowledgeCardPlan.firstIndex(where: { $0.id == itemId }) else { return }
            ui.knowledgeCardPlan[index] = updatedItem
        }
    }
}

// Why this is allowed:
// 1. This is EVENT-DRIVEN - an event triggers the handler, not a direct call
// 2. ui.knowledgeCardPlan is @Observable UI state consumed by SwiftUI views
// 3. Pattern: Event published → Handler receives → Updates UI state → SwiftUI reacts
// 4. This is NOT "business logic workflow" (like phase transitions) - it's UI display state
// 5. Handlers with @Observable UI state references are allowed when updating view-consumed state

// What makes this DIFFERENT from a violation:
// - ❌ Violation: Handler A directly calls Handler B for process coordination
// - ✅ Allowed: Event triggers handler, handler updates @Observable UI state
```

### ✅ ALLOWED: Handlers with UI State References
```swift
// Handlers may hold references to @Observable UI state containers (NOT a violation)
class ProfilePersistenceHandler {
    let ui: OnboardingUIState  // ✅ Reference to UI state for view updates

    func handleEvent(_ event: OnboardingEvent) async {
        switch event {
        case .profileValidated(let profile):
            // ✅ ALLOWED: Updating UI state in response to event
            ui.validatedProfile = profile
        }
    }
}

// Why this is allowed:
// 1. The handler reacts to EVENTS, not direct calls from other handlers
// 2. UI state updates are for SwiftUI view reactivity, not process coordination
// 3. This enables the hybrid pattern: events for coordination + @Observable for UI
```

## Data Contracts
- Use typed payloads (MessagePayload, OnboardingPhaseSpec, ToolPaneCardDescriptor)
- Avoid `Any` in event payloads
- Events specify their topic explicitly

## Phase & Tool Validation
- Tool calls MUST validate against StateCoordinator.allowedTools
- Phase transitions emit Phase.transition.requested → Phase.transition.applied
- All state updates are idempotent

## References
- StateCoordinator: Section 4.1
- EventCoordinator: Section 4.2  
- AsyncStream architecture: Implementation notes 2025-11-03
- Core sequences: Section 7
