# Hybrid Event-Driven + Reactive Architecture

## Core Tenets
1. **StateCoordinator (actor) is the SINGLE SOURCE OF TRUTH** - All state access flows through it; components MUST NOT access domain stores directly
2. **EventCoordinator for process orchestration** - Cross-component coordination uses events
3. **@Observable for UI reactivity** - SwiftUI's native reactivity for view state (best of both worlds)
4. **Handlers react to events** - Process coordination via events, UI updates via @Observable
5. **Tool execution in Tool Handler only** - Not sprinkled in UI

## Hybrid Pattern: Events + @Observable
**Use Events For:**
- Process orchestration (LLM request/response cycles)
- Cross-component coordination (state → multiple handlers)
- Business logic workflows (objective completion → next phase)
- Async operations (tool execution, API calls)

**Use @Observable For:**
- UI state that drives view updates
- Parent-child component data flow
- Form state, pending requests, active cards
- Any state consumed directly by SwiftUI views
- UI change detection tokens (version counters for triggering view updates)

**Why Hybrid?**
Events prevent tight coupling in business logic. @Observable prevents "CB radio"
UI updates. Each pattern plays to its strengths.

## Component Responsibilities

### StateCoordinator (actor) - SINGLE SOURCE OF TRUTH
- **OWNS ALL STATE ACCESS**: All reads and writes flow through StateCoordinator's public API
- **ENCAPSULATES**: Domain-specific stores (ObjectiveStore, ArtifactRepository, ChatTranscriptStore, StreamQueueManager, LLMStateManager, SessionUIState, DraftKnowledgeStore)
- **PROVIDES**: Delegation methods that serve as the single access point for all state
- **OWNS DIRECTLY**: currentPhase, wizardStep, evidenceRequirements (cross-cutting state)
- **APPLIES**: Phase scripts and emits transition events
- **SUBSCRIBES**: State.set(..), LLM.userMessageSent, Objective.ledger.update
- **PUBLISHES**: State.snapshot, State.allowedTools, Phase.transition.*, Objective.status.changed

### Domain-Specific Stores (actors) - INTERNAL IMPLEMENTATION
StateCoordinator encapsulates specialized stores for domain isolation and testability.
**These stores are PRIVATE to StateCoordinator - external components MUST NOT access them directly.**

- **ObjectiveStore**: Objective ledger, status tracking, phase completion
- **ArtifactRepository**: Artifacts, knowledge cards, timeline sync
- **ChatTranscriptStore**: Message history, streaming state, response IDs
- **StreamQueueManager**: LLM request queue, tool response batching
- **LLMStateManager**: Allowed tools, model config, tool pane card state
- **SessionUIState**: Processing state, pending prompts, active flags
- **DraftKnowledgeStore**: Draft knowledge cards pending approval

**Access Pattern - MANDATORY**:
- All state access MUST go through StateCoordinator's delegation methods
- Components receive `state: StateCoordinator` and use its public API (e.g., `state.getObjectiveStatus()`, `state.artifacts`, `state.messages`)
- This provides a single point of access for debugging, logging, and future enhancements
- The delegation methods ARE the encapsulation layer - they are not redundant

### EventCoordinator (actor)
- **ONLY PUB/SUB MECHANISM** - All inter-component communication
- AsyncStream-based with topic filtering
- Topics: llm, toolpane, artifact, userInput, state, phase, objective, tool, timeline, processing

### Handlers (UI/Business)
- **Process state via events** - Business logic coordination uses EventCoordinator
- **UI state via @Observable** - View-consumed state uses SwiftUI reactivity
- **NO CROSS-HANDLER CALLS** - Handlers communicate via events, not direct calls
- Examples: LLM Messenger (events), ProfileInteractionHandler (@Observable UI state)

## Prohibited Patterns

### ❌ CRITICAL VIOLATIONS (Block commit):
```swift
// Direct state mutation in wrong place
class MyHandler {
    currentPhase = .phase2 // ❌ Only StateCoordinator coordinates global state
}

// Handlers mutating global state without going through events
class MyHandler {
    let objectiveStore: ObjectiveStore
    func process() async {
        await objectiveStore.setStatus("id", .completed) // ❌ State mutations should use events
    }
}

// Cross-component process coordination without events (Handler → Handler)
class HandlerA {
    func onObjectiveComplete() {
        llmHandler.sendNextMessage() // ❌ Must publish event to EventCoordinator
    }
}

// Direct tool service calls from UI (bypassing coordinator)
Button("Execute") {
    toolService.executeToolDirectly() // ❌ Must go through Coordinator, which uses events
}
// Note: UI → Coordinator methods for user actions are allowed (see ✅ ALLOWED section)

// Cross-handler direct calls
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Must use events for handler coordination
    }
}

// Synchronous blocking in actor
actor StateCoordinator {
    func update() {
        heavyWork() // ❌ Use async/await
    }
}
```

### ✅ ALLOWED: @Observable UI State
```swift
// UI state in handler (NOT a violation)
@MainActor
@Observable
class ProfileInteractionHandler {
    private(set) var pendingProfileSummary: JSON? // ✅ UI state for views
    private(set) var pendingIntakeRequest: Request? // ✅ UI state for views

    func showProfileSummary(profile: JSON) {
        pendingProfileSummary = profile // ✅ SwiftUI reactivity handles updates
    }
}

// UI change detection tokens (NOT a violation)
@Observable
class Coordinator {
    // ✅ ALLOWED: UI-only change tokens for SwiftUI reactivity
    private(set) var timelineUIChangeToken: Int = 0

    // When timeline events occur, update UI token for SwiftUI detection
    func handleEvent(_ event: Event) {
        switch event {
        case .timelineChanged:
            timelineUIChangeToken += 1 // ✅ UI state update for view reactivity
        }
    }
}

// View consumes via @Observable chain
struct ToolPaneView: View {
    @Bindable var coordinator: Coordinator

    var body: some View {
        if let summary = coordinator.toolRouter.profileHandler.pendingProfileSummary {
            SummaryCard(summary) // ✅ Automatic UI updates via @Observable
        }
    }
}
```

### ✅ ALLOWED: UI → Coordinator Method Calls
```swift
// User-initiated actions calling coordinator methods (NOT a violation)
struct ValidationCard: View {
    let coordinator: OnboardingInterviewCoordinator

    var body: some View {
        Button("Confirm") {
            Task {
                // ✅ ALLOWED: UI responding to user action by calling coordinator method
                await coordinator.submitValidationAndResume(
                    status: "confirmed",
                    updatedData: data,
                    changes: nil,
                    notes: nil
                )
            }
        }
    }
}

// Why this is allowed:
// 1. Not cross-handler communication (UI → Coordinator, not Handler → Handler)
// 2. User-initiated action (button click), not automatic workflow
// 3. Coordinator is @Observable with public API designed for UI interactions
// 4. Coordinator methods can still use events internally for cross-component coordination

// What's NOT allowed:
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Handler → Handler calls must use events
    }
}
```

### ✅ CORRECT PATTERNS:
```swift
// State changes through StateCoordinator
await stateCoordinator.apply(.setState(.phase2))

// Event-driven UI updates
await eventCoordinator.publish(.llmMessageReceived(text))

// Tool execution through event
await eventCoordinator.publish(.toolCallReceived(tool))

// Handler communication via events
for await event in eventCoordinator.stream(topic: .llm) {
    // React to event
}

// Stateless handler
@MainActor
class ChatboxHandler {
    func handleEvent(_ event: OnboardingEvent) async {
        // Pure reaction, no stored state
        await eventCoordinator.publish(response)
    }
}

// Direct store access via DependencyContainer for reads
class MyController {
    let container: OnboardingDependencyContainer

    // ✅ ALLOWED: Direct read access via container
    func checkStatus() async -> ObjectiveStatus? {
        await container.objectiveStore.getObjectiveStatus("applicant_profile")
    }
}

// StateCoordinator handles orchestration, not delegation
actor StateCoordinator {
    private let objectiveStore: ObjectiveStore

    // ✅ ALLOWED: Event-driven coordination
    private func handleObjectiveEvent(_ event: OnboardingEvent) async {
        switch event {
        case .objectiveStatusUpdateRequested(let id, let status, ...):
            await objectiveStore.setObjectiveStatus(id, status: status)
        }
    }
}
```

### ✅ ALLOWED: Global App Store Access for Output Persistence
```swift
// Onboarding produces output that persists to main app stores
// These are NOT onboarding-internal stores - they are final output destinations
class CoordinatorEventRouter {
    let resRefStore: ResRefStore      // Global app store (in DataManagers/)
    let coverRefStore: CoverRefStore  // Global app store (in DataManagers/)

    // ✅ ALLOWED: Direct writes to global app stores for onboarding output
    func persistKnowledgeCard(card: JSON) {
        let resRef = ResRef(from: card)
        resRefStore.addResRef(resRef) // ✅ Output persistence to main app
    }

    // ✅ ALLOWED: Direct writes for writing sample persistence
    func persistWritingSample(sample: JSON) {
        let coverRef = CoverRef(from: sample)
        coverRefStore.addCoverRef(coverRef) // ✅ Output persistence to main app
    }
}

// Why this is allowed:
// 1. ResRefStore, CoverRefStore are GLOBAL APP stores (in DataManagers/), not onboarding-internal
// 2. Onboarding is a PRODUCER of data for the main app, not just internal state management
// 3. StateCoordinator encapsulates onboarding-INTERNAL stores; output stores are different
// 4. This is the "export" boundary where onboarding delivers its results
```

### ✅ ALLOWED: UI Handler Helper Methods
```swift
// ProfileInteractionHandler helper methods called from event handlers
class CoordinatorEventRouter {
    let toolRouter: ToolHandler

    // ✅ ALLOWED: Helper method calls for UI state cleanup
    func handleEvent(_ event: OnboardingEvent) async {
        switch event {
        case .objectiveStatusChanged(let id, _, let status, _, _, _, _):
            if id == "applicant_profile" && status == "completed" {
                // ✅ UI cleanup action triggered by event - not cross-handler coordination
                toolRouter.profileHandler.dismissProfileSummary()
            }
        }
    }
}

// Why this is allowed:
// 1. This is EVENT-DRIVEN - the handler is reacting to an event
// 2. dismissProfileSummary() is a UI cleanup helper, not process coordination
// 3. The pattern is: Event → Handler reacts → calls helper for UI state
// 4. NOT the same as Handler A calling Handler B to coordinate workflow
```

## Data Contracts
- Use typed payloads (MessagePayload, OnboardingPhaseSpec, ToolPaneCardDescriptor)
- Avoid `Any` in event payloads
- Events specify their topic explicitly

## Phase & Tool Validation
- Tool calls MUST validate against StateCoordinator.allowedTools
- Phase transitions emit Phase.transition.requested → Phase.transition.applied
- All state updates are idempotent

## References
- StateCoordinator: Section 4.1
- EventCoordinator: Section 4.2  
- AsyncStream architecture: Implementation notes 2025-11-03
- Core sequences: Section 7
