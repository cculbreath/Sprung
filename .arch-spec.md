# Hybrid Event-Driven + Reactive Architecture

## Core Tenets
1. **StateCoordinator (actor) is the ONLY source of truth** - All state changes flow through it
2. **EventCoordinator for process orchestration** - Cross-component coordination uses events
3. **@Observable for UI reactivity** - SwiftUI's native reactivity for view state (best of both worlds)
4. **Handlers react to events** - Process coordination via events, UI updates via @Observable
5. **Tool execution in Tool Handler only** - Not sprinkled in UI

## Hybrid Pattern: Events + @Observable
**Use Events For:**
- Process orchestration (LLM request/response cycles)
- Cross-component coordination (state → multiple handlers)
- Business logic workflows (objective completion → next phase)
- Async operations (tool execution, API calls)

**Use @Observable For:**
- UI state that drives view updates
- Parent-child component data flow
- Form state, pending requests, active cards
- Any state consumed directly by SwiftUI views
- UI change detection tokens (version counters for triggering view updates)

**Why Hybrid?**
Events prevent tight coupling in business logic. @Observable prevents "CB radio"
UI updates. Each pattern plays to its strengths.

## Component Responsibilities

### StateCoordinator (actor)
- **OWNS**: currentSystemPrompt, allowedTools, currentPhase, nextPhase, objective ledger
- **APPLIES**: Phase scripts and emits transition events
- **SUBSCRIBES**: State.set(..), LLM.userMessageSent, Objective.ledger.update
- **PUBLISHES**: State.snapshot, State.allowedTools, Phase.transition.*, Objective.status.changed

### EventCoordinator (actor)
- **ONLY PUB/SUB MECHANISM** - All inter-component communication
- AsyncStream-based with topic filtering
- Topics: llm, toolpane, artifact, userInput, state, phase, objective, tool, timeline, processing

### Handlers (UI/Business)
- **Process state via events** - Business logic coordination uses EventCoordinator
- **UI state via @Observable** - View-consumed state uses SwiftUI reactivity
- **NO CROSS-HANDLER CALLS** - Handlers communicate via events, not direct calls
- Examples: LLM Messenger (events), ProfileInteractionHandler (@Observable UI state)

## Prohibited Patterns

### ❌ CRITICAL VIOLATIONS (Block commit):
```swift
// Direct state mutation in wrong place
class MyHandler {
    currentPhase = .phase2 // ❌ Only StateCoordinator mutates global state
}

// Cross-component process coordination without events (Handler → Handler)
class HandlerA {
    func onObjectiveComplete() {
        llmHandler.sendNextMessage() // ❌ Must publish event to EventCoordinator
    }
}

// Direct tool service calls from UI (bypassing coordinator)
Button("Execute") {
    toolService.executeToolDirectly() // ❌ Must go through Coordinator, which uses events
}
// Note: UI → Coordinator methods for user actions are allowed (see ✅ ALLOWED section)

// Cross-handler direct calls
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Must use events for handler coordination
    }
}

// Synchronous blocking in actor
actor StateCoordinator {
    func update() {
        heavyWork() // ❌ Use async/await
    }
}
```

### ✅ ALLOWED: @Observable UI State
```swift
// UI state in handler (NOT a violation)
@MainActor
@Observable
class ProfileInteractionHandler {
    private(set) var pendingProfileSummary: JSON? // ✅ UI state for views
    private(set) var pendingIntakeRequest: Request? // ✅ UI state for views

    func showProfileSummary(profile: JSON) {
        pendingProfileSummary = profile // ✅ SwiftUI reactivity handles updates
    }
}

// UI change detection tokens (NOT a violation)
@Observable
class Coordinator {
    // ✅ ALLOWED: UI-only change tokens for SwiftUI reactivity
    private(set) var timelineUIChangeToken: Int = 0

    // When timeline events occur, update UI token for SwiftUI detection
    func handleEvent(_ event: Event) {
        switch event {
        case .timelineChanged:
            timelineUIChangeToken += 1 // ✅ UI state update for view reactivity
        }
    }
}

// View consumes via @Observable chain
struct ToolPaneView: View {
    @Bindable var coordinator: Coordinator

    var body: some View {
        if let summary = coordinator.toolRouter.profileHandler.pendingProfileSummary {
            SummaryCard(summary) // ✅ Automatic UI updates via @Observable
        }
    }
}
```

### ✅ ALLOWED: UI → Coordinator Method Calls
```swift
// User-initiated actions calling coordinator methods (NOT a violation)
struct ValidationCard: View {
    let coordinator: OnboardingInterviewCoordinator

    var body: some View {
        Button("Confirm") {
            Task {
                // ✅ ALLOWED: UI responding to user action by calling coordinator method
                await coordinator.submitValidationAndResume(
                    status: "confirmed",
                    updatedData: data,
                    changes: nil,
                    notes: nil
                )
            }
        }
    }
}

// Why this is allowed:
// 1. Not cross-handler communication (UI → Coordinator, not Handler → Handler)
// 2. User-initiated action (button click), not automatic workflow
// 3. Coordinator is @Observable with public API designed for UI interactions
// 4. Coordinator methods can still use events internally for cross-component coordination

// What's NOT allowed:
class HandlerA {
    let handlerB: HandlerB
    func process() {
        handlerB.doSomething() // ❌ Handler → Handler calls must use events
    }
}
```

### ✅ CORRECT PATTERNS:
```swift
// State changes through StateCoordinator
await stateCoordinator.apply(.setState(.phase2))

// Event-driven UI updates
await eventCoordinator.publish(.llmMessageReceived(text))

// Tool execution through event
await eventCoordinator.publish(.toolCallReceived(tool))

// Handler communication via events
for await event in eventCoordinator.stream(topic: .llm) {
    // React to event
}

// Stateless handler
@MainActor
class ChatboxHandler {
    func handleEvent(_ event: OnboardingEvent) async {
        // Pure reaction, no stored state
        await eventCoordinator.publish(response)
    }
}
```

## Data Contracts
- Use typed payloads (MessagePayload, OnboardingPhaseSpec, ToolPaneCardDescriptor)
- Avoid `Any` in event payloads
- Events specify their topic explicitly

## Phase & Tool Validation
- Tool calls MUST validate against StateCoordinator.allowedTools
- Phase transitions emit Phase.transition.requested → Phase.transition.applied
- All state updates are idempotent

## References
- StateCoordinator: Section 4.1
- EventCoordinator: Section 4.2  
- AsyncStream architecture: Implementation notes 2025-11-03
- Core sequences: Section 7
