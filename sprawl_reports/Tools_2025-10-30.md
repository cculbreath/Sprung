# Code Sprawl Analysis Report
**Directory**: `./Sprung/Onboarding/Tools/`
**Analysis Date**: 2025-10-30
**Files Examined**: 14

## ✅ COMPLETED REFACTORING (2025-10-30)
**Quick Wins Implemented:**
1. Deleted unused `defaultPrompt()` function in GetUserUploadTool.swift (-22 LOC)
2. Removed redundant error re-throwing in SetObjectiveStatusTool.swift (-8 LOC)
3. Created ToolPayloadBuilder.swift utility (+104 LOC of reusable helpers)

**Status**: Tools directory reduced from 1,708 → 1,782 LOC (net +74 due to utility addition, but enables ~180 LOC reduction when applied)

## Executive Summary
- Total LOC in directory: 1,782 (adjusted for utility addition)
- Estimated reducible LOC: 390 (21.9%, was 420)
- High-priority issues: 6 (was 8, completed 2)
- Medium-priority issues: 12
- Low-priority issues: 6

## Key Findings

The Tools directory shows **moderate code sprawl** with several recurring patterns:

1. **Duplicated JSON response building** across 8 files (~180 LOC)
2. **Redundant parameter validation** logic repeated in 9 tools (~120 LOC)
3. **Copy-pasted continuation token patterns** in 6 tools (~90 LOC)
4. **Overly verbose payload parsing** structs that could be simplified (~80 LOC)
5. **Inconsistent error handling** with different approaches per tool

The infrastructure files (ToolProtocol, ToolRegistry, ToolExecutor) are **well-designed and concise** with no significant issues.

---

## Infrastructure Files

### ToolProtocol.swift
**Current LOC**: 63
**Estimated reducible LOC**: 0

#### Issues Found
None. This file demonstrates clean protocol design with appropriate abstractions.

---

### ToolRegistry.swift
**Current LOC**: 51
**Estimated reducible LOC**: 0

#### Issues Found
None. Clean, thread-safe registry implementation with appropriate synchronization primitives.

---

### ToolExecutor.swift
**Current LOC**: 96
**Estimated reducible LOC**: 15

#### Issues Found

1. **Duplicated Error Handling Logic** (Priority: Low)
   - **Lines**: 59-95
   - **Problem**: The `errorResult` method builds JSON responses manually with repetitive field assignments. While functional, it's verbose.
   - **Recommendation**: Extract to a `ToolResult.error` factory method or use a `JSONEncoder` approach for error payloads.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction + improved consistency
   - **Example**:
     ```swift
     // Before
     var payload = JSON()
     payload["status"].string = "error"
     payload["reason"].string = reason
     payload["message"].string = message
     payload["tool"].string = toolName

     // After (with factory)
     let payload = ToolResult.errorPayload(reason: reason, message: message, tool: toolName)
     ```

2. **Unnecessary normalize method** (Priority: Low)
   - **Lines**: 47-57
   - **Problem**: The normalize method essentially just stores continuations and passes through most results. The logic could be inlined.
   - **Recommendation**: Consider whether this abstraction adds value or just adds an extra function call.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction
   - **Not Recommended**: This abstraction may be preparing for future middleware. Keep unless proven unnecessary.

---

## Tool Implementations

### GetMacOSContactCardTool.swift
**Current LOC**: 155
**Estimated reducible LOC**: 35

#### Issues Found

1. **Duplicated JSON Response Building** (Priority: High)
   - **Lines**: 122-155
   - **Problem**: The `makeResponse` function manually constructs nested JSON with repetitive field assignments. This pattern appears in 7+ tools.
   - **Recommendation**: Create a shared `JSONBuilder` utility with helpers for common patterns like `addStringArray`, `addLabeledValues`, etc.
   - **Effort**: Medium (requires extracting shared utility)
   - **Impact**: ~25 LOC reduction in this file, ~180 LOC total across Tools directory

2. **Overly Specific Error Cases** (Priority: Medium)
   - **Lines**: 59-63
   - **Problem**: Private `ContactError` enum duplicates error information already in ToolError. Three custom error cases for relatively simple scenarios.
   - **Recommendation**: Use ToolError directly with descriptive messages. Remove ContactError enum.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction
   - **Example**:
     ```swift
     // Before
     enum ContactError: Error {
         case denied
         case notFound
         case other(Error)
     }

     // After - just throw ToolError directly
     throw ToolError.permissionDenied("Contacts access denied")
     throw ToolError.executionFailed("Contact not found")
     ```

3. **Unused CardType.specific** (Priority: Medium)
   - **Lines**: 37-39, 66-69
   - **Problem**: The schema includes `specific` as a cardType option, but execution immediately returns `.executionFailed("not implemented yet")`. This is dead code.
   - **Recommendation**: Either implement it or remove it from the schema. If truly planned for future, add a FIXME comment.
   - **Effort**: Low
   - **Impact**: Removes confusion, no LOC change

---

### PersistDataTool.swift
**Current LOC**: 67
**Estimated reducible LOC**: 10

#### Issues Found

1. **Redundant Parameter Validation** (Priority: Medium)
   - **Lines**: 46-53
   - **Problem**: Manual guard statements for parameter validation. This pattern repeats across 9 tools with slight variations.
   - **Recommendation**: Create a `ParameterValidator` utility with methods like `requireString(_ key:)`, `requireObject(_ key:)`.
   - **Effort**: Medium (requires shared utility)
   - **Impact**: ~10 LOC reduction per tool using it

2. **Over-nested Response Building** (Priority: Low)
   - **Lines**: 57-60
   - **Problem**: Three levels of nested dictionary access to build response: `response["persisted"]["id"]`, etc.
   - **Recommendation**: Use a response builder or flatten the structure.
   - **Effort**: Low
   - **Impact**: Improved readability, ~5 LOC reduction

---

### SetObjectiveStatusTool.swift
**Current LOC**: 53
**Estimated reducible LOC**: 8

#### Issues Found

1. **Redundant Error Re-throwing** (Priority: Medium)
   - **Lines**: 44-51
   - **Problem**: Catches ToolError just to re-throw it, catches other errors to wrap them. This is a common Swift pattern but adds no value here.
   - **Recommendation**: Let errors propagate naturally. The errorResult handler in ToolExecutor already handles all error types.
   - **Effort**: Low
   - **Impact**: ~8 LOC reduction
   - **Example**:
     ```swift
     // Before
     do {
         let result = try await service.updateObjectiveStatus(...)
         return .immediate(result)
     } catch let error as ToolError {
         throw error
     } catch {
         throw ToolError.executionFailed(error.localizedDescription)
     }

     // After
     let result = try await service.updateObjectiveStatus(...)
     return .immediate(result)
     ```

---

### ExtractDocumentTool.swift
**Current LOC**: 147
**Estimated reducible LOC**: 30

#### Issues Found

1. **Complex Response Building Logic** (Priority: High)
   - **Lines**: 83-146
   - **Problem**: 64 lines of manual JSON construction with conditional logic for return types. The `buildResponse`, `makeArtifactJSON`, and `makeMetadataJSON` methods are verbose.
   - **Recommendation**: Use Codable structs for response types, or extract to a shared ResponseBuilder.
   - **Effort**: Medium
   - **Impact**: ~25 LOC reduction

2. **Redundant Return Type Filtering** (Priority: Medium)
   - **Lines**: 87-90
   - **Problem**: Normalizes return types, creates a Set, then checks each one individually. The logic could be cleaner.
   - **Recommendation**: Simplify to a single lookup: `let shouldInclude = returnTypes.isEmpty || returnTypes.contains(type)`
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

---

### GenerateKnowledgeCardTool.swift
**Current LOC**: 70
**Estimated reducible LOC**: 5

#### Issues Found

1. **Unnecessary agentProvider Closure** (Priority: Low)
   - **Lines**: 32, 47-49
   - **Problem**: Uses a closure `() -> KnowledgeCardAgent?` instead of passing the agent directly. This indirection adds complexity without clear benefit.
   - **Recommendation**: If the agent can change, document why. Otherwise, pass it directly as a property.
   - **Effort**: Low
   - **Impact**: Improved clarity, ~5 LOC with simplified init

**Note**: This is one of the cleanest tool implementations. Good example to follow.

---

### GetApplicantProfileTool.swift
**Current LOC**: 48
**Estimated reducible LOC**: 0

#### Issues Found
No significant issues found. This is a well-structured, minimal tool implementation.

---

### GetUserOptionTool.swift
**Current LOC**: 161
**Estimated reducible LOC**: 40

#### Issues Found

1. **Overly Verbose Payload Struct** (Priority: High)
   - **Lines**: 108-161
   - **Problem**: The `OptionPromptPayload` struct takes 54 lines for what is essentially parameter parsing. Nested `Option` struct adds another layer.
   - **Recommendation**: Simplify by parsing directly in `execute()` or create a lightweight validator.
   - **Effort**: Medium
   - **Impact**: ~30 LOC reduction

2. **Duplicated Continuation Pattern** (Priority: High)
   - **Lines**: 75-104
   - **Problem**: The waiting payload + continuation token creation pattern is nearly identical across 6 tools (GetUserOption, GetUserUpload, GetApplicantProfile, SubmitForValidation, ValidateApplicantProfile, NextPhase).
   - **Recommendation**: Extract to `ContinuationToken.withWaiting(...)` factory method.
   - **Effort**: Medium
   - **Impact**: ~10 LOC per tool = ~60 LOC total reduction

3. **Unused dateFormatter** (Priority: Low)
   - **Lines**: 52-56
   - **Problem**: dateFormatter is initialized with specific format options but only used once in the resumeHandler (line 99). The configuration is more complex than needed.
   - **Recommendation**: Use `ISO8601DateFormatter()` inline or justify the custom configuration.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

---

### GetUserUploadTool.swift
**Current LOC**: 273
**Estimated reducible LOC**: 80

#### Issues Found

1. **Massive UploadRequestPayload Struct** (Priority: High)
   - **Lines**: 128-223
   - **Problem**: 96 lines for parameter parsing. Contains two large switch statements (lines 178-199, 201-222) that map upload kinds to titles and prompts. These are never used together.
   - **Recommendation**:
     - Split into smaller focused structs
     - Move title/prompt mappings to a separate lookup table or extension on `OnboardingUploadKind`
     - The `defaultPrompt` function (201-222) appears unused - verify and remove
   - **Effort**: Medium
   - **Impact**: ~50 LOC reduction

2. **Duplicated Continuation Token Pattern** (Priority: High)
   - **Lines**: 76-121
   - **Problem**: Same verbose continuation pattern as GetUserOptionTool.
   - **Recommendation**: Use shared factory method.
   - **Effort**: Medium (once factory exists)
   - **Impact**: ~15 LOC reduction

3. **Complex Nested Status Handling** (Priority: Medium)
   - **Lines**: 91-118
   - **Problem**: The resumeHandler has deeply nested switch/try/catch logic. The UploadUserResponse parsing could be simpler.
   - **Recommendation**: Extract status handling to separate methods or simplify UploadUserResponse.
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction

4. **Dead Code - defaultPrompt** (Priority: Medium)
   - **Lines**: 201-222
   - **Problem**: The `defaultPrompt` function is never called. The `prompt` is always required from JSON (line 146).
   - **Recommendation**: Remove if truly unused. If it's defensive code for future use, move to a separate defaults file.
   - **Effort**: Low
   - **Impact**: ~22 LOC reduction

---

### NextPhaseTool.swift
**Current LOC**: 153
**Estimated reducible LOC**: 35

#### Issues Found

1. **Excessive Branching Logic** (Priority: High)
   - **Lines**: 41-115
   - **Problem**: The execute method has 7 different conditional branches checking various phase advance scenarios. This is hard to follow and test.
   - **Recommendation**: Extract each branch to a named method like `handleAlreadyComplete()`, `handleAwaitingApproval()`, `handleCachedResponse()`, etc.
   - **Effort**: Medium
   - **Impact**: ~25 LOC reduction through consolidation

2. **Duplicated Response Building** (Priority: Medium)
   - **Lines**: 42-45, 52-56, 66-68, 82-86, 92-94, 98-102, 109-113
   - **Problem**: Seven different places build nearly identical "blocked" or "status" responses with slight variations.
   - **Recommendation**: Create factory methods: `Response.blocked(missing:overrides:message:)`, `Response.approved(phase:)`, etc.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction

---

### SubmitForValidationTool.swift
**Current LOC**: 242
**Estimated reducible LOC**: 60

#### Issues Found

1. **Overly Complex Missing Payload Handling** (Priority: High)
   - **Lines**: 65-88
   - **Problem**: 24 lines handling the case where data is null, including retry tracking, fallback logic, and message construction. This is business logic embedded in a tool.
   - **Recommendation**: Move retry/fallback logic to the service layer. The tool should just validate and fail fast.
   - **Effort**: Medium
   - **Impact**: ~20 LOC reduction

2. **Duplicated Auto-Approval Logic** (Priority: High)
   - **Lines**: 91-127
   - **Problem**: This block checks for "user_validated" status and auto-approves. ValidateApplicantProfileTool (lines 58-65) has nearly identical logic. This is duplication.
   - **Recommendation**: Extract to a shared validation helper or consolidate these two tools.
   - **Effort**: High (design decision needed)
   - **Impact**: ~30 LOC reduction if tools are merged

3. **Long Continuation Handler** (Priority: Medium)
   - **Lines**: 154-186
   - **Problem**: 33 lines of resumeHandler logic with complex conditional handling.
   - **Recommendation**: Extract to a named method like `handleValidationResponse(input:)`.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction through readability improvement

4. **ValidationPayload Struct Redundancy** (Priority: Medium)
   - **Lines**: 193-242
   - **Problem**: The `ValidationPayload` struct has multiple properties that are variations of the same data: `dataType`, `canonicalType`, `normalizedType`. The `isApplicantProfile` computed property checks normalizedType.
   - **Recommendation**: Consolidate to a single canonical representation.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

---

### ValidateApplicantProfileTool.swift
**Current LOC**: 129
**Estimated reducible LOC**: 35

#### Issues Found

1. **Tool Overlap with SubmitForValidationTool** (Priority: High)
   - **Lines**: 49-110
   - **Problem**: This tool and SubmitForValidationTool have significant overlap. Both handle applicant profile validation, both check for "user_validated" status, both present UI and wait for continuation.
   - **Recommendation**: Consider merging into a single tool or making this a specialized variant that delegates to SubmitForValidationTool.
   - **Effort**: High (requires design discussion)
   - **Impact**: Could eliminate this entire file (~129 LOC) or reduce significantly

2. **Duplicated Auto-Approval Logic** (Priority: High)
   - **Lines**: 58-65
   - **Problem**: Identical to SubmitForValidationTool lines 101-127.
   - **Recommendation**: Extract to shared helper method.
   - **Effort**: Medium
   - **Impact**: ~10 LOC reduction

3. **Complex Schema with Verbose Description** (Priority: Low)
   - **Lines**: 6-34
   - **Problem**: The schema description is 5 lines of text explaining when NOT to call the tool. This suggests the tool's responsibility is unclear.
   - **Recommendation**: Clarify tool boundaries. If the coordinator already validated data, why does this tool exist?
   - **Effort**: Low (documentation/design clarity)
   - **Impact**: May reveal this tool is unnecessary

---

## Cross-Cutting Patterns

### Pattern 1: Manual JSON Response Building (8 files)
**Files**: GetMacOSContactCardTool, ExtractDocumentTool, PersistDataTool, GetUserOptionTool, GetUserUploadTool, NextPhaseTool, SubmitForValidationTool, ValidateApplicantProfileTool

**Problem**: Every tool manually constructs JSON responses with repetitive:
```swift
var response = JSON()
response["status"].string = "..."
response["field"].string = "..."
return .immediate(response)
```

**Impact**: ~180 LOC across 8 files

**Solution**: Create a `ToolResponseBuilder` utility:
```swift
// Proposed utility
struct ToolResponseBuilder {
    private var json = JSON()

    func with(status: String) -> Self { /* */ }
    func with(_ key: String, value: Any?) -> Self { /* */ }
    func build() -> JSON { json }
}

// Usage
return .immediate(
    ToolResponseBuilder()
        .with(status: "approved")
        .with("data", value: sanitized)
        .build()
)
```

---

### Pattern 2: Duplicated Parameter Validation (9 files)
**Files**: GetMacOSContactCardTool, PersistDataTool, SetObjectiveStatusTool, ExtractDocumentTool, GetUserOptionTool, GetUserUploadTool, NextPhaseTool, SubmitForValidationTool, ValidateApplicantProfileTool

**Problem**: Every tool has 5-15 lines of guard statements validating JSON parameters:
```swift
guard let param = json["key"].string, !param.isEmpty else {
    throw ToolError.invalidParameters("key must be provided")
}
```

**Impact**: ~120 LOC across 9 files

**Solution**: Create a `JSONParameterValidator`:
```swift
struct JSONParameterValidator {
    let json: JSON

    func requireString(_ key: String) throws -> String { /* */ }
    func requireObject(_ key: String) throws -> JSON { /* */ }
    func optionalString(_ key: String, default: String) -> String { /* */ }
}
```

---

### Pattern 3: Duplicated Continuation Token Patterns (6 files)
**Files**: GetUserOptionTool, GetUserUploadTool, GetApplicantProfileTool, NextPhaseTool, SubmitForValidationTool, ValidateApplicantProfileTool

**Problem**: Each tool creates waiting payload + continuation token with nearly identical structure:
```swift
var waitingPayload = JSON()
waitingPayload["status"].string = "waiting"
waitingPayload["tool"].string = name
waitingPayload["message"].string = "..."

let token = ContinuationToken(
    id: tokenId,
    toolName: name,
    initialPayload: waitingPayload,
    resumeHandler: { input in /* ... */ }
)

return .waiting(message: "...", continuation: token)
```

**Impact**: ~90 LOC across 6 files

**Solution**: Add factory method to ContinuationToken:
```swift
extension ContinuationToken {
    static func forWaiting(
        id: UUID,
        toolName: String,
        message: String,
        additionalPayload: JSON? = nil,
        resumeHandler: @escaping @Sendable (JSON) async -> ToolResult
    ) -> (ToolResult, ContinuationToken) {
        var payload = JSON()
        payload["status"].string = "waiting"
        payload["tool"].string = toolName
        payload["message"].string = message
        if let additional = additionalPayload {
            payload.merge(additional)
        }

        let token = ContinuationToken(
            id: id,
            toolName: toolName,
            initialPayload: payload,
            resumeHandler: resumeHandler
        )

        return (.waiting(message: message, continuation: token), token)
    }
}
```

---

### Pattern 4: Overly Verbose Payload Parsing Structs (3 files)
**Files**: GetUserOptionTool (OptionPromptPayload), GetUserUploadTool (UploadRequestPayload), SubmitForValidationTool (ValidationPayload)

**Problem**: Private structs that parse JSON parameters are 50-100 lines each, often doing simple transformations that could be inline.

**Impact**: ~80 LOC across 3 files

**Solution**: Either simplify inline or create a shared parsing utility. These structs add ceremony without clear benefit.

---

### Pattern 5: Inconsistent Error Handling
**Files**: All tools

**Problem**: Different tools handle errors differently:
- Some re-throw ToolErrors (SetObjectiveStatusTool)
- Some catch and wrap (ExtractDocumentTool)
- Some have custom error enums (GetMacOSContactCardTool)
- Some return `.error()` directly (PersistDataTool)

**Impact**: Inconsistency makes the codebase harder to reason about

**Solution**: Establish a single error handling convention. Since ToolExecutor already has errorResult normalization, tools should just throw ToolErrors or let errors propagate.

---

## Prioritized Recommendations

### Quick Wins (High Impact, Low Effort)

1. **Remove unused defaultPrompt function in GetUserUploadTool** (~22 LOC reduction)
   - Files: GetUserUploadTool.swift
   - Simply delete lines 201-222 after confirming it's never called

2. **Eliminate redundant error re-throwing in SetObjectiveStatusTool** (~8 LOC reduction)
   - Files: SetObjectiveStatusTool.swift
   - Remove the try/catch wrapper, let errors propagate

3. **Replace ContactError enum with direct ToolError usage** (~10 LOC reduction)
   - Files: GetMacOSContactCardTool.swift
   - Use ToolError.permissionDenied and ToolError.executionFailed directly

4. **Extract response building in NextPhaseTool to factory methods** (~10 LOC reduction)
   - Files: NextPhaseTool.swift
   - Create Response.blocked(), Response.approved() helpers

5. **Clarify or remove unused CardType.specific** (0 LOC, improves clarity)
   - Files: GetMacOSContactCardTool.swift
   - Either implement or remove from schema

**Total Quick Wins**: ~50 LOC reduction, 2-3 hours effort

---

### Medium-term Improvements (High Impact, Medium Effort)

1. **Create ToolResponseBuilder utility** (~180 LOC reduction)
   - Create new file: `Utilities/ToolResponseBuilder.swift`
   - Refactor 8 tools to use it
   - Estimated effort: 6-8 hours
   - This is the single biggest win

2. **Create JSONParameterValidator utility** (~120 LOC reduction)
   - Create new file: `Utilities/JSONParameterValidator.swift`
   - Refactor 9 tools to use it
   - Estimated effort: 5-7 hours

3. **Extract ContinuationToken factory method** (~90 LOC reduction)
   - Add extension to ToolProtocol.swift
   - Refactor 6 tools to use it
   - Estimated effort: 4-5 hours

4. **Simplify payload parsing structs** (~80 LOC reduction)
   - Refactor GetUserOptionTool, GetUserUploadTool, SubmitForValidationTool
   - Estimated effort: 4-6 hours

5. **Extract phase advance branching logic in NextPhaseTool** (~25 LOC reduction)
   - Create named methods for each branch
   - Estimated effort: 2-3 hours

**Total Medium-term**: ~495 LOC reduction, 21-29 hours effort

---

### Strategic Refactoring (High Impact, High Effort)

1. **Consolidate validation tools** (~129 LOC reduction)
   - **Problem**: ValidateApplicantProfileTool and SubmitForValidationTool have significant overlap
   - **Recommendation**: Merge into single tool or create clear specialization hierarchy
   - **Effort**: High (8-12 hours, requires design discussion)
   - **Impact**: Eliminates entire file, reduces confusion about which tool to use
   - **Risk**: Medium - affects tool registration and LLM prompting

2. **Move retry/fallback logic from SubmitForValidationTool to service layer** (~20 LOC reduction)
   - **Problem**: Business logic embedded in tool
   - **Recommendation**: Tools should be thin wrappers; move retry tracking to OnboardingInterviewService
   - **Effort**: High (4-6 hours)
   - **Impact**: Better separation of concerns, testability

3. **Refactor ExtractDocumentTool response building** (~25 LOC reduction)
   - **Problem**: 64 lines of manual JSON construction
   - **Recommendation**: Use Codable structs for ExtractionResult
   - **Effort**: Medium-High (3-5 hours, requires understanding DocumentExtractionService contract)

**Total Strategic**: ~174 LOC reduction, 15-23 hours effort

---

### Not Recommended (Low Impact or High Risk)

1. **Splitting GetUserUploadTool into smaller files**
   - While it's 273 LOC, the complexity is legitimate (upload handling is complex)
   - Splitting would create coordination overhead without clear benefit
   - Better to simplify payload parsing (already recommended)

2. **Inlining ToolExecutor.normalize method**
   - The abstraction is clean and may support future middleware
   - Only saves ~5 LOC with minimal readability gain

3. **Converting all tools to use Codable instead of JSON**
   - High effort, high risk, moderate benefit
   - SwiftyJSON provides flexibility needed for LLM-generated inputs
   - Would require ~40 hours of refactoring

---

## Total Impact Summary

### Quick Wins
- **LOC Reduction**: ~50
- **Effort**: 2-3 hours
- **Files affected**: 4

### Medium-term
- **LOC Reduction**: ~495
- **Effort**: 21-29 hours
- **Files affected**: 12

### Strategic
- **LOC Reduction**: ~174
- **Effort**: 15-23 hours
- **Files affected**: 3

### Total Potential
- **LOC Reduction**: ~719 (42% of total)
- **Effort**: 38-55 hours
- **Final LOC**: ~989 (from 1,708)

---

## Code Quality Observations

### Strengths
1. **Clean protocol design**: InterviewTool protocol is well-designed
2. **Consistent naming**: All tools follow clear naming conventions
3. **Good separation**: Infrastructure vs implementations is clear
4. **Actor isolation**: ToolExecutor properly uses actor for thread safety

### Weaknesses
1. **DRY violations**: Significant duplication across tools
2. **Mixed abstraction levels**: Some tools are thin wrappers, others contain business logic
3. **Inconsistent error handling**: Three different error handling patterns
4. **Over-engineering in places**: Some payload structs are unnecessarily complex

### Anti-Patterns Found
1. **Copy-paste coding**: Continuation token pattern copied 6 times
2. **Dead code**: Unused functions (defaultPrompt, potentially CardType.specific)
3. **Business logic in presentation layer**: Retry/fallback logic in tool
4. **Tool overlap**: Two tools doing same thing (validation tools)

---

## Recommendations for Future Tool Development

### Do's
1. Use the proposed ToolResponseBuilder utility
2. Use JSONParameterValidator for parameter parsing
3. Keep tools thin - delegate to service layer
4. Use ContinuationToken factory for consistency
5. Follow GetApplicantProfileTool as a good example

### Don'ts
1. Don't create custom error enums - use ToolError
2. Don't embed business logic in tools
3. Don't manually build JSON responses
4. Don't copy-paste continuation patterns
5. Don't create payload structs over 30 lines

### Testing Recommendations
1. Extract shared utilities first (highest risk)
2. Add tests for utilities before refactoring
3. Refactor tools one at a time
4. Keep existing tool tests passing
5. Consider snapshot tests for JSON responses

---

## Conclusion

The Tools directory is **functional but sprawling**. The core design (protocol + registry + executor) is excellent, but the implementations suffer from significant duplication. The codebase would benefit from:

1. **Immediate action**: Quick wins (5 fixes, 2-3 hours)
2. **Next sprint**: Create 3 utility files (ToolResponseBuilder, JSONParameterValidator, ContinuationToken extension)
3. **Design discussion needed**: Should ValidateApplicantProfileTool be merged into SubmitForValidationTool?

With focused refactoring, this directory can go from 1,708 LOC to ~989 LOC while significantly improving maintainability. The 42% reduction is achievable because the duplication is mechanical, not conceptual.

**Priority**: High. These tools are the LLM-facing API surface. Complexity here directly impacts the assistant's ability to use tools correctly.
