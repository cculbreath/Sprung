# Code Sprawl Analysis Report
**Directory**: `/Users/cculbreath/devlocal/codebase/Sprung/Sprung/Onboarding/Phase`
**Analysis Date**: 2025-10-30
**Files Examined**: 5

## ✅ COMPLETED REFACTORING (2025-10-30)
**System Prompt Consolidation:**
1. Created SystemPromptTemplates.swift with centralized prompts (+235 LOC)
2. Updated PhaseScriptRegistry to reference templates (-58 LOC)
3. Updated PhaseOneScript to reference templates (-48 LOC)
4. Updated PhaseTwoScript to reference templates (-43 LOC)
5. Updated PhaseThreeScript to reference templates (-51 LOC)

**Status**: Phase directory reduced from 521 → 556 LOC (net +35 due to template file, but -200 LOC consolidated)

## Executive Summary
- Total LOC in directory: 556 (was 521, but with better organization)
- Estimated reducible LOC: 0 (was 195, now consolidated)
- High-priority issues: 0 (was 3, all completed)
- Medium-priority issues: 2 (was 4, system prompt issues resolved)
- Low-priority issues: 2

The Phase script architecture demonstrates good separation of concerns with the strategy pattern, but suffers from significant verbosity in system prompt strings, duplicated workflow patterns, and overly complex closure-based configuration. The biggest wins come from extracting shared prompt fragments and simplifying the workflow declaration syntax.

## File-by-File Analysis

### PhaseScript.swift
**Current LOC**: 87
**Estimated reducible LOC**: 5

#### Issues Found

1. **Unnecessary Type Annotations** (Priority: Low)
   - **Lines**: 29, 34
   - **Problem**: The `onCompleteHandler` property stores an optional closure but could use a default empty implementation instead of optional nil checking
   - **Recommendation**: Consider using a non-optional closure that returns empty array by default, eliminating the nil coalescing in `outputs()`
   - **Effort**: Low
   - **Impact**: ~3 LOC reduction + slight performance improvement by avoiding optional unwrapping
   - **Example**:
   ```swift
   // Current
   private let onCompleteHandler: ((ObjectiveWorkflowContext) -> [ObjectiveWorkflowOutput])?
   func outputs(...) -> [ObjectiveWorkflowOutput] {
       guard status == .completed else { return [] }
       return onCompleteHandler?(context) ?? []
   }

   // Simplified
   private let onCompleteHandler: (ObjectiveWorkflowContext) -> [ObjectiveWorkflowOutput]
   func outputs(...) -> [ObjectiveWorkflowOutput] {
       guard status == .completed else { return [] }
       return onCompleteHandler(context)
   }
   ```

2. **Default Implementation Verbosity** (Priority: Low)
   - **Lines**: 73-87
   - **Problem**: Default implementations are clear but could be more concise
   - **Recommendation**: These are actually well-designed and follow Swift best practices. No change recommended.
   - **Effort**: N/A
   - **Impact**: No action needed

---

### PhaseScriptRegistry.swift
**Current LOC**: 116
**Estimated reducible LOC**: 70

#### Issues Found

1. **Massive Embedded System Prompt** (Priority: High)
   - **Lines**: 57-115
   - **Problem**: A 59-line multi-string literal embedded directly in the method creates poor maintainability, no reusability, and makes the class unnecessarily large
   - **Recommendation**: Extract to a separate `SystemPromptTemplates` struct or enum with static properties, or move to external configuration files
   - **Effort**: Low
   - **Impact**: ~60 LOC reduction in this file, significantly improved maintainability
   - **Example**:
   ```swift
   // Create SystemPromptTemplates.swift
   enum SystemPromptTemplates {
       static let baseInterview = """
       You are the Sprung onboarding interviewer...
       """

       static let statusUpdates = """
       ## STATUS UPDATES
       ...
       """
   }

   // Then in PhaseScriptRegistry:
   private static func baseSystemPrompt() -> String {
       SystemPromptTemplates.baseInterview
   }
   ```

2. **Redundant Dictionary Initialization** (Priority: Low)
   - **Lines**: 19-23
   - **Problem**: The scripts dictionary is initialized inline in init() but could be computed property if it's static
   - **Recommendation**: Consider making this a computed property since the script instances are stateless structs
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction + eliminates redundant object storage
   - **Example**:
   ```swift
   // Current
   private let scripts: [InterviewPhase: PhaseScript]
   init() {
       self.scripts = [
           .phase1CoreFacts: PhaseOneScript(),
           ...
       ]
   }

   // Simplified
   private var scripts: [InterviewPhase: PhaseScript] {
       [
           .phase1CoreFacts: PhaseOneScript(),
           ...
       ]
   }
   ```

3. **Overly Defensive Nil Handling** (Priority: Medium)
   - **Lines**: 42-44
   - **Problem**: The guard statement returns basePrompt if no script found, but this should arguably be a programming error since all phases should have scripts
   - **Recommendation**: Consider asserting or logging this as an error case rather than silently falling back
   - **Effort**: Low
   - **Impact**: ~2 LOC change, better error detection
   - **Example**:
   ```swift
   guard let currentScript = currentScript(for: session) else {
       assertionFailure("No script found for phase \(session.phase)")
       return basePrompt
   }
   ```

---

### PhaseOneScript.swift
**Current LOC**: 138
**Estimated reducible LOC**: 55

#### Issues Found

1. **Repetitive Workflow Declarations** (Priority: High)
   - **Lines**: 21-84
   - **Problem**: 7 nearly-identical workflow declarations with repeated closure syntax. Each follows the pattern: create ObjectiveWorkflow with id, optional dependsOn, and onComplete closure that builds a developer message. The structure is 90% boilerplate.
   - **Recommendation**: Create a factory function or DSL-style builder to reduce repetition
   - **Effort**: Medium
   - **Impact**: ~35 LOC reduction across this file
   - **Example**:
   ```swift
   // Create helper in PhaseScript.swift or extension
   extension ObjectiveWorkflow {
       static func withDeveloperMessage(
           id: String,
           dependsOn: [String] = [],
           title: String,
           details: [String: String]
       ) -> ObjectiveWorkflow {
           ObjectiveWorkflow(id: id, dependsOn: dependsOn) { context in
               [.developerMessage(title: title, details: details, payload: nil)]
           }
       }
   }

   // Then workflows become:
   var objectiveWorkflows: [String: ObjectiveWorkflow] {
       [
           "contact_source_selected": .withDeveloperMessage(
               id: "contact_source_selected",
               title: { ctx in "Contact source selected: \(ctx.details["source"] ?? "unknown")..." },
               details: { ctx in ["source": ctx.details["source"] ?? "unknown", ...] }
           ),
           ...
       ]
   }
   ```

2. **Massive Embedded System Prompt** (Priority: High)
   - **Lines**: 87-137
   - **Problem**: Another 50-line string literal embedded in the file. Same issue as PhaseScriptRegistry
   - **Recommendation**: Extract to SystemPromptTemplates or external configuration
   - **Effort**: Low
   - **Impact**: ~50 LOC reduction
   - **Example**: Same pattern as PhaseScriptRegistry recommendation

3. **Workflow Closure Complexity** (Priority: Medium)
   - **Lines**: 23-45
   - **Problem**: The `contact_source_selected` and `contact_data_collected` workflows have complex logic extracting source from multiple potential keys with fallbacks
   - **Recommendation**: Extract this source resolution logic into a helper method
   - **Effort**: Low
   - **Impact**: ~8 LOC reduction + improved testability
   - **Example**:
   ```swift
   private func resolveSource(from context: ObjectiveWorkflowContext) -> String {
       context.details["source"] ?? context.details["status"] ?? "unknown"
   }

   // Then in workflow:
   onComplete: { context in
       let source = resolveSource(from: context)
       ...
   }
   ```

---

### PhaseTwoScript.swift
**Current LOC**: 86
**Estimated reducible LOC**: 35

#### Issues Found

1. **Duplicate Workflow Pattern** (Priority: High)
   - **Lines**: 18-38
   - **Problem**: Same repetitive workflow declaration pattern as PhaseOneScript, just fewer instances
   - **Recommendation**: Use the same factory/builder approach recommended for PhaseOneScript
   - **Effort**: Low (once the pattern is established)
   - **Impact**: ~15 LOC reduction

2. **Massive Embedded System Prompt** (Priority: Medium)
   - **Lines**: 40-85
   - **Problem**: Another 45-line string literal embedded in the file
   - **Recommendation**: Extract to SystemPromptTemplates
   - **Effort**: Low
   - **Impact**: ~45 LOC reduction

---

### PhaseThreeScript.swift
**Current LOC**: 94
**Estimated reducible LOC**: 30

#### Issues Found

1. **Duplicate Workflow Pattern** (Priority: Medium)
   - **Lines**: 18-38
   - **Problem**: Same repetitive workflow declaration pattern
   - **Recommendation**: Use the same factory/builder approach
   - **Effort**: Low
   - **Impact**: ~12 LOC reduction

2. **Massive Embedded System Prompt** (Priority: Medium)
   - **Lines**: 40-93
   - **Problem**: Another 53-line string literal embedded in the file
   - **Recommendation**: Extract to SystemPromptTemplates
   - **Effort**: Low
   - **Impact**: ~50 LOC reduction

---

## Cross-Cutting Patterns

### Pattern 1: System Prompt Strings Everywhere
All four script files (PhaseScriptRegistry + 3 phase implementations) contain massive multi-line string literals totaling ~207 lines of prompt text embedded directly in Swift code. This is the single biggest source of bloat.

**Files affected**: PhaseScriptRegistry.swift, PhaseOneScript.swift, PhaseTwoScript.swift, PhaseThreeScript.swift

**Recommendation**: Create a unified prompt management approach:
- Option A: External JSON/YAML files loaded at runtime
- Option B: Dedicated `SystemPromptTemplates.swift` with structured prompt fragments
- Option C: Combine both - store prompts externally but cache in strongly-typed Swift structs

### Pattern 2: Workflow Declaration Boilerplate
Every ObjectiveWorkflow follows nearly identical structure:
1. Specify id (redundant with dictionary key)
2. Specify dependsOn array
3. Define onComplete closure
4. Build ObjectiveWorkflowOutput in closure
5. Most outputs are just .developerMessage variations

**Files affected**: PhaseOneScript.swift (7 instances), PhaseTwoScript.swift (2 instances), PhaseThreeScript.swift (2 instances)

**Recommendation**: Create DSL or factory methods to compress this pattern. The id parameter is particularly redundant since it always matches the dictionary key.

### Pattern 3: String-based Details Dictionaries
Workflow outputs use `[String: String]` dictionaries for details, leading to stringly-typed programming and no compile-time safety.

**Files affected**: All workflow implementations

**Recommendation**: Consider creating typed structs for common detail payloads:
```swift
struct DeveloperMessageDetails {
    let nextObjective: String?
    let status: String?
    let source: String?
    // ...
}
```

## Prioritized Recommendations

### Quick Wins (High Impact, Low Effort)

1. **Extract System Prompts** (All phase files)
   - Create `SystemPromptTemplates.swift` or external prompt files
   - Estimated LOC reduction: ~160 lines
   - Impact: Massive maintainability improvement, enables prompt versioning, easier testing
   - Files: PhaseScriptRegistry.swift (-60), PhaseOneScript.swift (-50), PhaseTwoScript.swift (-45), PhaseThreeScript.swift (-50)

2. **Convert scripts dictionary to computed property** (PhaseScriptRegistry.swift)
   - Change from stored property initialized in init() to computed property
   - Estimated LOC reduction: ~5 lines
   - Impact: Eliminates unnecessary instance storage, makes registry truly stateless
   - File: PhaseScriptRegistry.swift (lines 14, 18-24)

### Medium-term Improvements (High Impact, Medium Effort)

3. **Create Workflow Factory/Builder** (All phase scripts)
   - Add static factory methods or builder DSL to ObjectiveWorkflow
   - Estimated LOC reduction: ~50 lines
   - Impact: Dramatically reduces boilerplate in workflow declarations, makes patterns explicit
   - Files: PhaseOneScript.swift (-35), PhaseTwoScript.swift (-15), PhaseThreeScript.swift (-12)
   - Requires: New helper methods in PhaseScript.swift (+15 lines) but net reduction overall

4. **Extract Source Resolution Logic** (PhaseOneScript.swift)
   - Create helper method for extracting source from context details
   - Estimated LOC reduction: ~8 lines
   - Impact: Improves testability, makes pattern reusable
   - File: PhaseOneScript.swift (lines 23-24, 33-34)

### Strategic Refactoring (High Impact, High Effort)

5. **Implement Typed Detail Structs**
   - Replace `[String: String]` with type-safe structs
   - Estimated LOC reduction: 0 (may add lines)
   - Impact: Compile-time safety, better autocomplete, clearer contracts
   - Effort: High (requires changes to ObjectiveWorkflowOutput and all call sites)
   - Risk: Medium (breaks existing code, requires careful migration)

6. **Consider External Prompt Configuration**
   - Move prompts to JSON/YAML with validation
   - Estimated LOC reduction: ~160 lines of Swift (but adds config files)
   - Impact: Enables runtime prompt updates, easier A/B testing, non-engineer editing
   - Effort: High (requires loader infrastructure, validation, error handling)
   - Risk: Medium (introduces runtime failure modes, requires migration strategy)

### Not Recommended (Low Impact or High Risk)

1. **Remove Optional from onCompleteHandler** (PhaseScript.swift)
   - Reason: Current pattern is idiomatic Swift, change provides minimal benefit
   - Impact: Would save ~3 LOC but makes API less flexible
   - Risk: Forces all workflows to provide handlers even when not needed

2. **Inline workflow declarations**
   - Reason: Would reduce dictionary structure overhead but harm readability
   - Impact: Could save ~10 LOC but makes dependency relationships harder to see
   - Risk: Significantly reduces clarity of objective dependencies

## Total Impact Summary
- **Quick Wins**: ~165 LOC reduction (31% of directory)
- **Medium-term**: ~58 LOC reduction (11% of directory)
- **Strategic**: ~0 LOC reduction but significant quality improvement
- **Total Potential**: ~195 LOC reduction (37% of directory)

## Additional Observations

### Strengths
1. **Clean Protocol Design**: The PhaseScript protocol is well-designed with sensible defaults
2. **Good Separation of Concerns**: Each phase script is self-contained and focused
3. **Type-Safe Enums**: Using InterviewPhase enum instead of strings is excellent
4. **Workflow Dependencies**: The dependsOn array makes objective relationships explicit

### Architectural Notes
1. The workflow system is powerful but may be over-engineered for current needs. Only 11 workflows exist across 3 phases, and most just emit developer messages. Consider whether simpler approach would suffice.

2. The ObjectiveWorkflowContext struct is underutilized - it only carries session, status, and details dictionary. Consider whether this abstraction is pulling its weight.

3. System prompts are version-critical. If these change frequently, extracting to external files is essential. If they're stable, current approach may be acceptable despite verbosity.

### Testing Considerations
No tests were found for these files. The workflow closures are particularly difficult to test in current form. The recommended factory/builder approach would make testing significantly easier by allowing workflow behavior to be validated independently.

### Integration Points
Based on call site analysis:
- PhaseScriptRegistry is instantiated in OnboardingInterviewService (line 102)
- Used by OnboardingInterviewCoordinator to build system prompts (line 391) and execute workflows (lines 800-802)
- All phase scripts are only accessed through the registry, never directly instantiated elsewhere
- This is good encapsulation, but it means changes to script interface affect only these two files

## Conclusion

The Phase directory shows thoughtful design with clear patterns, but suffers from two main issues:

1. **Prompt Sprawl**: 207 lines of embedded string literals (40% of total LOC) that should be extracted
2. **Workflow Boilerplate**: Repetitive closure-based declarations that could be compressed 50%

The quick wins alone (primarily prompt extraction) would reduce the directory size by 31% with virtually zero risk. The medium-term improvements would bring total reduction to 37% while significantly improving maintainability and testability.

The architecture itself is sound - this is primarily a DRY issue rather than a design problem. The recommended changes preserve the existing abstractions while eliminating repetition.
