# Code Sprawl Analysis Report
**Directory**: ./Sprung/Onboarding/Services/
**Analysis Date**: 2025-10-30
**Files Examined**: 4

## ✅ COMPLETED REFACTORING (2025-10-30)
**String Trimming Pattern Elimination:**
1. Created StringExtensions.swift with `trimmedNonEmpty` and `isTrimmedEmpty` helpers
2. Updated ContactsImportService to use new extension (-25 LOC of duplication)
3. Updated KnowledgeCardAgent to use new extension (-4 LOC of duplication)

**Status**: Services directory reduced from 687 → 658 LOC

## Executive Summary
- Total LOC in directory: 658 (was 687, reduced by 29)
- Estimated reducible LOC: 96 (14.6%, was 125)
- High-priority issues: 2 (was 4, completed 2)
- Medium-priority issues: 7
- Low-priority issues: 3

**Key Findings**: The Services directory shows good architectural separation with focused responsibilities. However, there are opportunities to reduce verbosity through extraction of repeated patterns, eliminate unnecessary nested structures, and consolidate duplicated type definitions that exist across service boundaries.

---

## File-by-File Analysis

### ContactsImportService.swift
**Current LOC**: 153
**Estimated reducible LOC**: 35

#### Issues Found

1. **Verbose Trimming and Empty Checking Pattern** (Priority: High)
   - **Lines**: 66-71, 74-76, 78-81, 84-97, 106-129
   - **Problem**: Repeated pattern of `trimmingCharacters(in: .whitespacesAndNewlines)` followed by isEmpty checks appears 10+ times throughout the file. This pattern is scattered across address parsing, email collection, and name building.
   - **Recommendation**: Extract a helper method or property extension:
     ```swift
     extension String {
         var trimmedNonEmpty: String? {
             let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)
             return trimmed.isEmpty ? nil : trimmed
         }
     }
     ```
     Then use: `if let city = postalAddress.city.trimmedNonEmpty { draft.city = city }`
   - **Effort**: Low
   - **Impact**: ~20 LOC reduction + improved readability across the file

2. **Overly Elaborate Email Deduplication** (Priority: Medium)
   - **Lines**: 88-96
   - **Problem**: Manual array deduplication using `reduce(into:)` when standard library provides this capability. The pattern is verbose for a simple deduplication task.
   - **Recommendation**: Use array filtering or convert to Set:
     ```swift
     let uniqueEmails = Array(Set(emailValues))
     draft.suggestedEmails = uniqueEmails
     ```
   - **Effort**: Low
   - **Impact**: 7 LOC reduction + clearer intent

3. **Postal Address Parsing Sprawl** (Priority: Medium)
   - **Lines**: 105-130
   - **Problem**: 25 lines of repetitive field extraction with identical pattern for street, city, state, postalCode, countryCode. Each follows: extract → trim → check empty → assign to draft.
   - **Recommendation**: Extract a helper that takes keypaths:
     ```swift
     func assignIfPresent<T>(_ value: String, to keyPath: WritableKeyPath<ApplicantProfileDraft, T>) where T: ExpressibleByStringLiteral {
         if let trimmed = value.trimmedNonEmpty {
             draft[keyPath: keyPath] = trimmed as! T
         }
     }
     ```
     Or use a dictionary-driven approach for address fields.
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction

4. **Continuation Wrapper Verbosity** (Priority: Low)
   - **Lines**: 48-60
   - **Problem**: The `requestContactsAccess()` method wraps the callback-based API in a continuation, which is necessary but verbose. The error handling branches could be simplified.
   - **Recommendation**: Consider combining error branches:
     ```swift
     if let error {
         throw ContactFetchError.system(error.localizedDescription)
     }
     guard granted else {
         throw ContactFetchError.permissionDenied
     }
     ```
   - **Effort**: Low
   - **Impact**: 2-3 LOC reduction (minimal)

---

### DocumentExtractionService.swift
**Current LOC**: 293
**Estimated reducible LOC**: 45

#### Issues Found

1. **Nested Type Sprawl** (Priority: High)
   - **Lines**: 12-47
   - **Problem**: Four nested types defined within the actor (`ExtractionRequest`, `ArtifactRecord`, `Quality`, `ExtractionResult`) totaling ~60 lines. These are used outside the service by `ExtractDocumentTool` and other consumers, suggesting they should not be actor-nested.
   - **Recommendation**: Extract these types to a separate file `DocumentExtractionTypes.swift` or into the existing `OnboardingArtifactRecord.swift` model file. This would improve discoverability and allow non-actor access without async context.
   - **Effort**: Low
   - **Impact**: ~0 LOC reduction but significant maintainability improvement. Eliminates actor boundary confusion.

2. **Duplicated ArtifactRecord Definition** (Priority: High)
   - **Lines**: 20-27 (DocumentExtractionService) vs. KnowledgeCardDraft.swift lines 132-184
   - **Problem**: `ArtifactRecord` is defined identically in two places: as a nested struct in `DocumentExtractionService` and as a standalone struct in `KnowledgeCardDraft.swift`. This creates a maintenance burden and potential divergence.
   - **Recommendation**: Consolidate to a single definition. Move to `OnboardingArtifactRecord.swift` or create a new `ArtifactRecord.swift` file. Update all references.
   - **Effort**: Medium
   - **Impact**: Eliminates ~30 duplicate LOC + prevents future divergence

3. **Verbose Text Extraction Switch** (Priority: Medium)
   - **Lines**: 172-218
   - **Problem**: The `extractPlainText` method uses verbose if-else branching with repeated issue array management and empty text checking. Each branch follows nearly identical pattern.
   - **Recommendation**: Extract extraction strategies:
     ```swift
     private let extractors: [String: (URL) -> (String?, [String])] = [
         "pdf": extractPDF,
         "docx": extractDOCX
     ]
     ```
     Then dispatch based on extension.
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction + easier to add new formats

4. **Hardcoded Prompt Construction** (Priority: Low)
   - **Lines**: 234-250
   - **Problem**: Multi-line string literal for LLM prompt is hardcoded in the method body. This makes it difficult to test, iterate on, or reuse across similar extraction tasks.
   - **Recommendation**: Extract to a computed property or separate prompt builder type. Consider a template system if multiple extraction purposes need different prompts.
   - **Effort**: Low
   - **Impact**: ~0 LOC reduction but improved testability and maintainability

5. **Redundant Status Determination Logic** (Priority: Medium)
   - **Lines**: 125-132
   - **Problem**: Status determination uses verbose nested if-else with duplicate `issues.contains` checks. Could be flattened.
   - **Recommendation**: Use a single expression or guard chain:
     ```swift
     let status: ExtractionResult.Status = {
         let hasCriticalIssue = issues.contains {
             $0.hasPrefix("llm_failure") || $0 == "text_extraction_warning"
         }
         return hasCriticalIssue ? .partial : .ok
     }()
     ```
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

6. **Confidence Estimation Algorithm Opacity** (Priority: Low)
   - **Lines**: 278-287
   - **Problem**: The confidence calculation uses magic numbers (0.95, 10_000.0, 0.4) without explanation. The algorithm is opaque.
   - **Recommendation**: Extract constants with descriptive names and document the formula:
     ```swift
     private let baseConfidence = 0.4
     private let maxConfidence = 0.95
     private let characterCountScalingFactor = 10_000.0
     ```
     Add a comment explaining the confidence model.
   - **Effort**: Low
   - **Impact**: 0 LOC reduction but improved clarity

---

### KnowledgeCardAgent.swift
**Current LOC**: 169
**Estimated reducible LOC**: 25

#### Issues Found

1. **Verbose Citation Validation Loop** (Priority: Medium)
   - **Lines**: 135-165
   - **Problem**: The validation loop performs multiple sequential checks with repeated trimming and guard statements. The candidate artifacts filtering and search logic could be more concise.
   - **Recommendation**: Extract validation logic to a separate method per concern:
     ```swift
     private func validateAchievement(_ achievement: Achievement, artifacts: [ArtifactRecord]) throws {
         try validateClaimNotEmpty(achievement.claim)
         try validateEvidenceNotEmpty(achievement.evidence)
         try validateCitationExists(achievement, in: artifacts)
     }
     ```
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction through extraction

2. **Duplicate Trimming Pattern** (Priority: High)
   - **Lines**: 141, 146
   - **Problem**: Same trimming + isEmpty pattern as ContactsImportService. Would benefit from the same utility extension.
   - **Recommendation**: Use shared trimming extension (see ContactsImportService issue #1).
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

3. **Artifact Truncation Duplication** (Priority: Medium)
   - **Lines**: 100-102 (artifacts), 113 (transcript)
   - **Problem**: Truncation logic is called twice with different limits. The `truncate` helper method (lines 129-133) is only used internally but could be useful elsewhere.
   - **Recommendation**: Consider making truncation a String extension or moving to a shared utilities file if other services need similar functionality.
   - **Effort**: Low
   - **Impact**: 0 LOC reduction in this file, but potential reuse elsewhere

4. **JSON String Conversion Verbosity** (Priority: Low)
   - **Lines**: 98
   - **Problem**: Uses `rawString(.utf8, options: [.prettyPrinted]) ?? description` as fallback. This is a common pattern that could be extracted.
   - **Recommendation**: Add a JSON extension:
     ```swift
     extension JSON {
         var prettyString: String {
             rawString(.utf8, options: [.prettyPrinted]) ?? description
         }
     }
     ```
   - **Effort**: Low
   - **Impact**: ~1 LOC reduction but improved clarity

5. **System Instruction as Computed Property** (Priority: Low)
   - **Lines**: 82-95
   - **Problem**: Multi-line string as computed property is executed every time it's accessed (though likely optimized by compiler). The string is static and never changes.
   - **Recommendation**: Convert to a private static constant:
     ```swift
     private static let systemInstruction = """..."""
     ```
   - **Effort**: Low
   - **Impact**: 0 LOC reduction but prevents unnecessary computation

---

### UploadFileService.swift
**Current LOC**: 72
**Estimated reducible LOC**: 20

#### Issues Found

1. **Premature macOS Version Check** (Priority: High)
   - **Lines**: 48-53
   - **Problem**: The code checks for `macOS 12.0` availability when determining UTType support. If the project's minimum deployment target is macOS 12+, this check is redundant. If not, it still represents future-proofing code that may no longer be necessary.
   - **Recommendation**: Check project deployment target. If macOS 12+, remove the availability check entirely. Otherwise, consider if this fallback is still needed or document why.
   - **Effort**: Low
   - **Impact**: ~7 LOC reduction if deployment target is macOS 12+

2. **Overly Defensive NSImage Validation** (Priority: Medium)
   - **Lines**: 56-58
   - **Problem**: The fallback to NSImage validation after UTType check might be redundant. UTType.conforms(to: .image) should be sufficient for most cases. The NSImage(data:) check adds overhead.
   - **Recommendation**: Evaluate whether the NSImage fallback has ever caught a validation issue that UTType missed. If not, remove it. If needed, document why with a comment.
   - **Effort**: Low
   - **Impact**: ~3 LOC reduction + faster validation

3. **Unused File Extension Parameter** (Priority: Medium)
   - **Lines**: 42, 49
   - **Problem**: The `fileExtension` parameter is only used in the UTType check path. If that path succeeds, the parameter value doesn't matter for NSImage validation. This suggests the API design could be simplified.
   - **Recommendation**: Consider whether file extension is truly needed or if Data alone is sufficient for validation. Alternatively, use the extension more consistently.
   - **Effort**: Low
   - **Impact**: Potential API simplification

4. **Generic Error Message for Download Failure** (Priority: Low)
   - **Lines**: 22-23
   - **Problem**: HTTP errors are reported as "Failed to download file from URL (HTTP error)" without including the actual status code. This makes debugging difficult.
   - **Recommendation**: Include status code in error message:
     ```swift
     throw ToolError.executionFailed("Failed to download file from URL (HTTP \(httpResponse.statusCode))")
     ```
   - **Effort**: Low
   - **Impact**: 0 LOC reduction but better error diagnostics

5. **Temporary File Naming Could Use Security Best Practices** (Priority: Low)
   - **Lines**: 29-31
   - **Problem**: The temporary filename uses `UUID().uuidString` prefix but preserves the original filename, which could contain special characters or path separators that cause issues.
   - **Recommendation**: Sanitize the filename before using it:
     ```swift
     let safeName = filename.replacingOccurrences(of: "/", with: "-")
     ```
   - **Effort**: Low
   - **Impact**: 0 LOC reduction but improves robustness

---

## Cross-Cutting Patterns

### 1. Duplicated Trimming Pattern
**Files**: ContactsImportService.swift, KnowledgeCardAgent.swift
**Occurrences**: 12+

The pattern of `.trimmingCharacters(in: .whitespacesAndNewlines)` followed by `.isEmpty` checks appears throughout multiple services. This is a prime candidate for extraction into a shared String extension.

**Recommendation**: Create a shared `StringExtensions.swift` file in a utilities directory with:
```swift
extension String {
    var trimmedNonEmpty: String? {
        let trimmed = trimmingCharacters(in: .whitespacesAndNewlines)
        return trimmed.isEmpty ? nil : trimmed
    }

    var isTrimmedEmpty: Bool {
        trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
}
```

**Impact**: ~25 LOC reduction across multiple files + improved consistency

### 2. Duplicated ArtifactRecord Type
**Files**: DocumentExtractionService.swift (nested type), KnowledgeCardDraft.swift (standalone)

Both files define an `ArtifactRecord` struct with nearly identical fields: filename, contentType, sizeInBytes, sha256, extractedContent, metadata. This represents a significant duplication and maintenance risk.

**Recommendation**: Consolidate to a single canonical definition, likely in its own file or alongside other shared models. Update all imports and references.

**Impact**: ~30 duplicate LOC eliminated + prevents divergence

### 3. Error Type Proliferation
**Files**: All services define their own error enums

While each service has domain-specific errors, there's no shared error handling infrastructure. Three services define error enums with similar patterns:
- `ContactFetchError` (ContactsImportService)
- `ExtractionError` (DocumentExtractionService)
- `KnowledgeCardAgentError` (KnowledgeCardAgent)

**Observation**: This is actually **good practice** - domain-specific errors are appropriate here. No action recommended.

### 4. JSON Construction Verbosity
**Files**: ExtractDocumentTool.swift, GenerateKnowledgeCardTool.swift, ProfileInteractionHandler.swift

Multiple files manually construct JSON objects field-by-field using SwiftyJSON. While this is functional, it's verbose and error-prone. Consider whether Codable could be used instead for structured types.

**Recommendation**: Evaluate whether tool response types could use Codable structs that are then converted to JSON, rather than building JSON manually. This would provide compile-time safety and reduce verbosity.

**Impact**: Potentially significant LOC reduction in tool implementations, but requires careful evaluation of SwiftyJSON's role in the architecture.

---

## Prioritized Recommendations

### Quick Wins (High Impact, Low Effort)

1. **Extract Shared String Trimming Extension** (~25 LOC reduction)
   - Create `StringExtensions.swift` with `trimmedNonEmpty` property
   - Refactor ContactsImportService lines 66-129 and KnowledgeCardAgent lines 141, 146
   - Impact: Eliminates 12+ instances of repeated trimming pattern

2. **Remove Redundant macOS Version Check in UploadFileService** (~7 LOC reduction)
   - Lines 48-53: If deployment target is macOS 12+, remove `#available` check
   - Verify deployment target first: Check project settings or Xcode minimum version
   - Impact: Eliminates dead code if deployment target supports it

3. **Simplify Email Deduplication in ContactsImportService** (~7 LOC reduction)
   - Lines 88-96: Replace manual reduce with `Array(Set(emailValues))`
   - Impact: Clearer intent, fewer lines

4. **Flatten Status Determination in DocumentExtractionService** (~5 LOC reduction)
   - Lines 125-132: Consolidate status checks into single expression
   - Impact: Improved readability

**Total Quick Wins Impact**: ~44 LOC reduction

### Medium-term Improvements (High Impact, Medium Effort)

1. **Consolidate ArtifactRecord Type Definitions** (~30 LOC reduction)
   - Create canonical `ArtifactRecord` definition
   - Remove duplicate from DocumentExtractionService nested types
   - Update all references across: DocumentExtractionService, KnowledgeCardAgent, GenerateKnowledgeCardTool, ExtractDocumentTool
   - Estimated effort: 2-3 hours including testing
   - Impact: Eliminates type duplication, prevents future divergence

2. **Extract Address Parsing Helper in ContactsImportService** (~15 LOC reduction)
   - Lines 105-130: Create reusable field extraction pattern
   - Consider dictionary-driven or keypath-based approach
   - Impact: Reduces postal address parsing from 25 lines to ~10

3. **Refactor Citation Validation in KnowledgeCardAgent** (~15 LOC reduction)
   - Lines 135-165: Extract validation concerns into focused methods
   - Create `validateAchievement`, `validateClaimNotEmpty`, `validateEvidenceNotEmpty`, `validateCitationExists`
   - Impact: Better separation of concerns, easier testing

4. **Extract Text Extraction Strategy Pattern in DocumentExtractionService** (~15 LOC reduction)
   - Lines 172-218: Move to strategy-based dispatch
   - Makes adding new file formats easier
   - Impact: Reduces switch sprawl, improves extensibility

**Total Medium-term Impact**: ~75 LOC reduction

### Strategic Refactoring (High Impact, High Effort)

1. **Move Nested Types Out of DocumentExtractionService Actor** (0 LOC reduction, major maintainability improvement)
   - Lines 12-47: Extract all nested types to separate file
   - Currently, consumers must deal with actor isolation when accessing these types
   - Estimated effort: 3-4 hours including all callsite updates
   - Impact: Eliminates actor boundary confusion, improves discoverability
   - **Risk**: Medium - requires careful testing of actor isolation boundaries

2. **Evaluate Codable vs. Manual JSON Construction** (Potentially 50+ LOC reduction)
   - Multiple files build JSON manually (ExtractDocumentTool, GenerateKnowledgeCardTool, handlers)
   - Consider creating Codable response types that convert to JSON
   - Estimated effort: 5-7 hours across multiple files
   - Impact: Type safety, reduced verbosity, compile-time checking
   - **Risk**: Medium - may require changes to how SwiftyJSON is used throughout the system

**Total Strategic Impact**: ~50+ LOC reduction + significant architectural improvement

### Not Recommended (Low Impact or High Risk)

1. **Extracting LLM Prompt Templates to Configuration Files**
   - While prompts are hardcoded (DocumentExtractionService, KnowledgeCardAgent), moving them to external files adds complexity without clear benefit unless prompt management becomes a requirement
   - Current approach keeps prompts close to their usage
   - Only consider if you need non-developer editing of prompts

2. **Converting All Services to Actors**
   - ContactsImportService, KnowledgeCardAgent, and UploadFileService are not actors
   - Only DocumentExtractionService is an actor (likely due to LLM executor requirements)
   - Don't convert to actors without clear concurrency requirements
   - Current mix is appropriate based on usage patterns

3. **Aggressive Inlining of Small Methods**
   - Methods like `truncate()`, `sha256Hex()`, and `cleanupTemporaryFile()` are small but appropriately extracted
   - Inlining would reduce LOC but harm readability and testability
   - Keep these as-is

---

## Total Impact Summary

**Quick Wins**: ~44 LOC reduction (2-3 hours effort)
**Medium-term**: ~75 LOC reduction (8-12 hours effort)
**Strategic**: ~50+ LOC reduction + major maintainability gains (8-11 hours effort)

**Total Potential**: ~169 LOC reduction out of 687 total (24.6% reduction)

**Realistic Target**: Completing Quick Wins + Medium-term improvements would yield ~119 LOC reduction (17.3%) with manageable effort and low risk. Strategic refactoring should be evaluated based on team bandwidth and architectural goals.

---

## Notes on Methodology

**Strengths Observed**:
- Clear separation of concerns across services
- Appropriate error handling with domain-specific error types
- Good use of async/await throughout
- Thoughtful actor isolation (DocumentExtractionService)
- Services are focused and single-purpose

**Architectural Observations**:
- The ArtifactRecord duplication suggests these types should live in a shared Models directory rather than being defined within services
- The heavy use of manual JSON construction with SwiftyJSON may warrant evaluation - consider whether Codable provides better type safety
- Good boundary separation between services and their consumers (Tools, Handlers)

**Testing Considerations**:
- Before implementing recommendations, verify test coverage for these services
- Several recommendations (like extracting validation methods) will improve testability
- The ArtifactRecord consolidation should be accompanied by comprehensive tests

**Deployment Target Check Required**:
- Before removing the macOS 12.0 availability check in UploadFileService, verify the project's deployment target
- If macOS 12+ is guaranteed, this is dead code
- If supporting macOS 11, document why the fallback is needed
