# Code Sprawl Analysis Report
**Directory**: /Users/cculbreath/devlocal/codebase/Sprung/Sprung/Onboarding/Core/
**Analysis Date**: 2025-10-30
**Files Examined**: 9

## ✅ COMPLETED REFACTORING (2025-10-30)
**Deleted 144 LOC of deprecated code:**
- Issue #3: Deleted deprecated `runPhaseOne()` method (37 lines)
- Issue #4: Deleted dead `collectApplicantProfile()` and `collectSkeletonTimeline()` methods (102 lines)
- Additional: Deleted `buildApplicantProfileDraft()` and `generateTimeline()` helpers (5 lines)
**Status**: InterviewOrchestrator.swift reduced from 982 → 838 LOC

## Executive Summary
- Total LOC in directory: 3,847 (was 3,991, reduced by 144)
- Estimated reducible LOC: 806-956 (21-25%, was 950-1,100)
- High-priority issues: 6 (was 8, completed 2)
- Medium-priority issues: 12
- Low-priority issues: 7

**Key Findings**: The Core directory shows significant architectural sprawl with three overlapping orchestration layers (Orchestrator → Coordinator → Service), extensive method duplication between async/sync variants, verbose callback structures, and scattered state management. The most impactful improvements would consolidate the three-tier architecture into two tiers and eliminate duplicate storage methods.

---

## File-by-File Analysis

### InterviewOrchestrator.swift
**Current LOC**: 982
**Estimated reducible LOC**: 250-300

#### Issues Found

1. **Massive Callbacks struct** (Priority: High)
   - **Lines**: 22-40
   - **Problem**: 14 separate callback closures defined inline with verbose `@Sendable` annotations. This struct is 19 lines of boilerplate.
   - **Recommendation**: Use protocol-based delegation or a single callback handler interface with methods instead of individual closures.
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction + improved testability and readability
   - **Example**:
   ```swift
   // Instead of 14 separate closures, use:
   protocol InterviewOrchestratorDelegate: AnyObject, Sendable {
       func updateProcessingState(_ processing: Bool) async
       func emitAssistantMessage(_ text: String) async -> UUID
       // ... other methods
   }
   ```

2. **Redundant allowedToolsMap** (Priority: Medium)
   - **Lines**: 47-82
   - **Problem**: 36 lines of hardcoded tool lists per phase. Tools are repeated across phases (e.g., "get_user_option" appears 4 times, "persist_data" appears 3 times).
   - **Recommendation**: Define base tool set and phase-specific additions. Use set operations to compose final lists.
   - **Effort**: Low
   - **Impact**: ~20 LOC reduction
   - **Example**:
   ```swift
   private static let baseTool = ["get_user_option", "persist_data", ...]
   private static let phase1Additions = ["get_macos_contact_card", ...]
   // Compose at runtime: baseTool + phase1Additions
   ```

3. **DEPRECATED method still present** (Priority: High)
   - **Lines**: 208-244
   - **Problem**: 37 lines of dead code explicitly marked as deprecated with comment "DEPRECATED: This imperative orchestration is replaced by LLM-driven flow". Method `runPhaseOne()` is not called anywhere.
   - **Recommendation**: Delete immediately. Keeping deprecated code creates confusion and maintenance burden.
   - **Effort**: Low
   - **Impact**: 37 LOC reduction
   - **Risk**: None - explicitly marked as deprecated and unused

4. **Dead code collection methods** (Priority: High)
   - **Lines**: 246-347
   - **Problem**: Methods `collectApplicantProfile()` and `collectSkeletonTimeline()` (102 lines total) are only called from the deprecated `runPhaseOne()` method. These implement the "imperative orchestration" that was replaced.
   - **Recommendation**: Delete along with deprecated method.
   - **Effort**: Low
   - **Impact**: 102 LOC reduction
   - **Risk**: None - only called from deprecated code

5. **Verbose stream buffer management** (Priority: Medium)
   - **Lines**: 516-604
   - **Problem**: 88 lines of complex streaming logic with nested conditionals, multiple buffer dictionaries, and repetitive nil-coalescing patterns. The logic for managing `streamBuffers`, `messageIdByOutputItem`, and `reasoningSummaryBuffers` is intertwined.
   - **Recommendation**: Extract streaming logic to dedicated `StreamManager` class with clearer responsibilities.
   - **Effort**: Medium
   - **Impact**: ~20 LOC reduction through consolidation + major readability improvement

6. **Duplicate sanitization logic** (Priority: Medium)
   - **Lines**: 781-819
   - **Problem**: Three nearly identical case blocks in `sanitizeToolOutput()` that all call `removeHiddenEmailOptions()` and `attachValidationMetaIfNeeded()`. The pattern is repeated with minor variations.
   - **Recommendation**: Extract common sanitization pattern to helper method, pass data type as parameter.
   - **Effort**: Low
   - **Impact**: ~25 LOC reduction

7. **Redundant conversation state updates** (Priority: Low)
   - **Lines**: 841-846
   - **Problem**: Method `updateConversationState()` is 6 lines but called from 5 different places in the streaming handler. Could be inlined or the pattern suggests missing abstraction.
   - **Recommendation**: Consider making response handling more compositional so state updates happen automatically.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

8. **Over-engineered queueDescription helper** (Priority: Low)
   - **Lines**: 927-971
   - **Problem**: 45 lines to extract a user-friendly string from JSON payload. Multiple fallback paths with repetitive nil-checking and string manipulation.
   - **Recommendation**: Use dictionary-based priority lookup or chain of responsibility pattern. Simplify nested conditionals.
   - **Effort**: Low
   - **Impact**: ~15 LOC reduction

---

### OnboardingInterviewCoordinator.swift
**Current LOC**: 1,208
**Estimated reducible LOC**: 300-350

#### Issues Found

1. **God Object Anti-Pattern** (Priority: High)
   - **Lines**: 1-1208 (entire file)
   - **Problem**: Coordinator is doing everything: state management, checkpoint persistence, data storage, artifact management, developer message queueing, objective tracking, wizard progress, tool routing delegation, phase advancement, etc. The class has 20+ private methods and manages 25+ properties.
   - **Recommendation**: Split into focused classes: `CheckpointCoordinator`, `ArtifactStore`, `ObjectiveTracker`, `DeveloperMessageQueue`, `PhaseManager`. Keep Coordinator as thin orchestration layer.
   - **Effort**: High
   - **Impact**: Massive maintainability improvement, enables testing individual concerns. Would restructure rather than reduce LOC, but removes cognitive overhead.

2. **Duplicate storage methods (async/sync variants)** (Priority: High)
   - **Lines**: 482-583 (public sync) vs 1096-1153 (private async)
   - **Problem**: Near-identical implementations of `storeApplicantProfile()`, `storeSkeletonTimeline()`, `storeArtifactRecord()`, and `storeKnowledgeCard()` appear twice - once as public synchronous methods and again as private async methods. The async variants add checkpoint persistence and objective recording. ~100 lines of duplication.
   - **Recommendation**: Keep only async variants, make them public. Remove sync wrappers entirely.
   - **Effort**: Low
   - **Impact**: ~90 LOC reduction
   - **Example**: Lines 1096-1106 vs 482-492 are nearly identical

3. **Verbose objective status handling** (Priority: Medium)
   - **Lines**: 86-135
   - **Problem**: 50 lines to record objective status with extensive formatting, message assembly, and observer notification. The `objectiveStatusMessage()` method manually constructs strings from components.
   - **Recommendation**: Move formatting to `ObjectiveEntry` extension, use computed property for status string representation.
   - **Effort**: Low
   - **Impact**: ~15 LOC reduction

4. **Redundant tool wait tracking** (Priority: Medium)
   - **Lines**: 141-204
   - **Problem**: 64 lines for tool queue management with `ToolQueueEntry` struct, manual dictionary tracking, verbose message formatting in `registerToolWait()` and related methods.
   - **Recommendation**: Extract `ToolWaitQueue` class to encapsulate this behavior. The queue logic doesn't need to live in Coordinator.
   - **Effort**: Medium
   - **Impact**: ~40 LOC reduction in Coordinator

5. **Excessive passthrough properties** (Priority: Medium)
   - **Lines**: 278-314
   - **Problem**: 37 lines of computed properties that just forward to `toolRouter` or `wizardTracker`. Examples: `messages`, `pendingChoicePrompt`, `pendingValidationPrompt`, `pendingUploadRequests`, etc.
   - **Recommendation**: Expose `toolRouter` and `wizardTracker` as public properties and let callers access directly, or use `@dynamicMemberLookup` if you want to maintain the facade.
   - **Effort**: Low
   - **Impact**: ~30 LOC reduction

6. **Duplicate checkpoint save logic** (Priority: Medium)
   - **Lines**: 459-472 vs 1155-1162
   - **Problem**: `saveCheckpoint()` and `persistCheckpoint()` do essentially the same thing - call `checkpoints.save()` with current state. The distinction is unclear.
   - **Recommendation**: Keep one method, ensure all callers use it consistently.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction

7. **Overly complex phase advance flow** (Priority: High)
   - **Lines**: 742-875
   - **Problem**: 134 lines to manage phase advance requests with caching, approval/denial, logging, multiple state updates, and waiting state coordination. The flow is difficult to trace.
   - **Recommendation**: Extract `PhaseAdvanceRequestHandler` with clear state machine. Current implementation mixes UI state (`pendingPhaseAdvanceRequest`), business logic (phase advancement), and logging.
   - **Effort**: High
   - **Impact**: ~30 LOC reduction + significant clarity improvement

8. **Verbose orchestrator factory** (Priority: Medium)
   - **Lines**: 1011-1094
   - **Problem**: 84 lines to construct orchestrator callbacks. Each callback is a multi-line closure with `[weak self]` capture, nil-checking, and `MainActor.run` wrapping. This is primarily due to Issue #1 in InterviewOrchestrator (Callbacks struct).
   - **Recommendation**: Use protocol delegation (see Orchestrator recommendation). This becomes a simple delegate assignment.
   - **Effort**: Medium (depends on Orchestrator refactor)
   - **Impact**: ~70 LOC reduction

9. **Unnecessary PhaseAdvanceBlockCache struct** (Priority: Low)
   - **Lines**: 1192-1201
   - **Problem**: 10-line struct with one method used only for caching denied phase advance responses. Over-engineered for its single use case.
   - **Recommendation**: Replace with tuple or simple dictionary keyed by sorted objective list.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

10. **Redundant wizard progress methods** (Priority: Low)
    - **Lines**: 374-388 vs 1007-1009
    - **Problem**: `syncWizardProgress()` and `applyWizardProgress()` both call `wizardTracker.syncProgress()`. Why two names for the same operation?
    - **Recommendation**: Keep one name, delete the other.
    - **Effort**: Low
    - **Impact**: ~5 LOC reduction

---

### OnboardingInterviewService.swift
**Current LOC**: 851
**Estimated reducible LOC**: 150-180

#### Issues Found

1. **Redundant facade layer** (Priority: High)
   - **Lines**: 19-53
   - **Problem**: Service exposes 14 computed properties that simply forward to `coordinator` properties with no transformation. This entire file is essentially a passthrough to Coordinator.
   - **Recommendation**: **Question the need for this entire class.** If Service doesn't add meaningful orchestration beyond Coordinator, consider eliminating it and using Coordinator directly. This is the core architectural sprawl issue.
   - **Effort**: High (architectural decision)
   - **Impact**: Could eliminate entire 851-line file if Coordinator is made MainActor-compatible
   - **Context**: Service init (lines 74-120) just constructs dependencies and passes them to Coordinator. The "internal state" (lines 60-71) is mostly coordinator references.

2. **Duplicate async forwarding methods** (Priority: High)
   - **Lines**: 143-214
   - **Problem**: 72 lines of methods that await coordinator methods and return results unchanged. Examples: `currentSession()`, `hasRestorableCheckpoint()`, `missingObjectives()`, `advancePhase()`, etc.
   - **Recommendation**: If Service layer is kept, these should be `var` computed properties accessing coordinator, not `func` methods that add async overhead for no reason.
   - **Effort**: Low
   - **Impact**: ~40 LOC reduction

3. **Verbose tool continuation helper** (Priority: Medium)
   - **Lines**: 266-286
   - **Problem**: 21 lines for `resumeToolContinuation()` helper that could be 3 lines. The `waitingState` enum and switch add complexity without benefit.
   - **Recommendation**: Inline the method or simplify - callers already know what waiting state to set.
   - **Effort**: Low
   - **Impact**: ~15 LOC reduction

4. **Repetitive handler presentation methods** (Priority: Medium)
   - **Lines**: 290-518
   - **Problem**: 229 lines of nearly identical method patterns: present → clear → resolve/cancel. Each handler type (choice, validation, profile, upload, section) has 4-6 methods with the same structure. Only the coordinator method name changes.
   - **Recommendation**: Use generic handler protocol or macro to generate these. Pattern is: `coordinator.{handlerMethod}()` + optional state update.
   - **Effort**: Medium
   - **Impact**: ~80 LOC reduction through abstraction

5. **Duplicate applicant profile methods** (Priority: Medium)
   - **Lines**: 312-473
   - **Problem**: Multiple methods for applicant profile handling with overlapping concerns: `presentApplicantProfileRequest`, `resolveApplicantProfile`, `rejectApplicantProfile`, `presentApplicantProfileIntake`, plus 8 more intake methods. 162 lines total for what could be consolidated profile state machine.
   - **Recommendation**: Extract `ApplicantProfileStateMachine` that encapsulates all profile-related transitions.
   - **Effort**: Medium
   - **Impact**: ~40 LOC reduction

6. **Scattered developer message sending** (Priority: Medium)
   - **Lines**: 640-825
   - **Problem**: 186 lines dedicated to formatting and sending developer messages. Multiple similar methods: `sendDeveloperStatus`, `sendApplicantProfileIntakeStatus`, `sendApplicantProfileURLStatus`, `sendApplicantProfileValidationStatus`, `sendUploadStatus`, plus template-building helpers.
   - **Recommendation**: These should be methods on `DeveloperMessageTemplates` struct, not scattered in Service. Move formatting and sending logic together.
   - **Effort**: Low
   - **Impact**: ~30 LOC reduction in Service (moves to better location)

7. **Confusing persistApplicantProfile naming** (Priority: Low)
   - **Lines**: 727-739
   - **Problem**: Method name suggests it only persists, but it also coordinates checkpoint saves and sends developer messages. Name doesn't reflect full behavior.
   - **Recommendation**: Rename to `saveAndPersistApplicantProfile()` or split into two methods if responsibilities should be separate.
   - **Effort**: Low
   - **Impact**: Clarity only, no LOC change

8. **Unnecessary photoFollowUp gate** (Priority: Low)
   - **Lines**: 741-774
   - **Problem**: 34 lines to manage photo upload follow-up with gates, flags, and tool override. This feels like business logic that should be in phase script or orchestrator, not Service.
   - **Recommendation**: Move to phase script system or remove if not actually used.
   - **Effort**: Medium
   - **Impact**: ~30 LOC reduction if removable

9. **Empty objective observer handling** (Priority: Low)
   - **Lines**: 790-826
   - **Problem**: 37 lines for `handleObjectiveStatusUpdate()` that currently only checks one objective (`contact_photo_collected`) then delegates to workflow system. Seems over-engineered for minimal logic.
   - **Recommendation**: Inline the photo check, let workflow system handle everything else directly.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction

---

### CheckpointActor.swift
**Current LOC**: 171
**Estimated reducible LOC**: 20-30

#### Issues Found

1. **Redundant history reload** (Priority: Low)
   - **Lines**: 125-127, 141-143
   - **Problem**: Both `restoreLatest()` and `hasCheckpoint()` reload history from disk via `Self.loadHistory()`. If these are called in sequence, file is read twice unnecessarily.
   - **Recommendation**: Add cached last-modified check or only reload if file changed. Acceptable as-is for infrequent operations.
   - **Effort**: Low
   - **Impact**: Minor performance gain, ~5 LOC for optimization

2. **Verbose checkpoint init** (Priority: Low)
   - **Lines**: 30-46
   - **Problem**: 17 lines of initializer that just assigns parameters. Could use memberwise init.
   - **Recommendation**: Remove custom init unless there's specific validation needed.
   - **Effort**: Low
   - **Impact**: ~15 LOC reduction

3. **Explicit encode/decode implementations** (Priority: Low)
   - **Lines**: 48-68
   - **Problem**: 21 lines of manual Codable implementation for simple struct with optional fields. Swift can synthesize this.
   - **Recommendation**: Remove explicit implementations, rely on synthesis. Only needed if custom logic required.
   - **Effort**: Low
   - **Impact**: ~20 LOC reduction
   - **Note**: If objectiveLedger default is needed, use `@DefaultEmpty` property wrapper pattern

**Overall Assessment**: This file is actually quite clean. Issues are minor and mostly about unnecessary verbosity rather than sprawl.

---

### InterviewSession.swift
**Current LOC**: 175
**Estimated reducible LOC**: 30-40

#### Issues Found

1. **Duplicate phase requirements** (Priority: Medium)
   - **Lines**: 63-75 vs 97-109
   - **Problem**: `missingObjectives()` and `shouldAdvancePhase()` both define the same objective lists for each phase. The required objectives list appears twice with same hardcoded values.
   - **Recommendation**: Extract phase requirements to single source. Use static property or method that returns required objectives per phase.
   - **Effort**: Low
   - **Impact**: ~20 LOC reduction
   - **Example**:
   ```swift
   private static func requiredObjectives(for phase: InterviewPhase) -> [String] {
       switch phase {
           case .phase1CoreFacts: return ["applicant_profile", ...]
           // ...
       }
   }
   ```

2. **Redundant phase advancement logic** (Priority: Low)
   - **Lines**: 91-94 vs 112-123
   - **Problem**: Two separate `advancePhase()` methods - one public that calls private. The public version adds logging but otherwise identical to private.
   - **Recommendation**: Combine into single method. If you want logging, add it to the one method.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction

3. **Unused shouldAdvancePhase check** (Priority: Low)
   - **Lines**: 96-110
   - **Problem**: Method `shouldAdvancePhase()` is defined but never called (checked with grep). Dead code.
   - **Recommendation**: Delete if truly unused, or integrate into advancement logic if it should be validating.
   - **Effort**: Low
   - **Impact**: ~15 LOC reduction

4. **Verbose objective registration** (Priority: Low)
   - **Lines**: 125-136
   - **Problem**: 12 lines to register objectives with manual nil-checking and label updates. The loop could be more concise.
   - **Recommendation**: Use `merge(_:uniquingKeysWith:)` for dictionary updates instead of manual nil checks.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

---

### ObjectiveLedger.swift
**Current LOC**: 161
**Estimated reducible LOC**: 20-30

#### Issues Found

1. **Overly complex signature computation** (Priority: Low)
   - **Lines**: 57-68
   - **Problem**: 12 lines to compute unique signature string with nested mapping and sorting. Difficult to read.
   - **Recommendation**: Extract detail formatting to helper, simplify nested map/sort operations.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction + readability

2. **Redundant ObjectiveDescriptor struct** (Priority: Low)
   - **Lines**: 9-43
   - **Problem**: 35 lines for descriptor that exists only to create `ObjectiveEntry` via `makeEntry()`. Why not construct `ObjectiveEntry` directly? The descriptor adds an unnecessary layer.
   - **Recommendation**: Remove `ObjectiveDescriptor`, create `ObjectiveEntry` directly with factory method or builder if needed.
   - **Effort**: Low
   - **Impact**: ~30 LOC reduction across codebase (would affect callers)
   - **Risk**: Low - simple refactor

3. **Hardcoded objective catalogs** (Priority: Medium)
   - **Lines**: 83-161
   - **Problem**: 79 lines of static objective definitions spread across three private arrays. This could be externalized to configuration file (JSON/YAML) for easier modification without recompilation.
   - **Recommendation**: Load objectives from configuration file. Would make objectives data-driven rather than hardcoded.
   - **Effort**: Medium
   - **Impact**: ~70 LOC reduction, massive flexibility gain for adding phases/objectives

**Overall Assessment**: This file is reasonable. The main opportunity is making objectives configurable rather than hardcoded in Swift.

---

### ModelProvider.swift
**Current LOC**: 71
**Estimated reducible LOC**: 10-15

#### Issues Found

1. **Redundant Config struct** (Priority: Low)
   - **Lines**: 19-23
   - **Problem**: 5 lines for simple value struct with 3 properties. Could be tuple or inline.
   - **Recommendation**: Return tuple from `forTask()` unless Config struct is exposed publicly and needs to be typed.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

2. **Unused escalate method** (Priority: Low)
   - **Lines**: 54-60
   - **Problem**: 7 lines for `escalate()` method that's defined but never called in codebase (verified with grep). Appears to be "future-proofing" for model fallback that isn't implemented.
   - **Recommendation**: Delete until needed. YAGNI principle.
   - **Effort**: Low
   - **Impact**: ~7 LOC reduction

3. **Over-engineered reasoning effort lookup** (Priority: Low)
   - **Lines**: 62-70
   - **Problem**: 9 lines with UserDefaults lookup, validation, and fallback for reasoning effort. Could be simplified.
   - **Recommendation**: Use nil-coalescing chain or computed property.
   - **Effort**: Low
   - **Impact**: ~3 LOC reduction

**Overall Assessment**: Clean, focused file. Issues are truly minor.

---

### DeveloperMessageTemplates.swift
**Current LOC**: 92
**Estimated reducible LOC**: 15-20

#### Issues Found

1. **Repetitive Message struct usage** (Priority: Low)
   - **Lines**: 11-92
   - **Problem**: Every method returns `Message(title:details:payload:)`. The struct exists solely as return value container. Could use tuple.
   - **Recommendation**: Return tuple `(title: String, details: [String: String], payload: JSON?)` or make methods return components separately.
   - **Effort**: Low
   - **Impact**: ~5 LOC reduction

2. **Verbose string construction** (Priority: Low)
   - **Lines**: Multiple locations
   - **Problem**: Several methods build title strings with manual concatenation and conditional logic. For example, `contactValidation()` has 7 lines just to build title and add conditional suffix.
   - **Recommendation**: Use string interpolation templates or builder pattern for complex messages.
   - **Effort**: Low
   - **Impact**: ~10 LOC reduction

**Overall Assessment**: Very clean file. These are nitpicks.

---

### OnboardingToolRouter.swift
**Current LOC**: 280
**Estimated reducible LOC**: 40-50

#### Issues Found

1. **Repetitive delegation pattern** (Priority: Medium)
   - **Lines**: 86-246
   - **Problem**: 161 lines of methods that are pure delegation to handlers with zero additional logic. Each method is 1-2 lines: `handlerName.method(args)`. This is boilerplate.
   - **Recommendation**: Expose handlers as public properties and let callers access directly, or use `@dynamicMemberLookup` for automatic forwarding.
   - **Effort**: Low
   - **Impact**: ~40 LOC reduction
   - **Example**: Instead of `func resolveChoice() { promptHandler.resolveChoice() }`, expose `promptHandler` and call `router.promptHandler.resolveChoice()`

2. **Verbose status resolver setup** (Priority: Low)
   - **Lines**: 256-279
   - **Problem**: 24 lines of closure-based status resolver configuration with repetitive structure. Each tool gets a closure that checks handler state.
   - **Recommendation**: If all handlers implemented `ToolStateProvider` protocol, this could be: `statusResolvers = handlers.mapValues { $0.currentStatus }`.
   - **Effort**: Medium
   - **Impact**: ~15 LOC reduction

3. **Unnecessary enum cases** (Priority: Low)
   - **Lines**: 6-13
   - **Problem**: `OnboardingToolIdentifier` enum defines 6 tools but `statusResolvers` only configures 5. The pattern suggests missing implementation.
   - **Recommendation**: Either add resolver for `extractDocument` or document why it's excluded.
   - **Effort**: Low
   - **Impact**: Consistency/completeness, no LOC change

**Overall Assessment**: Router is a thin delegation layer. Main issue is whether this layer adds value or just adds indirection.

---

## Cross-Cutting Patterns

### 1. Three-Tier Architecture Sprawl (Critical)
**Files**: InterviewOrchestrator.swift, OnboardingInterviewCoordinator.swift, OnboardingInterviewService.swift

**Pattern**:
- **Orchestrator** (982 LOC): Handles OpenAI API communication, streaming, tool execution coordination
- **Coordinator** (1,208 LOC): Manages state, checkpoints, artifacts, callbacks, wizard progress, objectives
- **Service** (851 LOC): Thin facade exposing Coordinator to SwiftUI with minimal added logic

**Impact**: 3,041 LOC across three tightly coupled classes that could be 1,800-2,000 LOC in two classes.

**Recommendation**:
1. **Merge Service into Coordinator** and make Coordinator `@MainActor` compatible. Service adds almost no value - it's 90% passthrough methods. This eliminates 600-700 LOC of delegation.
2. **Keep Orchestrator separate** as actor for OpenAI streaming isolation, but simplify its callback interface (see Orchestrator Issue #1).
3. Result: Two-tier architecture (Orchestrator + Coordinator) instead of three tiers.

**Estimated Impact**: 500-700 LOC reduction, dramatic simplification of calling patterns

---

### 2. Async/Sync Method Duplication
**Files**: OnboardingInterviewCoordinator.swift, OnboardingInterviewService.swift

**Pattern**: Same operations implemented twice - once synchronously (public) and once asynchronously (private). Examples:
- `storeApplicantProfile()` appears as sync public (line 482) and async private (line 1096)
- `storeSkeletonTimeline()` appears as sync public (line 513) and async private (line 1116)
- Multiple Service methods wrap async Coordinator calls unnecessarily

**Recommendation**: Choose async as canonical implementation. Remove sync wrappers. Modern Swift prefers async/await over completion handlers or sync wrappers.

**Estimated Impact**: 120-150 LOC reduction

---

### 3. Deprecated Code Still Present
**Files**: InterviewOrchestrator.swift

**Pattern**:
- `runPhaseOne()` marked DEPRECATED (line 208)
- `collectApplicantProfile()` only called from deprecated method (line 246)
- `collectSkeletonTimeline()` only called from deprecated method (line 284)
- Total: 139 lines of dead code explicitly marked as obsolete

**Recommendation**: Delete immediately. Zero risk, pure benefit.

**Estimated Impact**: 139 LOC reduction

---

### 4. Verbose Closure-Based Callbacks
**Files**: InterviewOrchestrator.swift, OnboardingInterviewCoordinator.swift

**Pattern**:
- Orchestrator Callbacks struct: 14 individual closures (19 lines)
- Coordinator's `makeOrchestrator()`: 84 lines to construct those callbacks
- Each callback: capture list + nil check + MainActor.run wrapper = 4-6 lines

**Recommendation**: Replace with protocol delegation. Single protocol with 14 methods is clearer than 14 separate closure properties.

**Estimated Impact**: 75-90 LOC reduction + major testability improvement

---

### 5. Hardcoded Phase Configuration
**Files**: InterviewOrchestrator.swift (allowedToolsMap), InterviewSession.swift (phase requirements), ObjectiveLedger.swift (objective catalogs)

**Pattern**: Phase-specific behavior (required objectives, allowed tools, objective descriptors) hardcoded in Swift across multiple files.

**Recommendation**: Centralize phase configuration in single data structure or external configuration file. This would enable adding/modifying phases without code changes.

**Estimated Impact**: 100-120 LOC reduction through consolidation, massive flexibility gain

---

## Prioritized Recommendations

### Quick Wins (High Impact, Low Effort)

1. **Delete deprecated code in InterviewOrchestrator**
   - Files: InterviewOrchestrator.swift
   - Effort: 15 minutes
   - Impact: 139 LOC reduction, zero risk

2. **Remove duplicate async/sync storage methods in Coordinator**
   - Files: OnboardingInterviewCoordinator.swift
   - Effort: 30 minutes
   - Impact: ~90 LOC reduction

3. **Simplify tool map in Orchestrator to base + additions**
   - Files: InterviewOrchestrator.swift
   - Effort: 20 minutes
   - Impact: ~20 LOC reduction, easier to maintain

4. **Remove unused methods** (`shouldAdvancePhase`, `escalate`)
   - Files: InterviewSession.swift, ModelProvider.swift
   - Effort: 10 minutes
   - Impact: ~22 LOC reduction

5. **Eliminate passthrough properties in Coordinator**
   - Files: OnboardingInterviewCoordinator.swift
   - Effort: 20 minutes
   - Impact: ~30 LOC reduction

**Quick Wins Total**: ~300 LOC reduction, 2-3 hours effort

---

### Medium-term Improvements (High Impact, Medium Effort)

1. **Merge OnboardingInterviewService into OnboardingInterviewCoordinator**
   - Files: OnboardingInterviewService.swift, OnboardingInterviewCoordinator.swift
   - Effort: 1-2 days (requires updating all callers)
   - Impact: 600-700 LOC reduction, eliminates unnecessary abstraction layer
   - Note: Make Coordinator `@MainActor` compatible

2. **Extract ToolWaitQueue from Coordinator**
   - Files: OnboardingInterviewCoordinator.swift
   - Effort: 2-3 hours
   - Impact: ~50 LOC reduction in Coordinator, better separation of concerns

3. **Extract StreamManager from Orchestrator**
   - Files: InterviewOrchestrator.swift
   - Effort: 3-4 hours
   - Impact: ~30 LOC reduction, major readability improvement

4. **Consolidate duplicate phase requirements definitions**
   - Files: InterviewSession.swift
   - Effort: 1 hour
   - Impact: ~20 LOC reduction, single source of truth

5. **Simplify handler delegation in ToolRouter**
   - Files: OnboardingToolRouter.swift
   - Effort: 2-3 hours
   - Impact: ~40 LOC reduction or expose handlers directly

**Medium-term Total**: ~750-850 LOC reduction, 1-2 weeks effort

---

### Strategic Refactoring (High Impact, High Effort)

1. **Replace closure callbacks with protocol delegation**
   - Files: InterviewOrchestrator.swift, OnboardingInterviewCoordinator.swift
   - Effort: 1-2 weeks (design protocol, refactor all callback sites, add tests)
   - Impact: ~90 LOC reduction + massive testability and clarity gain
   - Benefits: Can mock delegate for testing, clearer contracts, standard Swift pattern

2. **Decompose Coordinator god object**
   - Files: OnboardingInterviewCoordinator.swift
   - Effort: 2-3 weeks (extract CheckpointCoordinator, ArtifactStore, ObjectiveTracker, PhaseManager)
   - Impact: No LOC reduction but massive maintainability improvement
   - Benefits: Each concern can be tested independently, clearer boundaries

3. **Centralize phase configuration**
   - Files: Multiple (InterviewOrchestrator, InterviewSession, ObjectiveLedger)
   - Effort: 1-2 weeks (design config structure, refactor all access points)
   - Impact: ~120 LOC reduction + data-driven phase management
   - Benefits: Can add phases without code changes, easier to visualize phase flow

4. **Extract ApplicantProfileStateMachine**
   - Files: OnboardingInterviewService.swift
   - Effort: 1 week
   - Impact: ~80 LOC reduction in Service, clearer profile state transitions
   - Benefits: Explicit state machine makes valid transitions obvious

**Strategic Total**: ~290 LOC reduction + architectural clarity, 2-3 months effort

---

### Not Recommended (Low Impact or High Risk)

1. **Extract all developer message formatting to templates**
   - Reason: Current implementation is already reasonably clear. Moving would just shift LOC.
   - Risk: Medium coupling between message content and business logic context

2. **Replace ObjectiveEntry with protocol-based system**
   - Reason: Current struct-based approach is simple and works well
   - Risk: Over-engineering for marginal benefit

3. **Split InterviewOrchestrator into multiple smaller actors**
   - Reason: Actor is already focused on API communication and streaming. Further splitting would complicate actor isolation.
   - Risk: High - increased actor coordination complexity

---

## Total Impact Summary

- **Quick Wins**: ~300 LOC reduction (2-3 hours)
- **Medium-term**: ~750 LOC reduction (1-2 weeks)
- **Strategic**: ~290 LOC reduction + major architectural clarity (2-3 months)
- **Total Potential**: **~1,340 LOC reduction** (34% of current size)

**Beyond LOC**: The real value is reducing cognitive load. Consolidating the three-tier architecture to two tiers, eliminating the Service passthrough layer, and replacing verbose callback closures with protocols would make this codebase dramatically easier to understand and modify. The current sprawl isn't just about line count - it's about having to trace through three layers of delegation to understand a single operation.

---

## Methodology Notes

- **Line counts**: Measured with `wc -l`, verified against file readers
- **Usage analysis**: Used `grep` to search for method references outside Core directory
- **Duplication detection**: Manual inspection and pattern matching across similar method signatures
- **Priority assignment**: Based on LOC impact × effort ratio and architectural significance
- **Estimates**: Conservative; actual reduction may be higher with aggressive refactoring

**Date of Analysis**: 2025-10-30
**Analyzed by**: Claude Code (Sonnet 4.5)
**Context**: Post-manager-consolidation refactoring phase
