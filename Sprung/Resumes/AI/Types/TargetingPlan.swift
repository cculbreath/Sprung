//
//  TargetingPlan.swift
//  Sprung
//
//  Strategic pre-analysis output that guides all downstream resume
//  customization tasks. Generated by TargetingPlanService before
//  parallel field generation begins.
//

import Foundation

// MARK: - Targeting Plan

/// Strategic analysis output that establishes the resume's narrative angle
/// for a specific job application. Maps knowledge cards to sections,
/// identifies emphasis themes, and coordinates work entry framing
/// so parallel field generators produce coherent, differentiated output.
struct TargetingPlan: Codable, Sendable {
    /// The overarching narrative arc for this application.
    /// Describes what story the resume tells and why this candidate
    /// is a compelling fit for this specific role.
    var narrativeArc: String

    /// Which knowledge cards map to which resume sections.
    var kcSectionMapping: [KCSectionMapping]

    /// Themes to emphasize across all sections (3-5 themes).
    var emphasisThemes: [String]

    /// Per work entry: what angle to lead with, what to de-emphasize.
    var workEntryGuidance: [WorkEntryGuidance]

    /// Non-obvious skill transfers the LLM identified.
    var lateralConnections: [LateralConnection]

    /// Skills to prioritize for this specific application, ordered by importance.
    var prioritizedSkills: [String]

    /// Gaps in the candidate's profile relative to the job.
    var identifiedGaps: [String]

    /// Recommended KC relevance tiers (may augment preprocessor's relevantCardIds).
    var kcRelevanceTiers: KCRelevanceTiers
}

// MARK: - Supporting Types

/// Maps a knowledge card to the resume section where its evidence is most powerful.
struct KCSectionMapping: Codable, Sendable, Identifiable {
    var id: String { cardId }

    /// UUID string of the knowledge card.
    let cardId: String

    /// Human-readable title of the card (for display purposes).
    let cardTitle: String

    /// Recommended resume section: "work", "projects", "skills", "summary", "education".
    let recommendedSection: String

    /// Brief rationale for why this card maps to this section.
    let rationale: String
}

/// Guidance for framing a specific work entry in the resume.
struct WorkEntryGuidance: Codable, Sendable, Identifiable {
    var id: String { entryIdentifier }

    /// Identifier for the work entry (company name + role, or project name).
    let entryIdentifier: String

    /// The framing angle to lead with for this entry.
    let leadAngle: String

    /// What aspects to emphasize in bullets and descriptions.
    let emphasis: [String]

    /// What aspects to de-emphasize or omit for this application.
    let deEmphasis: [String]

    /// Which knowledge card IDs provide evidence for this entry.
    let supportingCardIds: [String]
}

/// A non-obvious connection between the candidate's experience and a job requirement.
struct LateralConnection: Codable, Sendable, Identifiable {
    var id: String { "\(sourceCardId)-\(targetRequirement.prefix(30))" }

    /// UUID string of the source knowledge card.
    let sourceCardId: String

    /// Human-readable title of the source card.
    let sourceCardTitle: String

    /// The job requirement this experience connects to.
    let targetRequirement: String

    /// Explanation of how the experience transfers.
    let reasoning: String
}

/// Tiered relevance classification for knowledge cards.
/// May augment or refine the preprocessor's initial relevantCardIds.
struct KCRelevanceTiers: Codable, Sendable {
    /// Card IDs directly relevant to the target role.
    let primary: [String]

    /// Card IDs with transferable skills or supporting evidence.
    let supporting: [String]

    /// Card IDs providing breadth context only.
    let background: [String]
}

// MARK: - Prompt Formatting

extension TargetingPlan {
    /// Converts the targeting plan into a markdown string suitable
    /// for inclusion in downstream task prompts.
    func formattedForPrompt() -> String {
        var sections: [String] = []

        // Narrative arc
        sections.append("""
        ## Strategic Targeting Plan

        ### Narrative Arc
        \(narrativeArc)
        """)

        // Emphasis themes
        if !emphasisThemes.isEmpty {
            let themeList = emphasisThemes.map { "- \($0)" }.joined(separator: "\n")
            sections.append("""
            ### Emphasis Themes
            Weave these themes throughout all sections:
            \(themeList)
            """)
        }

        // Work entry guidance
        if !workEntryGuidance.isEmpty {
            var lines = ["### Work Entry Framing"]
            for entry in workEntryGuidance {
                lines.append("")
                lines.append("**\(entry.entryIdentifier)**")
                lines.append("Lead with: \(entry.leadAngle)")
                if !entry.emphasis.isEmpty {
                    lines.append("Emphasize: \(entry.emphasis.joined(separator: "; "))")
                }
                if !entry.deEmphasis.isEmpty {
                    lines.append("De-emphasize: \(entry.deEmphasis.joined(separator: "; "))")
                }
            }
            sections.append(lines.joined(separator: "\n"))
        }

        // Lateral connections
        if !lateralConnections.isEmpty {
            var lines = ["### Lateral Connections (Non-Obvious Skill Transfers)"]
            for connection in lateralConnections {
                lines.append("- **\(connection.sourceCardTitle)** -> \(connection.targetRequirement): \(connection.reasoning)")
            }
            sections.append(lines.joined(separator: "\n"))
        }

        // Prioritized skills
        if !prioritizedSkills.isEmpty {
            let skillList = prioritizedSkills.enumerated().map { "\($0.offset + 1). \($0.element)" }.joined(separator: "\n")
            sections.append("""
            ### Prioritized Skills
            Feature these skills prominently, in order of importance:
            \(skillList)
            """)
        }

        // Identified gaps
        if !identifiedGaps.isEmpty {
            let gapList = identifiedGaps.map { "- \($0)" }.joined(separator: "\n")
            sections.append("""
            ### Identified Gaps
            Address these gaps through framing rather than fabrication:
            \(gapList)
            """)
        }

        // KC section mapping summary
        if !kcSectionMapping.isEmpty {
            var lines = ["### Knowledge Card Section Assignments"]
            let grouped = Dictionary(grouping: kcSectionMapping, by: { $0.recommendedSection })
            for (section, mappings) in grouped.sorted(by: { $0.key < $1.key }) {
                lines.append("")
                lines.append("**\(section.capitalized):**")
                for mapping in mappings {
                    lines.append("- \(mapping.cardTitle): \(mapping.rationale)")
                }
            }
            sections.append(lines.joined(separator: "\n"))
        }

        return sections.joined(separator: "\n\n")
    }

    /// Extract guidance for a specific work entry by identifier.
    /// Returns nil if no guidance exists for that entry.
    func guidance(forEntry identifier: String) -> WorkEntryGuidance? {
        workEntryGuidance.first { $0.entryIdentifier == identifier }
    }

    /// Extract KC mappings for a specific resume section.
    func cardMappings(forSection section: String) -> [KCSectionMapping] {
        kcSectionMapping.filter { $0.recommendedSection == section }
    }
}

// MARK: - Minimal Default

extension TargetingPlan {
    /// Creates a minimal targeting plan that doesn't block downstream work.
    /// Used as a fallback when the LLM call fails.
    static func minimal() -> TargetingPlan {
        TargetingPlan(
            narrativeArc: "",
            kcSectionMapping: [],
            emphasisThemes: [],
            workEntryGuidance: [],
            lateralConnections: [],
            prioritizedSkills: [],
            identifiedGaps: [],
            kcRelevanceTiers: KCRelevanceTiers(primary: [], supporting: [], background: [])
        )
    }
}
