//
//  CoverLetterStore.swift
//  Sprung
//
//
import Foundation
import SwiftData
import SwiftUI
@Observable
@MainActor
final class CoverLetterStore: SwiftDataStore {
    // MARK: - Properties
    unowned let modelContext: ModelContext
    var coverRefStore: CoverRefStore
    var cL: CoverLetter? // This is the currently selected/active cover letter instance
    var isGeneratingCoverLetter = false // Track when cover letter generation is in progress
    private let exportService: any CoverLetterExportService = LocalCoverLetterExportService()
    private let applicantProfileStore: ApplicantProfileStore
    // MARK: - Initialiser
    init(
        context: ModelContext,
        refStore: CoverRefStore,
        applicantProfileStore: ApplicantProfileStore
    ) {
        modelContext = context
        coverRefStore = refStore
        self.applicantProfileStore = applicantProfileStore
    }
    @discardableResult
    func addLetter(letter: CoverLetter, to jobApp: JobApp) -> CoverLetter {
        jobApp.coverLetters.append(letter)
        jobApp.selectedCover = letter
        modelContext.insert(letter)
        saveContext()
        return letter
    }
    @discardableResult
    func create(jobApp: JobApp) -> CoverLetter {
        let letter = CoverLetter(
            enabledRefs: coverRefStore.defaultSources,
            jobApp: jobApp
        )
        // Name will be set by processResults after AI generation.
        modelContext.insert(letter)
        saveContext()
        return letter
    }
    func createDuplicate(letter: CoverLetter) -> CoverLetter {
        // Ensure the context has pending changes saved before duplicating
        saveContext() // From `SwiftDataStore` extension
        let newLetter = CoverLetter(
            enabledRefs: letter.enabledRefs, // Copy enabled references
            jobApp: letter.jobApp // Associate with the same job application
        )
        newLetter.knowledgeCardInclusion = letter.knowledgeCardInclusion
        newLetter.selectedKnowledgeCardIds = letter.selectedKnowledgeCardIds
        newLetter.content = letter.content // Copy content for revision
        newLetter.generated = false // A duplicated letter for revision starts as not "freshly" generated by AI
        // It will be marked true by processResults after the revision.
        newLetter.currentMode = letter.currentMode // Copy current mode
        // Get next available option letter for the new cover letter
        let nextOptionLetter = newLetter.getNextOptionLetter()
        // Extract the part after the colon from the existing name (if any)
        let nameBase = letter.editableName
        // Set the new name with the next option letter
        newLetter.name = "Option \(nextOptionLetter): \(nameBase)"
        if let jobApp = letter.jobApp {
            addLetter(letter: newLetter, to: jobApp) // This also sets it as selectedCover on jobApp
        }
        // saveContext() // Context will be saved by the caller or at appropriate points
        return newLetter
    }
    func deleteLetter(_ letter: CoverLetter) {
        if let jobApp = letter.jobApp {
            if let index = jobApp.coverLetters.firstIndex(of: letter) {
                jobApp.coverLetters.remove(at: index)
                modelContext.delete(letter)
                saveContext() // Save the deletion
            }
        } else {
            // If the letter is not associated with a jobApp, just delete it.
            // This case should ideally not happen if data integrity is maintained.
            modelContext.delete(letter)
            saveContext() // Save the deletion
        }
    }
    /// Deletes all ungenerated draft cover letters to prevent accumulation of blank letters
    func deleteUngeneratedDrafts() {
        do {
            // Fetch all cover letters that are not generated (draft state)
            let descriptor = FetchDescriptor<CoverLetter>(
                predicate: #Predicate<CoverLetter> { letter in
                    !letter.generated && letter.content.isEmpty
                }
            )
            let ungeneratedDrafts = try modelContext.fetch(descriptor)
            // Delete each ungenerated draft
            for letter in ungeneratedDrafts {
                if let jobApp = letter.jobApp {
                    if let index = jobApp.coverLetters.firstIndex(of: letter) {
                        jobApp.coverLetters.remove(at: index)
                    }
                }
                modelContext.delete(letter)
            }
            if !ungeneratedDrafts.isEmpty {
                Logger.debug("ðŸ§¹ Cleaned up \(ungeneratedDrafts.count) ungenerated draft letters")
                saveContext()
            }
        } catch {
            Logger.error("Failed to cleanup ungenerated drafts: \(error.localizedDescription)")
        }
    }
    // `saveContext()` now provided by `SwiftDataStore` default implementation.
    // MARK: - PDF Export
    func exportPDF(from coverLetter: CoverLetter) -> Data {
        let applicant = Applicant(profile: applicantProfileStore.currentProfile())
        return exportService.exportPDF(from: coverLetter, applicant: applicant)
    }
}
