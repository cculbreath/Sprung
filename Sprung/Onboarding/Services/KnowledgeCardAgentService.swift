//
//  KnowledgeCardAgentService.swift
//  Sprung
//
//  Service for spawning parallel knowledge card generation agents.
//  Each agent runs in an isolated conversation thread with its own tool executor.
//  Results are collected and returned to the main coordinator for persistence.
//

import Foundation
import SwiftyJSON

// MARK: - Card Proposal

/// A chat excerpt to include as source material for a knowledge card
struct ChatExcerptInput: Codable {
    let excerpt: String      // The quoted text from conversation
    let context: String?     // Brief context explaining what it demonstrates

    init(excerpt: String, context: String? = nil) {
        self.excerpt = excerpt
        self.context = context
    }
}

/// Proposal for a knowledge card to be generated by a sub-agent
struct CardProposal: Codable {
    let cardId: String
    let cardType: String // "job" or "skill"
    let title: String
    let timelineEntryId: String?
    let assignedArtifactIds: [String]
    let chatExcerpts: [ChatExcerptInput]
    let notes: String?

    init(
        cardId: String = UUID().uuidString,
        cardType: String,
        title: String,
        timelineEntryId: String? = nil,
        assignedArtifactIds: [String] = [],
        chatExcerpts: [ChatExcerptInput] = [],
        notes: String? = nil
    ) {
        self.cardId = cardId
        self.cardType = cardType
        self.title = title
        self.timelineEntryId = timelineEntryId
        self.assignedArtifactIds = assignedArtifactIds
        self.chatExcerpts = chatExcerpts
        self.notes = notes
    }
}

// MARK: - Generated Card

/// A chat source from the agent output
struct ChatSourceOutput {
    let excerpt: String
    let context: String?
}

/// Result from a KC agent - the generated knowledge card data
struct GeneratedCard {
    let cardId: String
    let cardType: String
    let title: String
    let prose: String
    let sources: [String]  // Artifact IDs
    let chatSources: [ChatSourceOutput]  // Conversation excerpts used
    let highlights: [String]
    let skills: [String]
    let metrics: [String]
    let success: Bool
    let error: String?
    // Optional fields that may be extracted from timeline
    var timePeriod: String?
    var organization: String?
    var location: String?

    /// Convert to JSON format matching submit_knowledge_card schema.
    /// Output format:
    /// ```
    /// {
    ///   "card": { id, title, type, content, sources: [{type, artifact_id}], ... },
    ///   "summary": "Brief summary for UI"
    /// }
    /// ```
    func toJSON() -> JSON {
        var json = JSON()

        // Build the card object with submit_knowledge_card schema
        var card = JSON()
        card["id"].string = cardId
        card["title"].string = title
        card["type"].string = cardType  // "type" not "card_type"
        card["content"].string = prose   // "content" not "prose"

        // Transform sources from [String] to [{type: "artifact", artifact_id: String}]
        // and include chat sources as [{type: "chat", chat_excerpt: String, chat_context: String?}]
        var sourcesArray: [[String: Any]] = []
        for artifactId in sources {
            sourcesArray.append([
                "type": "artifact",
                "artifact_id": artifactId
            ])
        }
        for chatSource in chatSources {
            var chatDict: [String: Any] = [
                "type": "chat",
                "chat_excerpt": chatSource.excerpt
            ]
            if let context = chatSource.context {
                chatDict["chat_context"] = context
            }
            sourcesArray.append(chatDict)
        }
        card["sources"].arrayObject = sourcesArray

        // Add optional fields
        if let timePeriod = timePeriod {
            card["time_period"].string = timePeriod
        }
        if let organization = organization {
            card["organization"].string = organization
        }
        if let location = location {
            card["location"].string = location
        }

        json["card"] = card

        // Generate summary from card data
        let achievementCount = highlights.count + metrics.count
        let summary = "Knowledge card for \(title) with \(achievementCount) key achievements"
        json["summary"].string = summary

        // Include extra data that may be useful (not required by submit_knowledge_card)
        json["highlights"].arrayObject = highlights
        json["skills"].arrayObject = skills
        json["metrics"].arrayObject = metrics

        return json
    }

    /// Create from agent output
    static func fromAgentOutput(_ output: JSON, cardId: String) -> GeneratedCard {
        // Parse chat sources if provided
        let chatSources = output["chat_sources"].arrayValue.map { json in
            ChatSourceOutput(
                excerpt: json["excerpt"].stringValue,
                context: json["context"].string
            )
        }

        return GeneratedCard(
            cardId: cardId,
            cardType: output["card_type"].stringValue,
            title: output["title"].stringValue,
            prose: output["prose"].stringValue,
            sources: output["sources"].arrayValue.map { $0.stringValue },
            chatSources: chatSources,
            highlights: output["highlights"].arrayValue.map { $0.stringValue },
            skills: output["skills"].arrayValue.map { $0.stringValue },
            metrics: output["metrics"].arrayValue.map { $0.stringValue },
            success: true,
            error: nil,
            timePeriod: output["time_period"].string,
            organization: output["organization"].string,
            location: output["location"].string
        )
    }

    /// Create a failed card result
    static func failed(cardId: String, title: String, error: String) -> GeneratedCard {
        GeneratedCard(
            cardId: cardId,
            cardType: "",
            title: title,
            prose: "",
            sources: [],
            chatSources: [],
            highlights: [],
            skills: [],
            metrics: [],
            success: false,
            error: error,
            timePeriod: nil,
            organization: nil,
            location: nil
        )
    }
}

// MARK: - Dispatch Result

/// Result from dispatching multiple KC agents
struct KCDispatchResult {
    let cards: [GeneratedCard]
    let successCount: Int
    let failureCount: Int
    let totalDuration: TimeInterval

    var failedCards: [GeneratedCard] {
        cards.filter { !$0.success }
    }

    var successfulCards: [GeneratedCard] {
        cards.filter { $0.success }
    }
}

// MARK: - Knowledge Card Agent Service

/// Service that spawns parallel agents to generate knowledge cards.
/// Each agent runs in an isolated conversation thread.
actor KnowledgeCardAgentService {
    // MARK: - Dependencies

    private let artifactRepository: ArtifactRepository
    private weak var llmFacade: LLMFacade?
    private let tracker: AgentActivityTracker
    private let eventBus: EventCoordinator

    // MARK: - Configuration

    /// Maximum number of concurrent KC agents
    private let maxConcurrentAgents: Int

    // MARK: - Initialization

    init(
        artifactRepository: ArtifactRepository,
        llmFacade: LLMFacade?,
        tracker: AgentActivityTracker,
        eventBus: EventCoordinator,
        maxConcurrentAgents: Int = 3
    ) {
        self.artifactRepository = artifactRepository
        self.llmFacade = llmFacade
        self.tracker = tracker
        self.eventBus = eventBus
        self.maxConcurrentAgents = maxConcurrentAgents
        Logger.info("ðŸ¤– KnowledgeCardAgentService initialized (max concurrent: \(maxConcurrentAgents))", category: .ai)
    }

    // MARK: - Public API

    /// Dispatch multiple KC agents to generate cards in parallel
    /// - Parameters:
    ///   - proposals: Array of card proposals to generate
    ///   - allSummaries: All artifact summaries for agent reference
    /// - Returns: Results from all agents (successful and failed)
    func dispatchAgents(
        proposals: [CardProposal],
        allSummaries: [JSON]
    ) async -> KCDispatchResult {
        let startTime = Date()
        let cardIds = proposals.map { $0.cardId }

        Logger.info("ðŸš€ Dispatching \(proposals.count) KC agent(s)", category: .ai)

        // Emit dispatch started event
        await eventBus.publish(.kcAgentsDispatchStarted(count: proposals.count, cardIds: cardIds))

        // Get model ID from settings
        let modelId = UserDefaults.standard.string(forKey: "onboardingKCAgentModelId") ?? "anthropic/claude-haiku-4.5"

        // Generate cards with concurrency limit
        var results: [GeneratedCard] = []

        await withTaskGroup(of: (String, GeneratedCard).self) { group in
            var activeCount = 0
            var proposalIndex = 0

            // Add initial batch of tasks up to max concurrent
            while proposalIndex < proposals.count && activeCount < maxConcurrentAgents {
                let proposal = proposals[proposalIndex]
                proposalIndex += 1
                activeCount += 1

                let agentId = UUID().uuidString

                // Create task for this agent
                let task = Task {
                    await self.generateCard(
                        agentId: agentId,
                        proposal: proposal,
                        allSummaries: allSummaries,
                        modelId: modelId
                    )
                }

                // Register task with tracker for cancellation support
                await MainActor.run {
                    tracker.setTask(task, forAgentId: agentId)
                }

                // Add to task group
                group.addTask {
                    let result = await task.value
                    return (agentId, result)
                }
            }

            // Process results and add new tasks as slots become available
            for await (_, result) in group {
                results.append(result)
                activeCount -= 1

                // Add next proposal if available
                if proposalIndex < proposals.count {
                    let proposal = proposals[proposalIndex]
                    proposalIndex += 1
                    activeCount += 1

                    let newAgentId = UUID().uuidString

                    // Create task for this agent
                    let task = Task {
                        await self.generateCard(
                            agentId: newAgentId,
                            proposal: proposal,
                            allSummaries: allSummaries,
                            modelId: modelId
                        )
                    }

                    // Register task with tracker for cancellation support
                    await MainActor.run {
                        tracker.setTask(task, forAgentId: newAgentId)
                    }

                    // Add to task group
                    group.addTask {
                        let result = await task.value
                        return (newAgentId, result)
                    }
                }
            }
        }

        let duration = Date().timeIntervalSince(startTime)
        let successCount = results.filter { $0.success }.count
        let failureCount = results.filter { !$0.success }.count

        Logger.info("âœ… KC dispatch complete: \(successCount) succeeded, \(failureCount) failed (\(String(format: "%.1f", duration))s)", category: .ai)

        // Emit dispatch completed event
        await eventBus.publish(.kcAgentsDispatchCompleted(successCount: successCount, failureCount: failureCount))

        return KCDispatchResult(
            cards: results,
            successCount: successCount,
            failureCount: failureCount,
            totalDuration: duration
        )
    }

    // MARK: - Private: Single Card Generation

    private func generateCard(
        agentId: String,
        proposal: CardProposal,
        allSummaries: [JSON],
        modelId: String
    ) async -> GeneratedCard {
        // Track agent in AgentActivityTracker (without task - task is registered separately)
        _ = await MainActor.run {
            tracker.trackAgent(
                id: agentId,
                type: .knowledgeCard,
                name: proposal.title,
                task: nil as Task<Void, Never>?
            )
        }

        // Emit agent started event
        await eventBus.publish(.kcAgentStarted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))

        // Check for cancellation before starting
        if Task.isCancelled {
            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: "Cancelled by user")
            }
            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))
            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        }

        do {
            // Create isolated tool executor for this agent
            let toolExecutor = SubAgentToolExecutor(artifactRepository: artifactRepository)

            // Build prompts
            let systemPrompt = KCAgentPrompts.systemPrompt(
                cardType: proposal.cardType,
                title: proposal.title
            )
            let initialPrompt = KCAgentPrompts.initialPrompt(
                proposal: proposal,
                allSummaries: allSummaries
            )

            // Create and run agent
            let runner = AgentRunner.forKnowledgeCard(
                agentId: agentId,
                cardTitle: proposal.title,
                systemPrompt: systemPrompt,
                initialPrompt: initialPrompt,
                modelId: modelId,
                toolExecutor: toolExecutor,
                llmFacade: llmFacade,
                eventBus: eventBus,
                tracker: tracker
            )

            let output = try await runner.run()

            // Mark agent as completed
            await MainActor.run {
                tracker.markCompleted(agentId: agentId)
            }

            // Parse result
            if let result = output.result?["result"] {
                // Emit agent completed event
                await eventBus.publish(.kcAgentCompleted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))
                return GeneratedCard.fromAgentOutput(result, cardId: proposal.cardId)
            } else {
                // Emit agent failed event
                let error = "Agent completed but returned no result"
                await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error))
                return GeneratedCard.failed(
                    cardId: proposal.cardId,
                    title: proposal.title,
                    error: error
                )
            }

        } catch is CancellationError {
            // Task was cancelled - check if tracker already marked as killed
            let status = await MainActor.run {
                tracker.getAgent(id: agentId)?.status
            }

            // Only mark as failed if not already killed
            if status != .killed {
                await MainActor.run {
                    tracker.markFailed(agentId: agentId, error: "Cancelled by user")
                }
            }

            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        } catch {
            // Other error
            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: error.localizedDescription)
            }

            // Emit failed event
            await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error.localizedDescription))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: error.localizedDescription
            )
        }
    }
}
