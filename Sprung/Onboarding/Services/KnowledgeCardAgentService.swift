//
//  KnowledgeCardAgentService.swift
//  Sprung
//
//  Service for spawning parallel knowledge card generation agents.
//  Each agent runs in an isolated conversation thread with its own tool executor.
//  Results are collected and returned to the main coordinator for persistence.
//

import Foundation
import SwiftOpenAI
import SwiftyJSON

// MARK: - Card Proposal

/// A chat excerpt to include as source material for a knowledge card
struct ChatExcerptInput: Codable {
    let excerpt: String      // The quoted text from conversation
    let context: String?     // Brief context explaining what it demonstrates

    init(excerpt: String, context: String? = nil) {
        self.excerpt = excerpt
        self.context = context
    }
}

/// Proposal for a knowledge card to be generated by a sub-agent
struct CardProposal: Codable {
    let cardId: String
    let cardType: String // "job" or "skill"
    let title: String
    let timelineEntryId: String?
    let assignedArtifactIds: [String]
    let chatExcerpts: [ChatExcerptInput]
    let notes: String?

    init(
        cardId: String = UUID().uuidString,
        cardType: String,
        title: String,
        timelineEntryId: String? = nil,
        assignedArtifactIds: [String] = [],
        chatExcerpts: [ChatExcerptInput] = [],
        notes: String? = nil
    ) {
        self.cardId = cardId
        self.cardType = cardType
        self.title = title
        self.timelineEntryId = timelineEntryId
        self.assignedArtifactIds = assignedArtifactIds
        self.chatExcerpts = chatExcerpts
        self.notes = notes
    }
}

// MARK: - Generated Card

/// A chat source from the agent output
struct ChatSourceOutput {
    let excerpt: String
    let context: String?
}

/// Result from a KC agent - the generated knowledge card data
/// Supports both structured evidence format (new) and prose format (legacy)
struct GeneratedCard {
    let cardId: String
    let cardType: String
    let title: String
    let prose: String  // Legacy prose format or summary for structured cards
    let sources: [String]  // Artifact IDs
    let chatSources: [ChatSourceOutput]  // Conversation excerpts used
    let highlights: [String]
    let skills: [String]
    let metrics: [String]
    let success: Bool
    let error: String?
    // Optional fields that may be extracted from timeline
    var timePeriod: String?
    var organization: String?
    var location: String?
    // Structured evidence format (new)
    var evidenceBlocks: [EvidenceBlockOutput]?
    var extractedFacts: ExtractedFactsOutput?
    var resumeBullets: [String]?
    var keywords: [String]?
    var evidenceQuality: String?
    /// Token count for this card's content (output tokens from generation)
    var tokenCount: Int?

    /// Evidence block from structured output
    struct EvidenceBlockOutput {
        let sourceDocument: String
        let sourceType: String
        let locations: [String]
        let facts: [String]
        let verbatimQuotes: [String]
    }

    /// Extracted facts from structured output
    struct ExtractedFactsOutput {
        let scope: String?
        let responsibilities: [String]
        let technologies: [String]
        let outcomes: [String]
        let quantified: [String]
        let context: String?
    }

    /// Returns true if this card uses structured evidence format
    var isStructuredFormat: Bool {
        evidenceBlocks != nil && !evidenceBlocks!.isEmpty
    }

    func validationError(minProseChars: Int = 200) -> String? {
        let trimmedTitle = title.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedTitle.isEmpty {
            return "Missing title"
        }

        let trimmedType = cardType.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedType.isEmpty {
            return "Missing card_type"
        }
        let validTypes = ["job", "skill", "education", "project", "achievement", "employment"]
        if !validTypes.contains(trimmedType) {
            return "Invalid card_type '\(trimmedType)'"
        }

        // Structured format validation
        if isStructuredFormat {
            // Require at least one evidence block with facts
            let hasFacts = evidenceBlocks!.contains { !$0.facts.isEmpty }
            if !hasFacts {
                return "No facts in evidence blocks"
            }
            return nil
        }

        // Legacy prose format validation
        let trimmedProse = prose.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedProse.isEmpty {
            return "Missing prose"
        }
        if trimmedProse.count < minProseChars {
            return "Prose too short (\(trimmedProse.count) chars)"
        }

        let hasArtifactSources = sources.contains { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
        let hasChatSources = chatSources.contains { !$0.excerpt.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }
        if !hasArtifactSources && !hasChatSources {
            return "Missing evidence sources (artifact IDs and/or chat_sources)"
        }

        return nil
    }

    /// Convert to JSON format matching submit_knowledge_card schema.
    /// Supports both structured evidence format and legacy prose format.
    func toJSON() -> JSON {
        var json = JSON()

        // Build the card object with submit_knowledge_card schema
        var card = JSON()
        card["id"].string = cardId
        card["title"].string = title
        card["type"].string = cardType

        if isStructuredFormat {
            // Structured format: use evidence blocks
            card["content"].string = prose  // Summary/brief description

            // Evidence blocks
            var blocksArray: [[String: Any]] = []
            for block in evidenceBlocks ?? [] {
                blocksArray.append([
                    "source_document": block.sourceDocument,
                    "source_type": block.sourceType,
                    "locations": block.locations,
                    "facts": block.facts,
                    "verbatim_quotes": block.verbatimQuotes
                ])
            }
            card["evidence_blocks"].arrayObject = blocksArray

            // Extracted facts
            if let facts = extractedFacts {
                var factsDict: [String: Any] = [:]
                if let scope = facts.scope {
                    factsDict["scope"] = scope
                }
                if !facts.responsibilities.isEmpty {
                    factsDict["responsibilities"] = facts.responsibilities
                }
                if !facts.technologies.isEmpty {
                    factsDict["technologies"] = facts.technologies
                }
                if !facts.outcomes.isEmpty {
                    factsDict["outcomes"] = facts.outcomes
                }
                if !facts.quantified.isEmpty {
                    factsDict["quantified"] = facts.quantified
                }
                if let context = facts.context {
                    factsDict["context"] = context
                }
                card["facts"].dictionaryObject = factsDict
            }

            // Resume bullets
            if let bullets = resumeBullets {
                card["resume_bullets"].arrayObject = bullets
            }

            // Keywords
            if let kw = keywords {
                card["keywords"].arrayObject = kw
            }

            // Evidence quality
            if let quality = evidenceQuality {
                card["evidence_quality"].string = quality
            }
        } else {
            // Legacy prose format
            card["content"].string = prose
        }

        // Transform sources from [String] to [{type: "artifact", artifact_id: String}]
        var sourcesArray: [[String: Any]] = []
        for artifactId in sources {
            sourcesArray.append([
                "type": "artifact",
                "artifact_id": artifactId
            ])
        }
        for chatSource in chatSources {
            var chatDict: [String: Any] = [
                "type": "chat",
                "chat_excerpt": chatSource.excerpt
            ]
            if let context = chatSource.context {
                chatDict["chat_context"] = context
            }
            sourcesArray.append(chatDict)
        }
        card["sources"].arrayObject = sourcesArray

        // Add optional fields
        if let timePeriod = timePeriod {
            card["time_period"].string = timePeriod
        }
        if let organization = organization {
            card["organization"].string = organization
        }
        if let location = location {
            card["location"].string = location
        }
        if let tokenCount = tokenCount {
            card["token_count"].int = tokenCount
        }

        json["card"] = card

        // Generate summary from card data
        let achievementCount = isStructuredFormat
            ? (extractedFacts?.quantified.count ?? 0)
            : (highlights.count + metrics.count)
        let summary = "Knowledge card for \(title) with \(achievementCount) key achievements"
        json["summary"].string = summary

        // Include extra data that may be useful (not required by submit_knowledge_card)
        json["highlights"].arrayObject = highlights
        json["skills"].arrayObject = skills
        json["metrics"].arrayObject = metrics

        return json
    }

    /// Create from agent output
    /// Supports both structured evidence format and legacy prose format
    static func fromAgentOutput(_ output: JSON, cardId: String, tokenCount: Int? = nil) -> GeneratedCard {
        // Parse chat sources if provided
        let chatSources = output["chat_sources"].arrayValue.map { json in
            ChatSourceOutput(
                excerpt: json["excerpt"].stringValue,
                context: json["context"].string
            )
        }

        // Check for structured format (evidence_blocks present)
        let evidenceBlocksJSON = output["evidence_blocks"].arrayValue
        var evidenceBlocks: [EvidenceBlockOutput]?
        var extractedFacts: ExtractedFactsOutput?

        if !evidenceBlocksJSON.isEmpty {
            // Parse evidence blocks
            evidenceBlocks = evidenceBlocksJSON.map { blockJSON in
                EvidenceBlockOutput(
                    sourceDocument: blockJSON["source_document"].stringValue,
                    sourceType: blockJSON["source_type"].stringValue,
                    locations: blockJSON["locations"].arrayValue.map { $0.stringValue },
                    facts: blockJSON["extracted_content"]["facts"].arrayValue.map { $0.stringValue },
                    verbatimQuotes: blockJSON["extracted_content"]["verbatim_quotes"].arrayValue.map { $0.stringValue }
                )
            }

            // Parse extracted facts
            let factsJSON = output["facts"]
            if factsJSON.exists() {
                extractedFacts = ExtractedFactsOutput(
                    scope: factsJSON["scope"].string,
                    responsibilities: factsJSON["responsibilities"].arrayValue.map { $0.stringValue },
                    technologies: factsJSON["technologies"].arrayValue.map { $0.stringValue },
                    outcomes: factsJSON["outcomes"].arrayValue.map { $0.stringValue },
                    quantified: factsJSON["quantified"].arrayValue.map { $0.stringValue },
                    context: factsJSON["context"].string
                )
            }
        }

        // Get prose/content (for structured format, this is a summary)
        let prose = output["prose"].string ?? output["content"].string ?? output["summary"].stringValue

        // Get sources - handle both string array and object array formats
        var sources: [String] = []
        for sourceItem in output["sources"].arrayValue {
            if let artifactId = sourceItem.string {
                sources.append(artifactId)
            } else if let artifactId = sourceItem["artifact_id"].string {
                sources.append(artifactId)
            } else if let docId = sourceItem["source_document"].string {
                sources.append(docId)
            }
        }

        return GeneratedCard(
            cardId: cardId,
            cardType: output["card_type"].stringValue,
            title: output["title"].stringValue,
            prose: prose,
            sources: sources,
            chatSources: chatSources,
            highlights: output["highlights"].arrayValue.map { $0.stringValue },
            skills: output["skills"].arrayValue.map { $0.stringValue },
            metrics: output["metrics"].arrayValue.map { $0.stringValue },
            success: true,
            error: nil,
            timePeriod: output["time_period"].string ?? output["date_range"].string,
            organization: output["organization"].string,
            location: output["location"].string,
            evidenceBlocks: evidenceBlocks,
            extractedFacts: extractedFacts,
            resumeBullets: output["resume_bullets"].arrayValue.map { $0.stringValue },
            keywords: output["keywords"].arrayValue.map { $0.stringValue },
            evidenceQuality: output["evidence_quality"].string,
            tokenCount: tokenCount
        )
    }

    /// Create a failed card result
    static func failed(cardId: String, title: String, error: String) -> GeneratedCard {
        GeneratedCard(
            cardId: cardId,
            cardType: "",
            title: title,
            prose: "",
            sources: [],
            chatSources: [],
            highlights: [],
            skills: [],
            metrics: [],
            success: false,
            error: error,
            timePeriod: nil,
            organization: nil,
            location: nil,
            evidenceBlocks: nil,
            extractedFacts: nil,
            resumeBullets: nil,
            keywords: nil,
            evidenceQuality: nil,
            tokenCount: nil
        )
    }
}

// MARK: - Dispatch Result

/// Result from dispatching multiple KC agents
struct KCDispatchResult {
    let cards: [GeneratedCard]
    let successCount: Int
    let failureCount: Int
    let totalDuration: TimeInterval

    var failedCards: [GeneratedCard] {
        cards.filter { !$0.success }
    }

    var successfulCards: [GeneratedCard] {
        cards.filter { $0.success }
    }
}

// MARK: - Knowledge Card Agent Service

/// Service that spawns parallel agents to generate knowledge cards.
/// Each agent runs in an isolated conversation thread.
actor KnowledgeCardAgentService {
    // MARK: - Dependencies

    private let artifactRepository: ArtifactRepository
    private weak var llmFacade: LLMFacade?
    private let tracker: AgentActivityTracker
    private let eventBus: EventCoordinator

    // MARK: - Configuration

    /// Maximum number of concurrent KC agents
    private let maxConcurrentAgents: Int

    // MARK: - Initialization

    init(
        artifactRepository: ArtifactRepository,
        llmFacade: LLMFacade?,
        tracker: AgentActivityTracker,
        eventBus: EventCoordinator,
        maxConcurrentAgents: Int? = nil
    ) {
        self.artifactRepository = artifactRepository
        self.llmFacade = llmFacade
        self.tracker = tracker
        self.eventBus = eventBus
        // Read from UserDefaults, fallback to provided value or default of 5
        let settingsValue = UserDefaults.standard.integer(forKey: "onboardingKCAgentMaxConcurrent")
        self.maxConcurrentAgents = maxConcurrentAgents ?? (settingsValue > 0 ? settingsValue : 5)
        Logger.info("ðŸ¤– KnowledgeCardAgentService initialized (max concurrent: \(self.maxConcurrentAgents))", category: .ai)
    }

    // MARK: - Public API

    /// Dispatch multiple KC agents to generate cards in parallel
    /// - Parameters:
    ///   - proposals: Array of card proposals to generate
    ///   - allSummaries: All artifact summaries for agent reference
    /// - Returns: Results from all agents (successful and failed)
    func dispatchAgents(
        proposals: [CardProposal],
        allSummaries: [JSON]
    ) async -> KCDispatchResult {
        let startTime = Date()
        let cardIds = proposals.map { $0.cardId }

        Logger.info("ðŸš€ Dispatching \(proposals.count) KC agent(s) (max concurrent: \(maxConcurrentAgents))", category: .ai)

        // Emit dispatch started event
        await eventBus.publish(.kcAgentsDispatchStarted(count: proposals.count, cardIds: cardIds))

        // Get model ID from settings
        let modelId = UserDefaults.standard.string(forKey: "onboardingKCAgentModelId") ?? "anthropic/claude-haiku-4.5"

        // Pre-register all agents as pending (so they show in the UI immediately)
        var agentIds: [String] = []
        for proposal in proposals {
            let agentId = UUID().uuidString
            agentIds.append(agentId)
            await MainActor.run {
                _ = tracker.trackAgent(
                    id: agentId,
                    type: .knowledgeCard,
                    name: proposal.title,
                    status: .pending,
                    task: nil as Task<Void, Never>?
                )
            }
        }

        // Generate cards with concurrency limit
        var results: [GeneratedCard] = []

        await withTaskGroup(of: (String, GeneratedCard).self) { group in
            var activeCount = 0
            var proposalIndex = 0

            // Add initial batch of tasks up to max concurrent
            while proposalIndex < proposals.count && activeCount < maxConcurrentAgents {
                let proposal = proposals[proposalIndex]
                let agentId = agentIds[proposalIndex]
                proposalIndex += 1
                activeCount += 1

                // Mark agent as running
                await MainActor.run {
                    tracker.markRunning(agentId: agentId)
                }

                // Create task for this agent
                let task = Task {
                    await self.generateCard(
                        agentId: agentId,
                        proposal: proposal,
                        allSummaries: allSummaries,
                        modelId: modelId
                    )
                }

                // Register task with tracker for cancellation support
                await MainActor.run {
                    tracker.setTask(task, forAgentId: agentId)
                }

                // Add to task group
                group.addTask {
                    let result = await task.value
                    return (agentId, result)
                }
            }

            // Process results and add new tasks as slots become available
            for await (_, result) in group {
                results.append(result)
                activeCount -= 1

                // Add next proposal if available
                if proposalIndex < proposals.count {
                    let proposal = proposals[proposalIndex]
                    let agentId = agentIds[proposalIndex]
                    proposalIndex += 1
                    activeCount += 1

                    // Mark agent as running
                    await MainActor.run {
                        tracker.markRunning(agentId: agentId)
                    }

                    // Create task for this agent
                    let task = Task {
                        await self.generateCard(
                            agentId: agentId,
                            proposal: proposal,
                            allSummaries: allSummaries,
                            modelId: modelId
                        )
                    }

                    // Register task with tracker for cancellation support
                    await MainActor.run {
                        tracker.setTask(task, forAgentId: agentId)
                    }

                    // Add to task group
                    group.addTask {
                        let result = await task.value
                        return (agentId, result)
                    }
                }
            }
        }

        let duration = Date().timeIntervalSince(startTime)
        let successCount = results.filter { $0.success }.count
        let failureCount = results.filter { !$0.success }.count

        Logger.info("âœ… KC dispatch complete: \(successCount) succeeded, \(failureCount) failed (\(String(format: "%.1f", duration))s)", category: .ai)

        // Emit dispatch completed event
        await eventBus.publish(.kcAgentsDispatchCompleted(successCount: successCount, failureCount: failureCount))

        return KCDispatchResult(
            cards: results,
            successCount: successCount,
            failureCount: failureCount,
            totalDuration: duration
        )
    }

    // MARK: - Private: Single Card Generation

    private func generateCard(
        agentId: String,
        proposal: CardProposal,
        allSummaries: [JSON],
        modelId: String
    ) async -> GeneratedCard {
        // Agent is already pre-registered as pending in dispatchAgents() and marked running before this call
        // Emit agent started event
        await eventBus.publish(.kcAgentStarted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))

        // Check for cancellation before starting
        if Task.isCancelled {
            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: "Cancelled by user")
            }
            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))
            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        }

        do {
            // Create isolated tool executor for this agent
            let toolExecutor = SubAgentToolExecutor(artifactRepository: artifactRepository)

            // Build prompts
            let systemPrompt = KCAgentPrompts.systemPrompt(
                cardType: proposal.cardType,
                title: proposal.title
            )
            let initialPrompt = KCAgentPrompts.initialPrompt(
                proposal: proposal,
                allSummaries: allSummaries
            )

            // Create and run agent
            let runner = AgentRunner.forKnowledgeCard(
                agentId: agentId,
                cardTitle: proposal.title,
                systemPrompt: systemPrompt,
                initialPrompt: initialPrompt,
                modelId: modelId,
                toolExecutor: toolExecutor,
                llmFacade: llmFacade,
                eventBus: eventBus,
                tracker: tracker
            )

            let output = try await runner.run()

            // Get token count from tracker (output tokens from generation)
            let tokenCount = await MainActor.run {
                tracker.getAgent(id: agentId)?.outputTokens
            }

            // Parse result
            if let result = output.result?["result"] {
                // Build and store card BEFORE emitting completion event (fixes race condition)
                let generatedCard = GeneratedCard.fromAgentOutput(result, cardId: proposal.cardId, tokenCount: tokenCount)

                if let validationError = generatedCard.validationError() {
                    let error = "KC agent returned invalid output: \(validationError)"
                    await MainActor.run {
                        tracker.markFailed(agentId: agentId, error: error)
                    }
                    await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error))
                    return GeneratedCard.failed(
                        cardId: proposal.cardId,
                        title: proposal.title,
                        error: error
                    )
                }

                await artifactRepository.storePendingCard(generatedCard.toJSON(), id: proposal.cardId)

                // Mark agent as completed only after the card is valid and stored
                await MainActor.run {
                    tracker.markCompleted(agentId: agentId)
                }
                // NOW emit agent completed event (card is already stored)
                await eventBus.publish(.kcAgentCompleted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))
                return generatedCard
            } else {
                // Emit agent failed event
                let error = "Agent completed but returned no result"
                await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error))
                return GeneratedCard.failed(
                    cardId: proposal.cardId,
                    title: proposal.title,
                    error: error
                )
            }

        } catch is CancellationError {
            // Task was cancelled - check if tracker already marked as killed
            let status = await MainActor.run {
                tracker.getAgent(id: agentId)?.status
            }

            // Only mark as failed if not already killed
            if status != .killed {
                await MainActor.run {
                    tracker.markFailed(agentId: agentId, error: "Cancelled by user")
                }
            }

            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        } catch {
            // Extract detailed error message from APIError if available
            let errorMessage: String
            if let apiError = error as? APIError {
                errorMessage = apiError.displayDescription
            } else {
                errorMessage = error.localizedDescription
            }

            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: errorMessage)
            }

            // Emit failed event
            await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: errorMessage))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: errorMessage
            )
        }
    }
}
