//
//  KnowledgeCardAgentService.swift
//  Sprung
//
//  Service for spawning parallel knowledge card generation agents.
//  Each agent runs in an isolated conversation thread with its own tool executor.
//  Results are collected and returned to the main coordinator for persistence.
//

import Foundation
import SwiftOpenAI
import SwiftyJSON

// MARK: - Card Proposal

/// A chat excerpt to include as source material for a knowledge card
struct ChatExcerptInput: Codable {
    let excerpt: String      // The quoted text from conversation
    let context: String?     // Brief context explaining what it demonstrates

    init(excerpt: String, context: String? = nil) {
        self.excerpt = excerpt
        self.context = context
    }
}

/// Proposal for a knowledge card to be generated by a sub-agent
struct CardProposal: Codable {
    let cardId: String
    let cardType: String // "job" or "skill"
    let title: String
    let timelineEntryId: String?
    let assignedArtifactIds: [String]
    let chatExcerpts: [ChatExcerptInput]
    let notes: String?

    init(
        cardId: String = UUID().uuidString,
        cardType: String,
        title: String,
        timelineEntryId: String? = nil,
        assignedArtifactIds: [String] = [],
        chatExcerpts: [ChatExcerptInput] = [],
        notes: String? = nil
    ) {
        self.cardId = cardId
        self.cardType = cardType
        self.title = title
        self.timelineEntryId = timelineEntryId
        self.assignedArtifactIds = assignedArtifactIds
        self.chatExcerpts = chatExcerpts
        self.notes = notes
    }
}

// MARK: - Generated Card

/// Result from a KC agent - the generated knowledge card data
/// Uses fact-based format with structured facts and source attribution
struct GeneratedCard {
    let cardId: String
    let cardType: String
    let title: String
    let sources: [String]  // Artifact IDs
    let success: Bool
    let error: String?
    // Optional fields that may be extracted from timeline
    var timePeriod: String?
    var organization: String?
    var location: String?
    /// Token count for this card's content (output tokens from generation)
    var tokenCount: Int?

    // MARK: - Fact-Based Format Fields

    /// Raw facts array as JSON for storage (fact-based format)
    var factsJSON: String?
    /// Suggested resume bullets (fact-based format)
    var suggestedBullets: [String]?
    /// Technologies and tools mentioned (fact-based format)
    var technologies: [String]?

    /// Returns true if this card uses fact-based format
    var isFactBasedFormat: Bool {
        factsJSON != nil
    }

    func validationError() -> String? {
        let trimmedTitle = title.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedTitle.isEmpty {
            return "Missing title"
        }

        let trimmedType = cardType.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmedType.isEmpty {
            return "Missing card_type"
        }
        let validTypes = ["job", "skill", "education", "project", "achievement", "employment"]
        if !validTypes.contains(trimmedType) {
            return "Invalid card_type '\(trimmedType)'"
        }

        // Fact-based format validation
        if isFactBasedFormat {
            // factsJSON should contain at least one fact
            if let json = factsJSON, json.count < 10 {
                return "Facts JSON is too short - no facts extracted"
            }
            return nil
        }

        // No valid format
        return "Missing facts - card has no extracted content"
    }

    /// Convert to JSON format for storage and persistence
    func toJSON() -> JSON {
        var json = JSON()

        // Build the card object
        var card = JSON()
        card["id"].string = cardId
        card["title"].string = title
        card["type"].string = cardType

        // Fact-based format: store structured data
        if let factsJSON = factsJSON {
            card["facts_json"].string = factsJSON
        }
        if let bullets = suggestedBullets {
            card["suggested_bullets"].arrayObject = bullets
        }
        if let techs = technologies {
            card["technologies"].arrayObject = techs
        }

        // Transform sources to array format
        var sourcesArray: [[String: Any]] = []
        for artifactId in sources {
            sourcesArray.append([
                "type": "artifact",
                "artifact_id": artifactId
            ])
        }
        card["sources"].arrayObject = sourcesArray

        // Add optional fields
        if let timePeriod = timePeriod {
            card["time_period"].string = timePeriod
        }
        if let organization = organization {
            card["organization"].string = organization
        }
        if let location = location {
            card["location"].string = location
        }
        if let tokenCount = tokenCount {
            card["token_count"].int = tokenCount
        }

        json["card"] = card

        // Generate summary from card data
        let factCount = suggestedBullets?.count ?? 0
        let summary = "Knowledge card for \(title) with \(factCount) suggested bullets"
        json["summary"].string = summary

        return json
    }

    /// Create from fact-based agent output
    static func fromAgentOutput(_ output: JSON, cardId: String, tokenCount: Int? = nil) -> GeneratedCard {
        // Get sources from sources_used array
        let sources = output["sources_used"].arrayValue.map { $0.stringValue }

        // Serialize facts array to JSON string for storage
        var factsJSON: String?
        if let factsArray = output["facts"].array, !factsArray.isEmpty {
            if let data = try? JSONSerialization.data(withJSONObject: factsArray.map { $0.object }),
               let jsonString = String(data: data, encoding: .utf8) {
                factsJSON = jsonString
            }
        }

        return GeneratedCard(
            cardId: cardId,
            cardType: output["card_type"].stringValue,
            title: output["title"].stringValue,
            sources: sources,
            success: true,
            error: nil,
            timePeriod: output["date_range"].string,
            organization: output["organization"].string,
            location: output["location"].string,
            tokenCount: tokenCount,
            factsJSON: factsJSON,
            suggestedBullets: output["suggested_bullets"].arrayValue.map { $0.stringValue },
            technologies: output["technologies"].arrayValue.map { $0.stringValue }
        )
    }

    /// Create a failed card result
    static func failed(cardId: String, title: String, error: String) -> GeneratedCard {
        GeneratedCard(
            cardId: cardId,
            cardType: "",
            title: title,
            sources: [],
            success: false,
            error: error,
            timePeriod: nil,
            organization: nil,
            location: nil,
            tokenCount: nil,
            factsJSON: nil,
            suggestedBullets: nil,
            technologies: nil
        )
    }
}

// MARK: - Dispatch Result

/// Result from dispatching multiple KC agents
struct KCDispatchResult {
    let cards: [GeneratedCard]
    let successCount: Int
    let failureCount: Int
    let totalDuration: TimeInterval

    var failedCards: [GeneratedCard] {
        cards.filter { !$0.success }
    }

    var successfulCards: [GeneratedCard] {
        cards.filter { $0.success }
    }
}

// MARK: - Knowledge Card Agent Service

/// Service that spawns parallel agents to generate knowledge cards.
/// Each agent runs in an isolated conversation thread.
actor KnowledgeCardAgentService {
    // MARK: - Dependencies

    private let artifactRepository: ArtifactRepository
    private weak var llmFacade: LLMFacade?
    private let tracker: AgentActivityTracker
    private let eventBus: EventCoordinator

    // MARK: - Configuration

    /// Maximum number of concurrent KC agents
    private let maxConcurrentAgents: Int

    // MARK: - Initialization

    init(
        artifactRepository: ArtifactRepository,
        llmFacade: LLMFacade?,
        tracker: AgentActivityTracker,
        eventBus: EventCoordinator,
        maxConcurrentAgents: Int? = nil
    ) {
        self.artifactRepository = artifactRepository
        self.llmFacade = llmFacade
        self.tracker = tracker
        self.eventBus = eventBus
        // Read from UserDefaults, fallback to provided value or default of 5
        let settingsValue = UserDefaults.standard.integer(forKey: "onboardingKCAgentMaxConcurrent")
        self.maxConcurrentAgents = maxConcurrentAgents ?? (settingsValue > 0 ? settingsValue : 5)
        Logger.info("ðŸ¤– KnowledgeCardAgentService initialized (max concurrent: \(self.maxConcurrentAgents))", category: .ai)
    }

    // MARK: - Public API

    /// Dispatch multiple KC agents to generate cards in parallel
    /// - Parameters:
    ///   - proposals: Array of card proposals to generate
    ///   - allSummaries: All artifact summaries for agent reference
    /// - Returns: Results from all agents (successful and failed)
    func dispatchAgents(
        proposals: [CardProposal],
        allSummaries: [JSON]
    ) async -> KCDispatchResult {
        let startTime = Date()
        let cardIds = proposals.map { $0.cardId }

        Logger.info("ðŸš€ Dispatching \(proposals.count) KC agent(s) (max concurrent: \(maxConcurrentAgents))", category: .ai)

        // Emit dispatch started event
        await eventBus.publish(.kcAgentsDispatchStarted(count: proposals.count, cardIds: cardIds))

        // Get model ID from settings
        let modelId = UserDefaults.standard.string(forKey: "onboardingKCAgentModelId") ?? "anthropic/claude-haiku-4.5"

        // Pre-register all agents as pending (so they show in the UI immediately)
        var agentIds: [String] = []
        for proposal in proposals {
            let agentId = UUID().uuidString
            agentIds.append(agentId)
            await MainActor.run {
                _ = tracker.trackAgent(
                    id: agentId,
                    type: .knowledgeCard,
                    name: proposal.title,
                    status: .pending,
                    task: nil as Task<Void, Never>?
                )
            }
        }

        // Generate cards with concurrency limit
        var results: [GeneratedCard] = []

        await withTaskGroup(of: (String, GeneratedCard).self) { group in
            var activeCount = 0
            var proposalIndex = 0

            // Add initial batch of tasks up to max concurrent
            while proposalIndex < proposals.count && activeCount < maxConcurrentAgents {
                let proposal = proposals[proposalIndex]
                let agentId = agentIds[proposalIndex]
                proposalIndex += 1
                activeCount += 1

                // Mark agent as running
                await MainActor.run {
                    tracker.markRunning(agentId: agentId)
                }

                // Create task for this agent
                let task = Task {
                    await self.generateCard(
                        agentId: agentId,
                        proposal: proposal,
                        allSummaries: allSummaries,
                        modelId: modelId
                    )
                }

                // Register task with tracker for cancellation support
                await MainActor.run {
                    tracker.setTask(task, forAgentId: agentId)
                }

                // Add to task group
                group.addTask {
                    let result = await task.value
                    return (agentId, result)
                }
            }

            // Process results and add new tasks as slots become available
            for await (_, result) in group {
                results.append(result)
                activeCount -= 1

                // Add next proposal if available
                if proposalIndex < proposals.count {
                    let proposal = proposals[proposalIndex]
                    let agentId = agentIds[proposalIndex]
                    proposalIndex += 1
                    activeCount += 1

                    // Mark agent as running
                    await MainActor.run {
                        tracker.markRunning(agentId: agentId)
                    }

                    // Create task for this agent
                    let task = Task {
                        await self.generateCard(
                            agentId: agentId,
                            proposal: proposal,
                            allSummaries: allSummaries,
                            modelId: modelId
                        )
                    }

                    // Register task with tracker for cancellation support
                    await MainActor.run {
                        tracker.setTask(task, forAgentId: agentId)
                    }

                    // Add to task group
                    group.addTask {
                        let result = await task.value
                        return (agentId, result)
                    }
                }
            }
        }

        let duration = Date().timeIntervalSince(startTime)
        let successCount = results.filter { $0.success }.count
        let failureCount = results.filter { !$0.success }.count

        Logger.info("âœ… KC dispatch complete: \(successCount) succeeded, \(failureCount) failed (\(String(format: "%.1f", duration))s)", category: .ai)

        // Emit dispatch completed event
        await eventBus.publish(.kcAgentsDispatchCompleted(successCount: successCount, failureCount: failureCount))

        return KCDispatchResult(
            cards: results,
            successCount: successCount,
            failureCount: failureCount,
            totalDuration: duration
        )
    }

    // MARK: - Private: Single Card Generation

    private func generateCard(
        agentId: String,
        proposal: CardProposal,
        allSummaries: [JSON],
        modelId: String
    ) async -> GeneratedCard {
        // Agent is already pre-registered as pending in dispatchAgents() and marked running before this call
        // Emit agent started event
        await eventBus.publish(.kcAgentStarted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))

        // Check for cancellation before starting
        if Task.isCancelled {
            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: "Cancelled by user")
            }
            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))
            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        }

        do {
            // Create isolated tool executor for this agent
            let toolExecutor = SubAgentToolExecutor(artifactRepository: artifactRepository)

            // Build prompts for fact-based extraction
            let systemPrompt = KCAgentPrompts.systemPrompt(
                cardId: proposal.cardId,
                cardType: proposal.cardType,
                title: proposal.title
            )
            let initialPrompt = KCAgentPrompts.initialPrompt(
                proposal: proposal,
                allArtifacts: allSummaries
            )

            // Create and run agent
            let runner = AgentRunner.forKnowledgeCard(
                agentId: agentId,
                cardTitle: proposal.title,
                systemPrompt: systemPrompt,
                initialPrompt: initialPrompt,
                modelId: modelId,
                toolExecutor: toolExecutor,
                llmFacade: llmFacade,
                eventBus: eventBus,
                tracker: tracker
            )

            let output = try await runner.run()

            // Get token count from tracker (output tokens from generation)
            let tokenCount = await MainActor.run {
                tracker.getAgent(id: agentId)?.outputTokens
            }

            // Parse result
            if let result = output.result?["result"] {
                // Build and store card BEFORE emitting completion event (fixes race condition)
                let generatedCard = GeneratedCard.fromAgentOutput(result, cardId: proposal.cardId, tokenCount: tokenCount)

                if let validationError = generatedCard.validationError() {
                    let error = "KC agent returned invalid output: \(validationError)"
                    await MainActor.run {
                        tracker.markFailed(agentId: agentId, error: error)
                    }
                    await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error))
                    return GeneratedCard.failed(
                        cardId: proposal.cardId,
                        title: proposal.title,
                        error: error
                    )
                }

                await artifactRepository.storePendingCard(generatedCard.toJSON(), id: proposal.cardId)

                // Mark agent as completed only after the card is valid and stored
                await MainActor.run {
                    tracker.markCompleted(agentId: agentId)
                }
                // NOW emit agent completed event (card is already stored)
                await eventBus.publish(.kcAgentCompleted(agentId: agentId, cardId: proposal.cardId, cardTitle: proposal.title))
                return generatedCard
            } else {
                // Emit agent failed event
                let error = "Agent completed but returned no result"
                await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: error))
                return GeneratedCard.failed(
                    cardId: proposal.cardId,
                    title: proposal.title,
                    error: error
                )
            }

        } catch is CancellationError {
            // Task was cancelled - check if tracker already marked as killed
            let status = await MainActor.run {
                tracker.getAgent(id: agentId)?.status
            }

            // Only mark as failed if not already killed
            if status != .killed {
                await MainActor.run {
                    tracker.markFailed(agentId: agentId, error: "Cancelled by user")
                }
            }

            // Emit killed event
            await eventBus.publish(.kcAgentKilled(agentId: agentId, cardId: proposal.cardId))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: "Cancelled by user"
            )
        } catch {
            // Extract detailed error message from APIError if available
            let errorMessage: String
            if let apiError = error as? APIError {
                errorMessage = apiError.displayDescription
            } else {
                errorMessage = error.localizedDescription
            }

            await MainActor.run {
                tracker.markFailed(agentId: agentId, error: errorMessage)
            }

            // Emit failed event
            await eventBus.publish(.kcAgentFailed(agentId: agentId, cardId: proposal.cardId, error: errorMessage))

            return GeneratedCard.failed(
                cardId: proposal.cardId,
                title: proposal.title,
                error: errorMessage
            )
        }
    }
}
