//
//  DocumentSummary.swift
//  Sprung
//
//  Structured summary of a document generated during ingestion.
//  Used to provide lightweight context to the main LLM coordinator
//  without requiring full document text.
//

import Foundation

/// Structured summary of a document for the multi-agent architecture.
/// Generated by Gemini Flash-Lite during document ingestion.
struct DocumentSummary: Codable {
    /// Type of document (resume, performance_review, project_doc, etc.)
    let documentType: String

    /// ~500 word narrative summary of the document content
    let summary: String

    /// Time period covered by the document (e.g., "2019-2023")
    let timePeriod: String?

    /// Companies mentioned in the document
    let companies: [String]

    /// Roles/positions mentioned
    let roles: [String]

    /// Skills identified in the document
    let skills: [String]

    /// Key achievements mentioned
    let achievements: [String]

    /// Hints about what types of knowledge cards this doc could support
    let relevanceHints: String

    /// Generate a compact string representation for LLM context
    func toContextString() -> String {
        var parts: [String] = []

        parts.append("Type: \(documentType)")
        parts.append("Summary: \(summary)")

        if let timePeriod = timePeriod, !timePeriod.isEmpty {
            parts.append("Time Period: \(timePeriod)")
        }

        if !companies.isEmpty {
            parts.append("Companies: \(companies.joined(separator: ", "))")
        }

        if !roles.isEmpty {
            parts.append("Roles: \(roles.joined(separator: ", "))")
        }

        if !skills.isEmpty {
            parts.append("Skills: \(skills.joined(separator: ", "))")
        }

        if !achievements.isEmpty {
            parts.append("Achievements: \(achievements.joined(separator: "; "))")
        }

        if !relevanceHints.isEmpty {
            parts.append("Relevance: \(relevanceHints)")
        }

        return parts.joined(separator: "\n")
    }

    /// Create a fallback summary when parsing fails
    static func fallback(from text: String, filename: String) -> DocumentSummary {
        // Extract a simple summary from the first portion of text
        let truncated = String(text.prefix(1000))
        return DocumentSummary(
            documentType: "other",
            summary: "Document: \(filename). Content preview: \(truncated)...",
            timePeriod: nil,
            companies: [],
            roles: [],
            skills: [],
            achievements: [],
            relevanceHints: "Unable to fully analyze document structure."
        )
    }
}

// MARK: - JSON Conversion

extension DocumentSummary {
    /// Convert to JSON string for storage in artifact record
    func toJSONString() -> String? {
        let encoder = JSONEncoder()
        encoder.keyEncodingStrategy = .convertToSnakeCase
        guard let data = try? encoder.encode(self) else { return nil }
        return String(data: data, encoding: .utf8)
    }

    /// Initialize from JSON string
    static func fromJSONString(_ json: String) -> DocumentSummary? {
        guard let data = json.data(using: .utf8) else { return nil }
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        return try? decoder.decode(DocumentSummary.self, from: data)
    }
}
