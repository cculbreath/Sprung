import Foundation
import SwiftyJSON
/// Domain service for artifact storage and management.
/// Owns all artifact state including timeline cards, knowledge cards, and uploaded documents.
actor ArtifactRepository: OnboardingEventEmitter, ArtifactStorageProtocol {
    // MARK: - Event System
    let eventBus: EventCoordinator
    // MARK: - Artifact Storage
    private var artifacts = OnboardingArtifacts()
    // MARK: - Pending Knowledge Cards (Milestone 7: KC content not in main thread)
    // Cards generated by KC agents, stored locally until submitted
    private var pendingKnowledgeCards: [String: JSON] = [:]
    // MARK: - Synchronous Caches (for SwiftUI)
    nonisolated(unsafe) private(set) var artifactRecordsSync: [JSON] = []
    nonisolated(unsafe) private(set) var applicantProfileSync: JSON?
    nonisolated(unsafe) private(set) var skeletonTimelineSync: JSON?
    nonisolated(unsafe) private(set) var enabledSectionsSync: Set<String> = []
    nonisolated(unsafe) private(set) var knowledgeCardsSync: [JSON] = []
    /// Archived artifacts (from previous sessions, available for reuse)
    nonisolated(unsafe) private(set) var archivedArtifactsSync: [JSON] = []
    // MARK: - Initialization
    init(eventBus: EventCoordinator) {
        self.eventBus = eventBus
        Logger.info("ðŸ“¦ ArtifactRepository initialized", category: .ai)
    }
    /// Get all artifacts snapshot
    func getArtifacts() -> OnboardingArtifacts {
        artifacts
    }
    // MARK: - Core Artifacts
    /// Set applicant profile artifact
    func setApplicantProfile(_ profile: JSON?) async {
        artifacts.applicantProfile = profile
        applicantProfileSync = profile
        Logger.info("ðŸ‘¤ Applicant profile \(profile != nil ? "saved" : "cleared")", category: .ai)
        // Emit event for state coordinator to update objectives
        if profile != nil {
            await emit(.applicantProfileStored(profile!))
        }
    }
    /// Get applicant profile
    func getApplicantProfile() -> JSON? {
        artifacts.applicantProfile
    }
    /// Set skeleton timeline artifact
    func setSkeletonTimeline(_ timeline: JSON?) async {
        artifacts.skeletonTimeline = timeline
        skeletonTimelineSync = timeline
        Logger.info("ðŸ“… Skeleton timeline \(timeline != nil ? "saved" : "cleared")", category: .ai)
        // Emit event for state coordinator to update objectives
        if timeline != nil {
            await emit(.skeletonTimelineStored(timeline!))
        }
    }
    /// Get skeleton timeline
    func getSkeletonTimeline() -> JSON? {
        artifacts.skeletonTimeline
    }
    /// Set enabled sections
    func setEnabledSections(_ sections: Set<String>) async {
        artifacts.enabledSections = sections
        enabledSectionsSync = sections
        Logger.info("ðŸ“‘ Enabled sections updated: \(sections.count) sections", category: .ai)
        // Emit event for state coordinator to update objectives
        await emit(.enabledSectionsUpdated(sections))
    }
    /// Get enabled sections
    func getEnabledSections() -> Set<String> {
        artifacts.enabledSections
    }
    // MARK: - Artifact Records
    /// Set artifact records (bulk restore)
    func setArtifactRecords(_ records: [JSON]) {
        artifacts.artifactRecords = records
        artifactRecordsSync = records
        Logger.info("ðŸ“¦ Artifact records restored: \(records.count)", category: .ai)
    }
    /// Add a new artifact record
    func addArtifactRecord(_ artifact: JSON) {
        artifacts.artifactRecords.append(artifact)
        artifactRecordsSync = artifacts.artifactRecords
        Logger.info("ðŸ“¦ Artifact record added: \(artifact["id"].stringValue)", category: .ai)
    }
    /// Get artifact record by ID or SHA256
    func getArtifactRecord(id: String) -> JSON? {
        artifacts.artifactRecords.first { artifact in
            let artifactId = artifact["id"].stringValue
            let sha256 = artifact["sha256"].stringValue
            return artifactId == id || sha256 == id
        }
    }
    /// Query artifacts by target_phase_objective
    func getArtifactsForPhaseObjective(_ objectiveId: String) -> [JSON] {
        artifacts.artifactRecords.filter { artifact in
            let targetObjectives = artifact["metadata"]["target_phase_objectives"].arrayValue
            return targetObjectives.contains { $0.stringValue == objectiveId }
        }
    }
    /// Idempotent upsert of artifact record by id or sha256
    func upsertArtifactRecord(_ record: JSON) {
        let id = record["id"].string ?? record["sha256"].string ?? UUID().uuidString
        var replaced = false
        for i in artifacts.artifactRecords.indices {
            let existingId = artifacts.artifactRecords[i]["id"].string ?? artifacts.artifactRecords[i]["sha256"].string
            if existingId == id {
                artifacts.artifactRecords[i] = record
                replaced = true
                break
            }
        }
        if !replaced {
            artifacts.artifactRecords.append(record)
        }
        artifactRecordsSync = artifacts.artifactRecords
    }
    /// Update artifact metadata (field-level merge)
    func updateArtifactMetadata(artifactId: String, updates: JSON) async {
        // Find the artifact by ID
        guard let index = artifacts.artifactRecords.firstIndex(where: { record in
            record["id"].string == artifactId
        }) else {
            Logger.warning("âš ï¸ Artifact not found for metadata update: \(artifactId)", category: .ai)
            return
        }
        var artifact = artifacts.artifactRecords[index]
        var metadata = artifact["metadata"].dictionaryValue.isEmpty ? JSON() : artifact["metadata"]
        // Merge updates into metadata (field-level)
        for (key, value) in updates.dictionaryValue {
            metadata[key] = value
        }
        // Update artifact with new metadata
        artifact["metadata"] = metadata
        artifacts.artifactRecords[index] = artifact
        artifactRecordsSync = artifacts.artifactRecords
        Logger.info("âœ… Artifact metadata updated: \(artifactId) (\(updates.dictionaryValue.keys.count) fields)", category: .ai)
        // Emit confirmation event for persistence
        await emit(.artifactMetadataUpdated(artifact: artifact))
    }
    /// List artifact summaries (id, filename, size, content_type, summary)
    /// Used by main coordinator to see all docs at a glance without full text
    func listArtifactSummaries() -> [JSON] {
        artifacts.artifactRecords.map { artifact in
            var summary = JSON()
            summary["id"].string = artifact["id"].string ?? artifact["sha256"].string
            summary["filename"].string = artifact["filename"].string
            summary["size_bytes"].int = artifact["size_bytes"].int
            summary["content_type"].string = artifact["content_type"].string
            // Include the brief description if available (short ~10 word description)
            if let briefDesc = artifact["brief_description"].string, !briefDesc.isEmpty {
                summary["brief_description"].string = briefDesc
            }
            // Include the summary if available (from summarization step)
            if let docSummary = artifact["summary"].string, !docSummary.isEmpty {
                summary["summary"].string = docSummary
            }
            // Include summary_metadata (document_type, time_period, companies, roles, skills, etc.)
            if !artifact["summary_metadata"].dictionaryValue.isEmpty {
                summary["summary_metadata"] = artifact["summary_metadata"]
            }
            // Include metadata for additional context
            if let title = artifact["metadata"]["title"].string, !title.isEmpty {
                summary["title"].string = title
            }
            if let purpose = artifact["metadata"]["purpose"].string, !purpose.isEmpty {
                summary["purpose"].string = purpose
            }
            return summary
        }
    }

    /// Delete an artifact record by ID
    /// Returns the deleted artifact (for notification purposes) or nil if not found
    func deleteArtifactRecord(id: String) -> JSON? {
        guard let index = artifacts.artifactRecords.firstIndex(where: { record in
            record["id"].string == id || record["sha256"].string == id
        }) else {
            Logger.warning("âš ï¸ Artifact not found for deletion: \(id)", category: .ai)
            return nil
        }
        let deleted = artifacts.artifactRecords.remove(at: index)
        artifactRecordsSync = artifacts.artifactRecords
        Logger.info("ðŸ—‘ï¸ Artifact record deleted: \(deleted["filename"].stringValue)", category: .ai)
        return deleted
    }

    /// Update the summary field for an artifact (called after summarization)
    func updateArtifactSummary(artifactId: String, summary: String) async {
        guard let index = artifacts.artifactRecords.firstIndex(where: { record in
            record["id"].string == artifactId
        }) else {
            Logger.warning("âš ï¸ Artifact not found for summary update: \(artifactId)", category: .ai)
            return
        }

        var artifact = artifacts.artifactRecords[index]
        artifact["summary"].string = summary
        artifact["summary_generated_at"].string = ISO8601DateFormatter().string(from: Date())
        artifacts.artifactRecords[index] = artifact
        artifactRecordsSync = artifacts.artifactRecords

        Logger.info("âœ… Artifact summary updated: \(artifactId) (\(summary.count) chars)", category: .ai)
    }

    /// Check if an artifact has a summary
    func hasArtifactSummary(artifactId: String) -> Bool {
        guard let artifact = getArtifactRecord(id: artifactId) else { return false }
        return artifact["summary"].string?.isEmpty == false
    }

    /// Get artifacts that need summarization (have extracted text but no summary)
    func getArtifactsNeedingSummary() -> [JSON] {
        artifacts.artifactRecords.filter { artifact in
            let hasExtractedText = !artifact["extracted_text"].stringValue.isEmpty
            let hasSummary = !artifact["summary"].stringValue.isEmpty
            return hasExtractedText && !hasSummary
        }
    }

    // MARK: - Archived Artifacts Management

    /// Set archived artifacts (loaded from SwiftData)
    /// Called by coordinator to populate the cache on startup
    func setArchivedArtifacts(_ records: [JSON]) {
        archivedArtifactsSync = records
        Logger.info("ðŸ“¦ Archived artifacts loaded: \(records.count)", category: .ai)
    }

    /// Refresh archived artifacts cache
    /// Called after promotion or deletion to update UI
    func refreshArchivedArtifacts(_ records: [JSON]) {
        archivedArtifactsSync = records
        Logger.debug("ðŸ“¦ Archived artifacts refreshed: \(records.count)", category: .ai)
    }

    /// Remove an artifact from the archived cache
    /// Called after promotion (artifact moves to current session)
    func removeFromArchivedCache(id: String) {
        archivedArtifactsSync.removeAll { $0["id"].stringValue == id }
        Logger.debug("ðŸ“¦ Removed from archived cache: \(id)", category: .ai)
    }

    /// Get archived artifacts count (for UI visibility)
    func getArchivedArtifactsCount() -> Int {
        archivedArtifactsSync.count
    }

    // MARK: - Timeline Card Management
    /// Helper to get current timeline cards using TimelineCardAdapter
    private func currentTimelineCards() -> (cards: [TimelineCard], meta: JSON?) {
        let timelineJSON = artifacts.skeletonTimeline ?? JSON()
        return TimelineCardAdapter.cards(from: TimelineCardAdapter.normalizedTimeline(timelineJSON))
    }
    /// Create a new timeline card
    func createTimelineCard(_ card: JSON) async {
        var (cards, meta) = currentTimelineCards()
        // Create new timeline card
        let newCard: TimelineCard
        if let id = card["id"].string {
            newCard = TimelineCard(id: id, fields: card)
        } else {
            newCard = TimelineCard(id: UUID().uuidString, fields: card)
        }
        cards.append(newCard)
        artifacts.skeletonTimeline = TimelineCardAdapter.makeTimelineJSON(cards: cards, meta: meta)
        skeletonTimelineSync = artifacts.skeletonTimeline
        Logger.info("ðŸ“… Timeline card created", category: .ai)
    }
    /// Update an existing timeline card
    func updateTimelineCard(id: String, fields: JSON) async {
        var (cards, meta) = currentTimelineCards()
        guard let idx = cards.firstIndex(where: { $0.id == id }) else {
            Logger.warning("Timeline card \(id) not found for update", category: .ai)
            return
        }
        cards[idx] = cards[idx].applying(fields: fields)
        artifacts.skeletonTimeline = TimelineCardAdapter.makeTimelineJSON(cards: cards, meta: meta)
        skeletonTimelineSync = artifacts.skeletonTimeline
        Logger.info("ðŸ“… Timeline card \(id) updated", category: .ai)
    }
    /// Delete a timeline card
    func deleteTimelineCard(id: String) async {
        var (cards, meta) = currentTimelineCards()
        cards.removeAll { $0.id == id }
        artifacts.skeletonTimeline = TimelineCardAdapter.makeTimelineJSON(cards: cards, meta: meta)
        skeletonTimelineSync = artifacts.skeletonTimeline
        Logger.info("ðŸ“… Timeline card \(id) deleted", category: .ai)
    }
    /// Reorder timeline cards
    func reorderTimelineCards(orderedIds: [String]) async {
        let (cards, meta) = currentTimelineCards()
        let cardMap = Dictionary(uniqueKeysWithValues: cards.map { ($0.id, $0) })
        let reordered = orderedIds.compactMap { cardMap[$0] }
        artifacts.skeletonTimeline = TimelineCardAdapter.makeTimelineJSON(cards: reordered, meta: meta)
        skeletonTimelineSync = artifacts.skeletonTimeline
        Logger.info("ðŸ“… Timeline cards reordered", category: .ai)
    }
    /// Replace entire skeleton timeline (user edit in UI)
    func replaceSkeletonTimeline(_ timeline: JSON, diff: TimelineDiff?) async {
        artifacts.skeletonTimeline = TimelineCardAdapter.normalizedTimeline(timeline)
        skeletonTimelineSync = artifacts.skeletonTimeline
        if let diff = diff {
            Logger.info("ðŸ“… Skeleton timeline replaced by user (\(diff.summary))", category: .ai)
        } else {
            Logger.info("ðŸ“… Skeleton timeline replaced by user", category: .ai)
        }
        // DO NOT emit the event here - this method is called IN RESPONSE to the event
        // The TimelineManagementService already published the event that triggered this
    }
    // MARK: - Experience & Knowledge Cards
    /// Add experience card
    func addExperienceCard(_ card: JSON) async {
        artifacts.experienceCards.append(card)
        Logger.info("ðŸ’¼ Experience card added (total: \(artifacts.experienceCards.count))", category: .ai)
    }
    /// Get all experience cards
    func getExperienceCards() -> [JSON] {
        artifacts.experienceCards
    }
    /// Add knowledge card
    /// NOTE: This method is called IN RESPONSE to .knowledgeCardPersisted events.
    /// Do NOT emit .knowledgeCardPersisted here - that would create an infinite loop!
    func addKnowledgeCard(_ card: JSON) async {
        artifacts.knowledgeCards.append(card)
        knowledgeCardsSync = artifacts.knowledgeCards
        Logger.info("ðŸƒ Knowledge card added (total: \(artifacts.knowledgeCards.count))", category: .ai)
    }
    /// Set knowledge cards (bulk restore)
    func setKnowledgeCards(_ cards: [JSON]) async {
        artifacts.knowledgeCards = cards
        knowledgeCardsSync = cards
        Logger.info("ðŸƒ Knowledge cards loaded (total: \(artifacts.knowledgeCards.count))", category: .ai)
    }
    /// Get all knowledge cards
    func getKnowledgeCards() -> [JSON] {
        artifacts.knowledgeCards
    }

    // MARK: - Card Proposals (Multi-Agent)

    /// Store card proposals from propose_card_assignments tool
    func setCardProposals(_ proposals: JSON) {
        artifacts.cardProposals = proposals
        Logger.info("ðŸ“‹ Card proposals stored (\(proposals.arrayValue.count) proposals)", category: .ai)
    }

    /// Get stored card proposals for dispatch_kc_agents
    func getCardProposals() -> JSON {
        artifacts.cardProposals
    }

    // MARK: - Pending Knowledge Cards (Milestone 7)

    /// Store a generated knowledge card for later submission
    /// Keeps card content out of main PRI thread
    func storePendingCard(_ card: JSON, id: String) {
        pendingKnowledgeCards[id] = card
        Logger.info("ðŸ“¦ Pending KC stored: \(id) (total pending: \(pendingKnowledgeCards.count))", category: .ai)
    }

    /// Retrieve a pending card by ID (for submit_knowledge_card)
    func getPendingCard(id: String) -> JSON? {
        pendingKnowledgeCards[id]
    }

    /// Remove a pending card after submission
    func removePendingCard(id: String) {
        pendingKnowledgeCards.removeValue(forKey: id)
        Logger.debug("ðŸ—‘ï¸ Pending KC removed: \(id) (remaining: \(pendingKnowledgeCards.count))", category: .ai)
    }

    /// Get all pending card IDs
    func getPendingCardIds() -> [String] {
        Array(pendingKnowledgeCards.keys)
    }

    // MARK: - Writing Samples
    /// Add writing sample
    func addWritingSample(_ sample: JSON) async {
        artifacts.writingSamples.append(sample)
        Logger.info("âœï¸ Writing sample added (total: \(artifacts.writingSamples.count))", category: .ai)
    }
    /// Get all writing samples
    func getWritingSamples() -> [JSON] {
        artifacts.writingSamples
    }
    // MARK: - Scratchpad Summary
    /// Build artifact summary for LLM scratchpad
    func scratchpadSummary() -> [String] {
        var lines: [String] = []
        lines.append("applicant_profile_status=\(artifacts.applicantProfile == nil ? "missing" : "stored")")
        lines.append("skeleton_timeline_status=\(artifacts.skeletonTimeline == nil ? "missing" : "stored")")
        if !artifacts.enabledSections.isEmpty {
            lines.append("enabled_sections=\(artifacts.enabledSections.sorted().joined(separator: ", "))")
        } else {
            lines.append("enabled_sections=pending")
        }
        if !artifacts.experienceCards.isEmpty {
            lines.append("experience_cards=\(artifacts.experienceCards.count)")
        }
        if !artifacts.writingSamples.isEmpty {
            lines.append("writing_samples=\(artifacts.writingSamples.count)")
        }
        if !artifacts.artifactRecords.isEmpty {
            let hints = artifacts.artifactRecords
                .compactMap { record -> String? in
                    if let purpose = record["metadata"]["purpose"].string, !purpose.isEmpty {
                        return purpose
                    }
                    if let label = record["metadata"]["title"].string, !label.isEmpty {
                        return label
                    }
                    return record["id"].string
                }
            if !hints.isEmpty {
                let preview = hints.prefix(5).joined(separator: ", ")
                lines.append("artifact_hints=\(preview)")
            }
            lines.append("artifact_count=\(artifacts.artifactRecords.count)")
        }
        return lines
    }
    // MARK: - State Management
    /// Reset all artifacts
    func reset() {
        artifacts = OnboardingArtifacts()
        artifactRecordsSync = []
        applicantProfileSync = nil
        skeletonTimelineSync = nil
        enabledSectionsSync = []
        knowledgeCardsSync = []
        Logger.info("ðŸ”„ ArtifactRepository reset", category: .ai)
    }
}
