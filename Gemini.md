# Gemini.md

This file provides guidance to Gemini when working with code in this repository.

## Project Structure
- This is a **macOS** app, not an iOS app.
- Local clones of dependency repositories are available for code and documentation reference:
  - `~/devlocal/swift-chunked-audio-player` contains `ChunkedAudioPlayer`
  - `~/devlocal/codebase/SwiftOpenAI-ttsfork` contains my customized fork of `SwiftOpenAI`
- **CRITICAL**: `./ClaudeNotes/` contains essential architectural documentation. I will consult these files before starting any LLM-related work.

## Coding Style
- Use Swift's native error handling with `try/catch` and avoid force unwrapping.
- Organize imports alphabetically.
- Follow protocol-oriented programming patterns.
- Document public methods with triple-slash (`///`) comments.
- Use `@available` annotations for version-specific features.
- Prefer async/await over completion handlers where possible.
- Use SwiftData for persistence.
- Log network calls with descriptive emojis for easy debugging.

## Swift Concurrency and Actor Isolation
- **MainActor Usage**: Mark functions with `@MainActor` when they need to access main actor-isolated properties.
- **Actor Isolation**: Remove `@MainActor` from services that don't need UI thread access to avoid compilation conflicts.
- **Swift 6 Compliance**: Use `Task { @MainActor in }` for callback assignments when needed.
- **Async/Await Patterns**: Prefer structured concurrency over completion handlers.
- **Service Communication**: Design services to minimize actor boundary crossings.

## Coding Practices
- **üö´ NEVER include AI attribution in commit messages** - Work anonymously, no "Gemini", "Generated by", or similar attribution.
- Commit code changes regularly, using **detailed commit messages** that explain the purpose and impact.
- For major features or refactoring:
  - Create a new **branch**.
  - Use **multiple commits** where appropriate to document meaningful steps.
- After completing a branch, I will offer to assist with merging it back into `main`.
- **Before editing any code**, I will generate a detailed **implementation plan** and submit it for your feedback.
- For long, multi-part coding sessions, I will convert the plan into a **checklist file** and save and regularly update it as features are completed.
- Build at regular intervals and address compiler errors.
- **LLM Refactoring Specific**: 
  - Start with Phase 1 implementation (LLMService + ResumeReviseService).
  - Test each operation manually through UI before proceeding.
  - Preserve existing functionality during migration.
  - Follow two-stage model filtering patterns.
- In general, I will not implement "fallback" code or backwards compatibility with legacy code unless specifically asked to do so.
- I will not add TODO statements to code. Instead, I will implement what's needed.

## File Management During Refactoring
- **Default to Editing**: When consolidating code, I will prefer editing existing files over creating new ones.
- **Proper File Deletion**: When a file becomes truly obsolete, I will use appropriate deletion tools rather than blanking the content.
- **File Consolidation**: When merging multiple files into one, I will delete the source files after successfully moving their content.
- **Avoid File Blanking**: I will never use the Edit tool to replace entire file content with an empty string - this leaves orphaned empty files.
- **Validation**: After file operations, I will verify that the codebase still compiles and functions correctly.

## API Schema Management
- When modifying Codable structs used for API responses, I will ALWAYS update corresponding JSON schemas.
- I will check for both required and optional fields in schemas.
- When debugging JSON parsing failures, I will first verify the schema matches the struct definition.
- I will use optional fields in structs when the API might not always return a value.

## Systematic Debugging
- I will use the project's Logger utility at `/Sprung/Shared/Utilities/Logger.swift` for all logging.
- I will understand and use the debug level system: "None", "Basic", or "Verbose".
- I will choose appropriate log levels for my code.
- I will use descriptive emoji prefixes for context: üöÄ start, üìä progress, ‚úÖ success, ‚ùå error, üéØ key events.
- For multi-step processes, I will log transitions at the info level for major steps, and the debug level for substeps.
- When the UI doesn't update as expected, I will use `Logger.debug()` for state changes and MainActor verification.

## SwiftUI Best Practices
- When working with sheets, I will prefer keeping parent views visible and using completion handlers over dismiss-then-present patterns.
- I will always add debug logging for view lifecycle events (onAppear, onDisappear) when debugging UI issues.
- I will test sheet presentation flows before assuming the implementation is correct.
- For progress/loading states, I will ensure UI updates happen on MainActor.
- When implementing concurrent operations, I will use progress callbacks that update on MainActor.
- I will maintain separate state for: processing status, results, errors, and UI visibility.
- I will always provide cancellation support for long-running operations.
- I will use completion handlers for coordinating multiple views/sheets.

## Environment
- I am working in a **macOS command-line environment**.
- `coreutils` has been installed; I will use `gcat -A` to visualize whitespace in code files.
- `grep -n` is allowed.
- If I'm unsure whether a feature is working, I will **ask you** for a screenshot, a test run, or UI feedback.

## Separation of Concerns Refactoring
- I will follow the **Refactoring Restraint Principle**: The default assumption should be that existing code structure is adequate unless there is compelling evidence otherwise.
- I will only refactor when I can clearly articulate specific, concrete problems with the current structure.
- I will make the smallest change that solves the actual problem.
- I will not create abstractions for hypothetical future needs.

## Important Reminders
- I will not implement #Preview in any views.
