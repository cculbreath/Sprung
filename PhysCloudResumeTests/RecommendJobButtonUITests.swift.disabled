import XCTest
import SwiftUI
import ViewInspector
@testable import PhysCloudResume

@MainActor
final class RecommendJobButtonUITests: XCTestCase {
    
    private var appState: AppState!
    private var jobAppStore: JobAppStore!
    
    override func setUp() async throws {
        await super.setUp()
        
        // Initialize app state and store
        appState = AppState()
        jobAppStore = JobAppStore()
        
        // Set up test data
        let (resume, jobApps) = createMockTestData()
        
        // Populate job app store
        jobAppStore.jobApps = jobApps
        
        // Set selected job and resume
        if let firstApp = jobApps.first {
            jobAppStore.selectedApp = firstApp
            firstApp.addResume(resume)
            firstApp.selectedRes = resume
        }
        
        print("✅ Test setup complete with \(jobApps.count) jobs and selected resume")
    }
    
    override func tearDown() async throws {
        appState = nil
        jobAppStore = nil
        await super.tearDown()
    }
    
    // Test the button's visual appearance and accessibility
    func testButtonAppearance() throws {
        // Create the button view
        let button = RecommendJobButton()
            .environment(jobAppStore)
            .environment(\.appState, appState)
        
        // Extract the button using ViewInspector
        let buttonView = try button.inspect().button()
        
        // Verify button content
        let hstack = try buttonView.labelView().hStack()
        
        // Check for image
        let image = try hstack.image(0)
        XCTAssertEqual(try image.systemName(), "sparkles.rectangle.stack")
        
        // Check for text
        let text = try hstack.text(1)
        XCTAssertEqual(try text.string(), "Find Best Match")
        
        // Verify accessibility
        let helpText = try button.inspect().view().accessibilityHint()
        XCTAssertEqual(helpText, "Find the best job match based on your qualifications")
        
        // Check button is initially enabled
        let isDisabled = try button.inspect().button().isDisabled()
        XCTAssertFalse(isDisabled)
    }
    
    // Test the button's behavior when tapped
    func testJobRecommendationButton() async throws {
        // First ensure we have the expected test data
        XCTAssertNotNil(jobAppStore.selectedApp)
        XCTAssertNotNil(jobAppStore.selectedApp?.selectedRes)
        XCTAssertGreaterThan(jobAppStore.jobApps.count, 1)
        
        // Set a valid model that works according to our test matrix
        UserDefaults.standard.set("gpt-4.1", forKey: "preferredLLMModel")
        
        // Create an expectation for the async operation
        let expectation = XCTestExpectation(description: "Job recommendation completed")
        
        // Set up a tap handler and capture the result
        var capturedErrorWrapper: ErrorMessageWrapper?
        var capturedRecommendedJobId: UUID?
        
        // Create a button with a custom tap handler for testing
        let button = RecommendJobButton()
            .environment(jobAppStore)
            .environment(\.appState, appState)
        
        // Simulate button tap in a controlled environment
        Task {
            // Store the original selectedApp for comparison
            let originalSelectedApp = jobAppStore.selectedApp
            
            // Create the provider directly (same as button would)
            let provider = JobRecommendationProvider(
                appState: appState,
                jobApps: jobAppStore.jobApps,
                resume: jobAppStore.selectedApp?.selectedRes
            )
            
            do {
                // Make the API call directly
                let (jobId, reason) = try await provider.fetchRecommendation()
                
                // Update state as the button would
                await MainActor.run {
                    // Find and select the recommended job
                    if let recommendedJob = jobAppStore.jobApps.first(where: { $0.id == jobId }) {
                        jobAppStore.selectedApp = recommendedJob
                        appState.recommendedJobId = jobId
                        
                        // Create an error wrapper with success message (as the button would)
                        capturedErrorWrapper = ErrorMessageWrapper(
                            message: "Recommended: \(recommendedJob.jobPosition) at \(recommendedJob.companyName)\n\nReason: \(reason)"
                        )
                    } else {
                        capturedErrorWrapper = ErrorMessageWrapper(message: "Recommended job not found")
                    }
                    
                    // Store for test verification
                    capturedRecommendedJobId = jobId
                }
                
                // Mark the expectation as fulfilled
                expectation.fulfill()
            } catch {
                // Capture error as the button would
                await MainActor.run {
                    capturedErrorWrapper = ErrorMessageWrapper(message: "Error: \(error.localizedDescription)")
                }
                
                print("❌ Job recommendation failed: \(error.localizedDescription)")
                expectation.fulfill()
            }
        }
        
        // Wait for the async task to complete
        await fulfillment(of: [expectation], timeout: 60.0)
        
        // Verify results
        XCTAssertNotNil(capturedErrorWrapper, "Should have received a response message")
        XCTAssertNotNil(capturedRecommendedJobId, "Should have received a recommended job ID")
        
        if let jobId = capturedRecommendedJobId {
            let recommendedJob = jobAppStore.jobApps.first(where: { $0.id == jobId })
            XCTAssertNotNil(recommendedJob, "Recommended job should exist in the job list")
            XCTAssertEqual(jobAppStore.selectedApp?.id, jobId, "Selected job should be updated to recommended job")
            XCTAssertEqual(appState.recommendedJobId, jobId, "App state should track recommended job ID")
            
            // Print diagnostic info about the recommendation
            if let job = recommendedJob {
                print("✅ Recommendation test passed:")
                print("   - Selected job: \(job.companyName) - \(job.jobPosition)")
                print("   - Alert message: \(capturedErrorWrapper?.message ?? "None")")
            }
        }
    }
    
    // Test with no resume selected
    func testRecommendJobWithNoResume() async throws {
        // Create an expectation
        let expectation = XCTestExpectation(description: "Error message shown")
        
        // Remove selected resume
        if let app = jobAppStore.selectedApp {
            app.selectedRes = nil
        }
        
        // Create a button with a custom tap handler for testing
        let button = RecommendJobButton()
            .environment(jobAppStore)
            .environment(\.appState, appState)
        
        // Tap the button
        try button.inspect().button().tap()
        
        // The button should immediately show an error
        let alertBinding = try button.inspect().bindingAlert()
        let alertTitle = try alertBinding.title().text().string()
        let alertMessage = try alertBinding.message().text().string()
        
        XCTAssertEqual(alertTitle, "Recommendation")
        XCTAssertEqual(alertMessage, "Please select a resume first")
        
        expectation.fulfill()
        
        await fulfillment(of: [expectation], timeout: 1.0)
    }
    
    // MARK: - Helper Methods
    
    private func createMockTestData() -> (Resume, [JobApp]) {
        // Create a mock resume
        let resume = Resume(jobApp: nil, enabledSources: [], model: nil)
        resume.textRes = """
        Christopher Culbreath
        PhD in Chemical Physics
        
        EXPERIENCE
        - Senior Optical Engineer at Waymo (2020-Present)
          * Designed and implemented optical metrology systems
          * Led calibration of LiDAR systems for autonomous vehicles
          * Optimized imaging systems for improved performance
          
        - Research Scientist at Stanford University (2016-2020)
          * Developed novel imaging techniques for studying complex materials
          * Published 12 peer-reviewed papers in leading journals
          * Mentored graduate and undergraduate students
          
        EDUCATION
        - PhD in Chemical Physics, Harvard University
        - B.S. in Physics, MIT
        
        SKILLS
        - Optical system design
        - Laser development
        - Python, MATLAB, LabVIEW
        - Data analysis and signal processing
        - Technical leadership
        """
        
        // Create mock job applications with different positions
        let jobPositions = [
            (
                "Senior Optical Engineer",
                "Magic Leap",
                "Sunnyvale, CA",
                """
                We're looking for a Senior Optical Engineer with a PhD to work on developing next-generation augmented reality displays.
                Requirements:
                - PhD in Optics, Physics, or related field
                - 5+ years of experience in optical system design
                - Experience with AR/VR technologies
                - Strong background in waveguides and holographic optical elements
                - Proficiency in optical design software
                """
            ),
            (
                "Systems Development Engineer",
                "Amazon Robotics",
                "Boston, MA",
                """
                The Amazon Robotics, Learning Experience and Technology (LExT) Systems Development Engineer will apply their technical and coding expertise to design, develop, and maintain autonomous robot management systems. They will create innovative tools, consoles, and processes to ensure effective operation of Amazon's robotic fulfillment centers. The role requires development skills in both front-end and back-end systems, working with large-scale distributed systems, and implementing machine learning applications for robotics.
                
                Basic Qualifications:
                - Bachelor's degree in Computer Science, Engineering, or related field
                - 3+ years of experience with software development and engineering
                - Proficiency in Python, Java, or C++
                
                Preferred Qualifications:
                - Master's degree in Computer Science or Engineering
                - Experience with machine learning applications
                - Background in robotics systems
                - Strong problem-solving and analytical skills
                """
            ),
            (
                "Research Scientist",
                "DeepMind",
                "Mountain View, CA",
                """
                Lead research initiatives in artificial intelligence focusing on reinforcement learning and computer vision.
                Requirements:
                - PhD in Computer Science, Mathematics, or related field
                - Strong publication record in top AI conferences
                - Experience with deep reinforcement learning
                - Proficiency in Python and deep learning frameworks
                - Ability to mentor junior researchers
                """
            ),
            (
                "Lead Optical Physicist",
                "Lawrence Livermore National Laboratory",
                "Livermore, CA",
                """
                Work on high-energy laser systems for national security applications.
                Requirements:
                - PhD in Physics, Optical Engineering, or related field
                - 8+ years of experience with high-energy laser systems
                - Experience with optical metrology and diagnostic techniques
                - Strong background in laser-matter interactions
                - Experience with simulation and modeling of optical systems
                """
            )
        ]
        
        var jobApps: [JobApp] = []
        
        for position in jobPositions {
            let jobApp = JobApp(
                jobPosition: position.0,
                jobLocation: position.2,
                companyName: position.1,
                jobDescription: position.3
            )
            jobApp.status = .new
            jobApps.append(jobApp)
        }
        
        return (resume, jobApps)
    }
}

// MARK: - ViewInspector Inspection Extension

extension RecommendJobButton: Inspectable {}
