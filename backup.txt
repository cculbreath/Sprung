import Cocoa
import SwiftUI

class AppDelegate: NSObject, NSApplicationDelegate {

  var settingsWindow: NSWindow?

//  func applicationDidFinishLaunching(_ notification: Notification) {
//    // Set the title of the main window
//    if let window = NSApplication.shared.windows.first {
//      window.title = "Job Applications"
//    }
//
//  }

  @objc func showSettingsWindow() {
    if settingsWindow == nil {
      let settingsView = SettingsView()
      settingsWindow = NSWindow(
        contentRect: NSRect(x: 0, y: 0, width: 400, height: 200),
        styleMask: [.titled, .closable],
        backing: .buffered, defer: false
      )
      settingsWindow?.title = "Settings"
      settingsWindow?.contentView = NSHostingView(rootView: settingsView)
      settingsWindow?.isReleasedWhenClosed = false

      // Center the window on the screen
      settingsWindow?.center()
    }
    settingsWindow?.makeKeyAndOrderFront(nil)
  }
}
    import SwiftUI

    @main
    struct PhysicsCloudResumeApp: App {
      @NSApplicationDelegateAdaptor(AppDelegate.self) var appDelegate

      var body: some Scene {
        Window("Physics Cloud Résumé", id: "myApp") {
          ContentViewLaunch()  // ContentView handles its own JobAppStore initialization
        }
        .modelContainer(for: [JobApp.self, Resume.self, ResRef.self, TreeNode.self, CoverLetter.self, MessageParams.self, CoverRef.self])
//    .windowToolbarStyle(UnifiedWindowToolbarStyle(showsTitle: false))
    .commands {
      CommandGroup(replacing: .appSettings) {
        Button("Settings...") {
          appDelegate.showSettingsWindow()
        }
        .keyboardShortcut(",", modifiers: .command)
      }
    }
  }
}
import Foundation
import PDFKit
import SwiftData
import SwiftUI

@Model class Resume: Identifiable, Hashable {
  @Attribute(.unique) var id: UUID = UUID()  // Explicit id field
  var needToTree: Bool = true
  @Relationship(deleteRule: .cascade) var rootNode: TreeNode?
  var nodes: [TreeNode] = []
  var dateCreated: Date
  weak var jobApp: JobApp?
  @Relationship(inverse: \ResRef.enabledResumes) var enabledSources: [ResRef]
  var createdDateString: String {
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "hh:mm a 'on' MM/dd/yy"
    return dateFormatter.string(from: dateCreated)
  }
  var textRes: String = ""
  var bgDocs: [ResRef] {
    return self.enabledSources.filter { $0.type == SourceType.background }
  }
  var isUpdating: Bool = false
  var pdfData: Data?
  var attentionGrab: Int = 2
  var jsonTxt: String {
    return self.rebuildJSON()
  }
  var hasValidRefsEnabled: Bool {

    let resumeSourceCount = enabledSources.filter { $0.type == .resumeSource }.count
    let jsonSourceCount = enabledSources.filter { $0.type == .jsonSource }.count
    return resumeSourceCount == 1 && jsonSourceCount == 1

  }

  func getUpdatableNodes() -> [[String: String]] {
    if let node = self.rootNode {
      return TreeNode.traverseAndExportNodes(node: node)
    }
    else {return [[:]]}
  }
  var meta: String = "\"format\": \"FRESH@0.6.0\", \"version\": \"0.1.0\""

  // Default initializer
  init?(
    jobApp: JobApp,
    enabledSources: [ResRef]
  ) {
    // Initialize stored properties
    self.id = UUID()
    self.jobApp = jobApp
    self.dateCreated = Date()
    self.enabledSources = enabledSources

    // Create a temporary variable for rootNode
  }
//  func initialize(jsonText: String) {
//    // Use the temporary variable to store the result of buildTree
//    if let jsonData = jsonText.data(using: .utf8) {  // Convert the string to Data using UTF-8 encoding
//      self.rootNode = self.buildTree(from: jsonData, res: self)
//    } else {
//      print("Cannot convert jsonText to Data")
//    }
//  }




  func generateQuery(attentionGrab: Int) -> ResumeApiQuery {
    self.attentionGrab = attentionGrab
    return ResumeApiQuery(resume: self)
  }
  func loadPDF(from fileURL: URL = FileHandler.pdfUrl()) {
    // Load the PDF data asynchronously
    DispatchQueue.global(qos: .background).async { [weak self] in
      do {
        print("Loading from URL \(fileURL.path)")
        let data = try Data(contentsOf: fileURL)

        // Switch back to the main queue to update the UI
        DispatchQueue.main.async { [weak self] in
          self?.pdfData = data
          self?.isUpdating = false
        }
      } catch {
        // Handle the error safely in case the view is not available
        DispatchQueue.main.async { [weak self] in
          print("Failed to load PDF file: \(error.localizedDescription)")
          self?.isUpdating = false
        }
      }
    }
  }
  func displayPDF() -> PDFView? {
    guard let pdfData = pdfData else { return nil }
    let pdfView = PDFView()

    // Create the PDF document on the main queue
    DispatchQueue.main.async {
      if let document = PDFDocument(data: pdfData) {
        pdfView.document = document
        pdfView.autoScales = true
      }
    }

    return pdfView
  }
  @Transient private var exportWorkItem: DispatchWorkItem?

  func debounceExport() {
    print("pdf refresh")
    isUpdating = true
    // Cancel the previous work item if it exists
    exportWorkItem?.cancel()

    // Create a new work item to perform the export
    exportWorkItem = DispatchWorkItem { [weak self] in
      if let jsonString = self?.rebuildJSON() {
        if let jsonFile = FileHandler.saveJSONToFile(jsonString: jsonString) {
          apiGenerateResFromJson(jsonPath: jsonFile) { pdfWebUrl, resumeText in
            if let resumeText = resumeText {
              self?.textRes = resumeText
            }
            if let pdfWebUrl = pdfWebUrl {
              downloadResPDF(from: pdfWebUrl) { pdfFileUrl in
                if let pdfFileUrl = pdfFileUrl {
                  self?.loadPDF(from: pdfFileUrl)
                }
              }
            }
          }
        }
      }
      else {
        print("jsonString problem")
      }
    }


    // Execute the export after a delay of 0.5 seconds (or any delay you want)
    DispatchQueue.main.asyncAfter(
      deadline: .now() + 0.5, execute: self.exportWorkItem!)
  }
}
import Foundation
import OrderedCollections
import SwiftData

extension Resume {

  func buildTree(from jsonData: Data, res: Resume) -> TreeNode {
    let rootNode = TreeNode(
      name: "root",
      value: "",
      status: LeafStatus.isNotLeaf,
      resume: res
    )
    TreeNode.childIndexer = 0
    if needToTree {
      needToTree = false

      do {
        // Use JSONParser for parsing the JSON data with OrderedDictionary support
        var parser = JSONParser(bytes: Array(jsonData))
        let jsonValue = try parser.parse()
        let x = try jsonValue.unwrap()

        // Check if the parsed value is an OrderedDictionary

        if let json = x as? OrderedDictionary<String, Any> {
          if let sectionLabelsDict = json["section-labels"]
            as? OrderedDictionary<String, Any>
          {
            // Handle the case where the value is a nested OrderedDictionary
            print(
              "Found dictionary for key 'section-labels': \(sectionLabelsDict.prettyPrint())"
            )
            print("count: \(sectionLabelsDict.count)")

            let sectionLabels = rootNode.addChild(
              TreeNode(
                name: "Section Labels",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res))
            for (key, myValue) in sectionLabelsDict {
              sectionLabels.addChild(
                TreeNode(
                  name: key,
                  value: myValue as? String ?? "something went wrong",
                  status: LeafStatus.saved,
                  resume: res))
              print("\(key): \(myValue as! String)")

            }
          }
          if let contactDict = json["contact"]
            as? OrderedDictionary<String, Any>
          {
            let contact = rootNode.addChild(
              TreeNode(
                name: "Contact Info",
                value: "",
                status: LeafStatus.isNotLeaf,
                resume: res))

            for (key, myValue) in contactDict {

              switch key {
              case "location":
                let locNode =
                  contact
                  .addChild(
                    (TreeNode(
                      name: key,
                      value: "",
                      status: LeafStatus.isNotLeaf, resume: res
                    ))
                  )
                if let locDict = myValue as? OrderedDictionary<String, Any> {
                  for (myKey, theValue) in locDict {
                    locNode.addChild(
                      TreeNode(
                        name: myKey,
                        value: theValue as? String ?? "",
                        status: LeafStatus.disabled, resume: res
                      ))
                    print(theValue as? String ?? "")
                  }
                } else {
                  print("LOCDict prob")
                }
              default:
                contact.addChild(
                  TreeNode(
                    name: key,
                    value: myValue as? String ?? "",
                    status: LeafStatus.disabled, resume: res))
                print(myValue as? String ?? "")
              }
            }
          } else {
            print("no contact import")
          }
          if let summaryArray = json["summary"] as? [String] {
            let summary = rootNode.addChild(
              TreeNode(
                name: "Summary",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res))
            summary.addChild(
              TreeNode(
                name: "", value: summaryArray[0],
                status: LeafStatus.saved, resume: res))

          }

          // Initialize labels
          if let labelsArray = json["labels"] as? [String] {
            let labels = rootNode.addChild(
              TreeNode(
                name: "Labels", value: "",
                status: LeafStatus.isNotLeaf, resume: res))
            for (index, label) in labelsArray.enumerated() {
              labels.addChild(
                TreeNode(
                  name: "", value: label, status: LeafStatus.saved, resume: res
                ))
            }
          }
          // Initialize skills and expertise
          if let skillsArray = json["skills-and-expertise"] as? [String] {
            let skills = rootNode.addChild(
              TreeNode(
                name: "Skills and Expertise", value: "",
                status: LeafStatus.isNotLeaf, resume: res))
            for (index, skill) in skillsArray.enumerated() {
              skills.addChild(
                TreeNode(
                  name: "", value: skill, status: LeafStatus.saved, resume: res
                ))
            }
          }
          var jobDictArray: [OrderedDictionary<String, Any>] = []
          if let jobArray = json["employment"] as? [Any] {
            let employment = rootNode.addChild(
              TreeNode(
                name: "Employment", value: "",
                status: LeafStatus.isNotLeaf, resume: res))

            for (element) in jobArray {
              if let jobDict = element as? OrderedDictionary<String, Any> {
                jobDictArray.append(jobDict)
                print(jobDict.prettyPrint())
                let jobNode =
                  employment
                  .addChild(
                    TreeNode(
                      name: jobDict["employer"] as! String,
                      value: "",
                      status: LeafStatus.isNotLeaf, resume: res
                    )
                  )
                for (key, val) in jobDict {
                  switch val {
                  case let strValue as String:
                    jobNode.addChild(
                      TreeNode(
                        name: key,
                        value: strValue,
                        status: LeafStatus.disabled, resume: res))
                  case let highlightsArray as [String]:
                    let highlightParent =
                      jobNode
                      .addChild(
                        (TreeNode(
                          name: key,
                          value: "",
                          status: LeafStatus.isNotLeaf, resume: res
                        ))
                      )
                    for myHighlight in highlightsArray {
                      highlightParent.addChild(
                        TreeNode(
                          name: "",
                          value: myHighlight,
                          status: LeafStatus.saved, resume: res

                        ))
                    }

                  default:
                    print("unknown type encountered")

                  }
                }
              }
            }
          } else {
            print("job cast to dict no worky")
          }
          if let educationArray = json["education"] as? [Any] {
            let education = rootNode.addChild(
              TreeNode(
                name: "Education",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res
              )
            )
            for element in educationArray {

              if let schoolDict = element as? OrderedDictionary<String, Any> {
                if let institutionName = schoolDict["institution"]
                  as? String
                {
                  let schoolNode = education.addChild(
                    TreeNode(
                      name: institutionName,
                      value: "",
                      status: LeafStatus.isNotLeaf, resume: res
                    )
                  )
                  for (key, value) in schoolDict {
                    if let stringValue = value as? String {
                      schoolNode.addChild(
                        TreeNode(
                          name: key,
                          value: stringValue,
                          status: LeafStatus.disabled, resume: res
                        )
                      )
                    }
                  }
                }
              }
            }
          } else {
            print("ed prob")
          }
          if let languagesArray = json["languages"] as? [String] {
            let languageNode = rootNode.addChild(
              TreeNode(

                name: "Languages and Frameworks",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res

              ))
            for (index, language) in languagesArray.enumerated() {
              languageNode.addChild(
                TreeNode(
                  name: "",
                  value: language,
                  status: LeafStatus.saved, resume: res
                ))
            }
          }
          if let projectsArray = json["projects-and-hobbies"] as? [Any] {
            let projectNode = rootNode.addChild(
              TreeNode(
                name: "Projects and Hobbies",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res)
            )

            for (element) in projectsArray {
              if let projectDict = element as? OrderedDictionary<String, Any> {
                guard let projectTitle = projectDict["title"] as? String else {
                  print("Skipping project with no title.")
                  continue
                }
                let projectNode = projectNode.addChild(
                  TreeNode(
                    name: projectTitle,
                    value: "",
                    status: LeafStatus.isNotLeaf, resume: res
                  )
                )

                if let examples = projectDict["examples"] as? [Any] {
                  for element in examples {
                    if let example = element as? OrderedDictionary<String, Any>
                    {
                      if let exampleName = example["name"],
                        let exampleDescription = example["description"]
                      {
                        let exampleNode = projectNode.addChild(
                          TreeNode(
                            name: exampleName as? String ?? "nameProb",
                            value: "",
                            status: LeafStatus.isNotLeaf, resume: res)
                        )
                        exampleNode.addChild(
                          TreeNode(
                            name: "Description",
                            value: exampleDescription as? String ?? "descprob",
                            status: LeafStatus.saved, resume: res
                          )
                        )
                      }
                    }
                  }
                } else {
                  print("No examples found for project \(projectTitle).")
                }
              }
            }
          }

          // Move Publications and More Info nodes outside the loop
          if let publicationsArray = json["publications"] as? [Any] {
            let pubsNode = rootNode.addChild(
              TreeNode(
                name: "Publications",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res
              )
            )
            for (element) in publicationsArray {
              if let publication = element as? OrderedDictionary<String, Any> {
                if let journalStr = publication["journal"] as? String,
                  let yearStr = publication["year"] as? String
                {
                  let nameString = "\(journalStr), \(yearStr)"
                  let paperNode = pubsNode.addChild(
                    TreeNode(
                      name: nameString,
                      value: "",
                      status: LeafStatus.isNotLeaf, resume: res
                    )
                  )
                  for (key, val) in publication {
                    switch val {
                    case let strVal as String:
                      paperNode.addChild(
                        TreeNode(
                          name: key,
                          value: strVal,
                          status: LeafStatus.disabled, resume: res
                        )
                      )

                    case let authorArray as [String]:
                      let authorNode = paperNode.addChild(
                        TreeNode(
                          name: "authors",
                          value: "",
                          status: LeafStatus.isNotLeaf, resume: res))
                      for (index, author) in authorArray.enumerated() {
                        authorNode.addChild(
                          TreeNode(
                            name: "",
                            value: author,
                            status: LeafStatus.disabled, resume: res)
                        )
                      }
                    default:
                      print("unknown publication attribute")
                    }
                  }
                } else {
                  print("year or journal can't be read as string")
                }
              }
            }
          }

          if let moreInfoString = json["more-info"] as? String {
            let infoNode = rootNode.addChild(
              TreeNode(
                name: "More Information",
                value: "",
                status: LeafStatus.isNotLeaf, resume: res
              )
            )
            infoNode.addChild(
              TreeNode(
                name: "", value: moreInfoString,
                status: LeafStatus.saved, resume: res))
          }
        }

      } catch { print("some error") }
    } else {
      print("extra run attempted")
    }
    return rootNode
  }

  func rebuildJSON() -> String {
    var jsonString = "{\n"
    let applicant: Applicant = Applicant()
    if let myRootNode = self.rootNode {
      // 1. Add "meta" dynamically
      jsonString += """
        "meta": {
            "format": "FRESH@0.6.0",
            "version": "0.1.0"
        },
        "contact": {
              "name": "\(applicant.name)"
        },
        """
      // 1b. Missing Labels
      if let labelsNode = myRootNode.children?.first(where: {
        $0.name == "Labels"
      }) {
        let labelsArray = labelsNode.children?.sorted(by: {
          $0.myIndex < $1.myIndex
        })
        .compactMap { $0.value as String }
        if let labelsArray = labelsArray, !labelsArray.isEmpty {
          jsonString += """
            "labels": [
            \(labelsArray.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))
            ],
            """
        }
      }
      // 2. Traverse and add section-labels dynamically
      jsonString += """
        "section-labels": {
        """
      if let sectionLabelsNode = myRootNode.children?.first(where: {
        $0.name == "Section Labels"
      }) {
        jsonString +=
          sectionLabelsNode.children?.sorted(by: { $0.myIndex < $1.myIndex })
          .compactMap({ child in
            let value = child.value
            return
              "\"\(child.name)\": \"\(value.replacingOccurrences(of: "\"", with: "\\\""))\""
          }).joined(separator: ",\n") ?? ""
      }
      jsonString += "\n},"

      // 3. Traverse and add contact information dynamically
      if let contactInfoNode = myRootNode.children?.first(where: {
        $0.name == "contact"
      }) {
        jsonString += """
          "contact": {
          """
        jsonString +=
          contactInfoNode.children?.compactMap({ child in
            if child.name == "location" {
              let locationString =
                child.children?.compactMap({ locChild in
                 let value = locChild.value
                  return
                    "\"\(locChild.name)\": \"\(value.replacingOccurrences(of: "\"", with: "\\\""))\""
                }).joined(separator: ",\n") ?? ""
              return "\"\(child.name)\": {\n\(locationString)\n}"
            } else if let value = child.value as? String {
              return
                "\"\(child.name)\": \"\(value.replacingOccurrences(of: "\"", with: "\\\""))\""
            }
            return nil
          }).joined(separator: ",\n") ?? ""
        jsonString += "\n},"
      }

      // 4. Traverse and add summary dynamically
      if let summaryNode = myRootNode.children?.first(where: {
        $0.name == "Summary"
      }) {
        let summaryArray = summaryNode.children?.sorted(by: {
          $0.myIndex < $1.myIndex
        }).compactMap { $0.value as? String }
        if let summaryArray = summaryArray, !summaryArray.isEmpty {
          jsonString += """
            "summary": [
            \(summaryArray.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))
            ],
            """
        }
      }

      // 5. Traverse and add employment dynamically (sorted by myIndex)
      if let employmentNode = myRootNode.children?.first(where: {
        $0.name == "Employment"
      }) {
        jsonString += """
          "employment": [
          """
        let employmentArray =
          employmentNode.children?.sorted(by: { $0.myIndex < $1.myIndex })
          .compactMap {
            jobNode -> String? in
            var jobDict: [String: Any] = [:]
            if !jobNode.name.isEmpty { jobDict["employer"] = jobNode.name }
            for jobDetail in jobNode.children?.sorted(by: {
              $0.myIndex < $1.myIndex
            }) ?? [] {
              if jobDetail.name == "highlights" {
                let highlightsArray = jobDetail.children?.sorted(by: {
                  $0.myIndex < $1.myIndex
                })
                .compactMap { $0.value as? String }
                if let highlightsArray = highlightsArray,
                  !highlightsArray.isEmpty
                {
                  jobDict[jobDetail.name] = highlightsArray
                }
              } else if !jobDetail.name.isEmpty,
                let value = jobDetail.value as? String
              {
                jobDict[jobDetail.name] = value
              }
            }
            if !jobDict.isEmpty {
              let jobJSON = jobDict.map { key, value -> String in
                if let arrayValue = value as? [String] {
                  return
                    "\"\(key)\": [\n\(arrayValue.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))\n]"
                } else if let stringValue = value as? String {
                  return
                    "\"\(key)\": \"\(stringValue.replacingOccurrences(of: "\"", with: "\\\""))\""
                }
                return ""
              }.joined(separator: ",\n")
              return "{\n\(jobJSON)\n}"
            }
            return nil
          }.joined(separator: ",\n") ?? ""
        jsonString += employmentArray
        jsonString += "\n],"
      }

      // 6. Traverse and add education dynamically (sorted by myIndex)
      if let educationNode = myRootNode.children?.first(where: {
        $0.name == "Education"
      }) {
        jsonString += """
          "education": [
          """
        let educationArray =
          educationNode.children?.sorted(by: { $0.myIndex < $1.myIndex })
          .compactMap {
            schoolNode -> String? in
            var schoolDict: [String: Any] = [:]
            if !schoolNode.name.isEmpty {
              schoolDict["institution"] = schoolNode.name
            }
            for schoolDetail in schoolNode.children?.sorted(by: {
              $0.myIndex < $1.myIndex
            }) ?? [] {
              if !schoolDetail.name.isEmpty,
                let value = schoolDetail.value as? String
              {
                schoolDict[schoolDetail.name] = value
              }
            }
            if !schoolDict.isEmpty {
              let schoolJSON = schoolDict.map { key, value -> String in
                return "\"\(key)\": \"\(value as! String)\""
              }.joined(separator: ",\n")
              return "{\n\(schoolJSON)\n}"
            }
            return nil
          }.joined(separator: ",\n") ?? ""
        jsonString += educationArray
        jsonString += "\n],"
      }

      // 7. Traverse and add skills-and-expertise dynamically
      if let skillsNode = myRootNode.children?.first(where: {
        $0.name == "Skills and Expertise"
      }) {
        let skillsArray = skillsNode.children?.sorted(by: {
          $0.myIndex < $1.myIndex
        }).compactMap {
          $0.value as? String
        }
        if let skillsArray = skillsArray, !skillsArray.isEmpty {
          jsonString += """
            "skills-and-expertise": [
            \(skillsArray.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))
            ],
            """
        }
      }

      // 8. Traverse and add languages dynamically
      if let languagesNode = myRootNode.children?.first(where: {
        $0.name == "Languages and Frameworks"
      }) {
        let languagesArray = languagesNode.children?.sorted(by: {
          $0.myIndex < $1.myIndex
        })
        .compactMap { $0.value as? String }
        if let languagesArray = languagesArray, !languagesArray.isEmpty {
          jsonString += """
            "languages": [
            \(languagesArray.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))
            ],
            """
        }
      }

      // 9. Traverse and add projects-and-hobbies dynamically
      if let projectsNode = myRootNode.children?.first(where: {
        $0.name == "Projects and Hobbies"
      }) {
        jsonString += """
          "projects-and-hobbies": [
          """

        let projectsArray =
          projectsNode.children?.sorted(by: { $0.myIndex < $1.myIndex })
          .compactMap { projectNode -> String? in
            var projectString = ""

            // Set the project title
            if !projectNode.name.isEmpty {
              projectString += "\"title\": \"\(projectNode.name)\""
            }

            // Handle examples
            var examplesArray: [String] = []
            for example in projectNode.children?.sorted(by: {
              $0.myIndex < $1.myIndex
            }) ?? [] {
              var exampleString = "{"
              // Extract both "name" and "description" from the node's children
              let exampleName = example.name
              if !exampleName.isEmpty {
                exampleString +=
                  "\"name\": \"\(exampleName.replacingOccurrences(of: "\"", with: "\\\""))\", "
              }
              if let descriptionNode = example.children?.first(where: {
                $0.name.lowercased() == "description"
              }), let description = descriptionNode.value as? String {
                exampleString +=
                  "\"description\": \"\(description.replacingOccurrences(of: "\"", with: "\\\""))\""
              }
              exampleString += "}"
              examplesArray.append(exampleString)
            }

            // Add examples to project
            if !examplesArray.isEmpty {
              projectString +=
                ", \"examples\": [\n" + examplesArray.joined(separator: ",\n")
                + "\n]"
            }

            // Wrap the project in curly braces
            return "{\n\(projectString)\n}"

          }.joined(separator: ",\n") ?? ""

        jsonString += projectsArray
        jsonString += "\n],"
      }
      // 10. Traverse and add publications dynamically
      if let publicationsNode = myRootNode.children?.first(where: {
        $0.name == "Publications"
      }) {
        jsonString += """
          "publications": [
          """
        let publicationsArray =
          publicationsNode.children?.sorted(by: { $0.myIndex < $1.myIndex })
          .compactMap {
            pubNode -> String? in
            var pubDict: [String: Any] = [:]
            if !pubNode.name.isEmpty { pubDict["title"] = pubNode.name }
            for pubDetail in pubNode.children?.sorted(by: {
              $0.myIndex < $1.myIndex
            }) ?? [] {
              if pubDetail.name == "authors" {
                let authorsArray = pubDetail.children?.sorted(by: {
                  $0.myIndex < $1.myIndex
                })
                .compactMap { $0.value as String }
                if let authorsArray = authorsArray, !authorsArray.isEmpty {
                  pubDict[pubDetail.name] = authorsArray
                }
              } else if !pubDetail.name.isEmpty,
                let value = pubDetail.value as? String
              {
                pubDict[pubDetail.name] = value
              }
            }
            if !pubDict.isEmpty {
              let pubJSON = pubDict.map { key, value -> String in
                if let arrayValue = value as? [String] {
                  return
                    "\"\(key)\": [\n\(arrayValue.map { "\"\($0.replacingOccurrences(of: "\"", with: "\\\""))\"" }.joined(separator: ",\n"))\n]"
                } else if let stringValue = value as? String {
                  return
                    "\"\(key)\": \"\(stringValue.replacingOccurrences(of: "\"", with: "\\\""))\""
                }
                return ""
              }.joined(separator: ",\n")
              return "{\n\(pubJSON)\n}"
            }
            return nil
          }.joined(separator: ",\n") ?? ""
        jsonString += publicationsArray
        jsonString += "\n],"
      }

      // 11. Traverse and add more-info dynamically
      if let moreInfoNode = myRootNode.children?.first(where: {
        $0.name == "More Information"
      }) {
        if let moreInfoValue = moreInfoNode.children?.first?.value as? String,
          !moreInfoValue.isEmpty
        {
          jsonString += """
            "more-info": "\(moreInfoValue.replacingOccurrences(of: "\"", with: "\\\""))"
            """
        }
      }

      // 12. Final addition of closing brace
      jsonString += "\n}"
    }

    return jsonString
  }
}

extension OrderedDictionary {
  func prettyPrint() -> String {
    var result = "OrderedDictionary Contents:\n"
    for (index, (key, value)) in self.enumerated() {
      let valueType = type(of: value)
      result +=
        "\(index + 1). Key: '\(key)' -> Value: '\(value)' (Type: \(valueType))\n"
    }
    return result
  }
}
//
//  ResumeUpdateNode.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/2/24.
//
import Foundation

struct ProposedRevisionNode: Codable, Equatable {
  var id: String = ""
  var oldValue: String = ""
  var newValue: String = ""
  var valueChanged: Bool = false
  var why: String = ""
}

struct RevisionsContainer: Codable {
  var revArray: [ProposedRevisionNode]
}

enum PostReviewAction: String, Codable {
  case accepted = "No action required. Revision Accepted."
  case acceptedWithChanges = "No action required. Revision Accepted with reviewer changes."
  case noChange = "No action required. Original value retained as recommended."
  case restored = "No action Required. Revision rejected and original value restored."
  case revise =
    "Action Required: Please update your submission to incorporate the reviewer comments."
  case rewriteNoComment = "Action Required: Revsion rejected without comment, please try again."
  case mandatedChangeNoComment =
    "Action Required: Unchanged submission rejected. Please propose a revised value for this field"
  case mandatedChange =
    "Action Required: Unchanged submission rejected. Please propose a revised value for this field to incorporate reviewer comments"
  case unevaluated = "Unevaluated"

}

@Observable class FeedbackNode {
  var id: String
  var originalValue: String
  var proposedRevision: String = ""
  var actionRequested: PostReviewAction = .unevaluated
  var reviewerComments: String = ""
  init(
    id: String = "",
    originalValue: String = "",
    proposedRevision: String = "",
    actionRequested: PostReviewAction = .unevaluated,
    reviewerComments: String = ""
  ) {
    self.id = id
    self.originalValue = originalValue
    self.proposedRevision = proposedRevision
    self.actionRequested = actionRequested
    self.reviewerComments = reviewerComments
  }

}
extension FeedbackNode: Encodable {
  enum CodingKeys: String, CodingKey {
    case id
    case originalValue
    case proposedRevision
    case actionRequested
    case reviewerComments
  }

  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(originalValue, forKey: .originalValue)
    try container.encode(proposedRevision, forKey: .proposedRevision)
    try container.encode(actionRequested, forKey: .actionRequested)
    try container.encode(reviewerComments, forKey: .reviewerComments)
  }
}
func fbToJson(_ feedbackNodes: [FeedbackNode]) -> String? {
  let encoder = JSONEncoder()
  encoder.outputFormatting = .prettyPrinted // Optional: makes the JSON output more readable
  do {
    let jsonData = try encoder.encode(feedbackNodes)
    if let jsonString = String(data: jsonData, encoding: .utf8) {
      return jsonString
    } else {
      print("Error converting JSON data to String")
      return nil
    }
  } catch {
    print("Error encoding FeedbackNodes to JSON: \(error)")
    return nil
  }
}
//
//  ResumeApplicant.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/25/24.
//

import Foundation

struct Applicant {
  let name: String = "Christopher Culbreath"
  let address: String = "7317 Shadywood Drive"
  let city: String = "Austin"
  let state: String = "Texas"
  let zip: String = "78745"
  let websites: String = "culbreath.net"
  let email: String = "cc@physicscloud.net"
  let phone: String = "(805) 234-0847"
}
import Foundation

class PdfResume {
  static func render(res: Resume) {
    // Step 1: Get the paths for the JSON input, PDF output, and theme
      if !FileHandler.fontsDone {
//      FileHandler.copyFontsToAppSupport()
      FileHandler.fontsDone = true

    }
    let process = Process()

    let jsonPath: URL = FileHandler.jsonUrl()
    let pdfPath: URL = FileHandler.pdfUrl()
    let templatePath: URL = FileHandler.pdfUrl(filename: "rendered-resume.pdf.html")

    // Locate the typewriter theme directory in the bundle
    guard
      let themeDirectory = Bundle.main.url(
        forResource: "typewriter", withExtension: nil, subdirectory: "scripts")

    else {
      print("Theme directory not found")
      return
    }
    process.currentDirectoryURL = themeDirectory
    // Get all files and directories in the theme (this step is optional for listing files)
//    let files = listFilesInThemeDirectory(at: themeDirectory)
    //    print("Theme files: \(files)")  // You can remove this line if you don't need to list files

    // Step 2: Find the HackMyResume utility in the bundle
    guard
      let utilityURL = Bundle.main.url(
        forResource: "HackMyResume", withExtension: nil, subdirectory: "scripts")
    else {
      print("HackMyResume executable not found in the bundle")
      return
    }

    // Step 3: Create a Process to execute the utility
    process.executableURL = utilityURL

    // Step 4: Pass the correct arguments
    process.arguments = [
      "build",
      jsonPath.path,  // Path to the input JSON file
      "to",
      templatePath.path,  // Path to the output PDF file
      "-t", themeDirectory.path,  // Pass the theme directory
      "-p", "none",  // Specify the PDF generator (weasyprint)
      "-d",  // Enable debugging
    ]

    // Step 5: Set up a pipe to capture standard output
    let pipe = Pipe()
    process.standardOutput = pipe

    do {
      // Step 6: Execute the process
      try process.run()

      // Wait until the process is done
      process.waitUntilExit()

      // Step 7: Read and print the output if needed
      let data = pipe.fileHandleForReading.readDataToEndOfFile()
      if let output = String(data: data, encoding: .utf8) {
        print("Output: \(output)")
      }
      htmlToPdf(sourceUrl: templatePath, destUrl: pdfPath)
    } catch {
      print("Error executing the utility: \(error)")
    }
  }

  // Helper function to list files in a directory (optional)
  static func listFilesInThemeDirectory(at directory: URL) -> [URL] {
    let fileManager = FileManager.default
    var urls = [URL]()

    if let enumerator = fileManager.enumerator(at: directory, includingPropertiesForKeys: nil) {
      for case let url as URL in enumerator {
        urls.append(url)
      }
    }

    return urls
  }
  static func htmlToPdf(sourceUrl: URL, destUrl: URL) {
    let process = Process()
    print("html")
    guard
      let utilityURL = Bundle.main.url(
        forResource: "weasyprint", withExtension: nil, subdirectory: "weasy-dist")
    else {
      print("weasyprint executable not found in the bundle")
      return
    }
    process.executableURL = utilityURL
    process.arguments = [
      sourceUrl.path,
      destUrl.path,
    ]

    // Step 5: Set up a pipe to capture standard output
    let pipe = Pipe()
    process.standardOutput = pipe

    do {
      // Step 6: Execute the process
      try process.run()

      // Wait until the process is done
      process.waitUntilExit()

      // Step 7: Read and print the output if needed
      let data = pipe.fileHandleForReading.readDataToEndOfFile()
      if let output = String(data: data, encoding: .utf8) {
        print("Output: \(output)")
      }
    } catch {
      print("Error executing the utility: \(error)")
    }
  }
}
//
//  ResumeApiRefresh.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/7/24.
//



import Foundation

func apiGenerateResFromJson(jsonPath: URL, completion: @escaping (String?, String?) -> Void) {
  // URL of the API endpoint
  guard let url = URL(string: "https://resume.physicscloud.net/build-resume-file") else {
    print("Invalid URL")
    completion(nil, nil)
    return
  }

  // Create a URLRequest
  var request = URLRequest(url: url)
  request.httpMethod = "POST"

  // Set the API key in the headers
  request.addValue("b0b307e1-6eb4-41d9-8c1f-278c254351d3", forHTTPHeaderField: "x-api-key")

  // Prepare the file data to be uploaded
  let boundary = UUID().uuidString
  let fileData = try! Data(contentsOf: jsonPath)

  // Set the Content-Type to multipart/form-data
  request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")

  // Create multipart form body
  var body = Data()
  body.append("--\(boundary)\r\n".data(using: .utf8)!)
  body.append("Content-Disposition: form-data; name=\"resumeFile\"; filename=\"\(jsonPath.lastPathComponent)\"\r\n".data(using: .utf8)!)
  body.append("Content-Type: application/json\r\n\r\n".data(using: .utf8)!)
  body.append(fileData)
  body.append("\r\n".data(using: .utf8)!)
  body.append("--\(boundary)--\r\n".data(using: .utf8)!)

  // Set the body
  request.httpBody = body

  // Create the URLSession and upload the file
  let task = URLSession.shared.dataTask(with: request) { data, response, error in
    if let error = error {
      print("Error: \(error)")
      completion(nil, nil)
      return
    }

    if let response = response as? HTTPURLResponse {
      print("Response status code: \(response.statusCode)")
    }

    guard let data = data else {
      print("No data received")
      completion(nil, nil)
      return
    }

    do {
      if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
        let pdfUrl = json["pdfUrl"] as? String
        let resumeText = json["resumeText"] as? String
        completion(pdfUrl, resumeText)
      } else {
        print("Invalid JSON format")
        completion(nil, nil)
      }
    } catch {
      print("Error parsing JSON: \(error)")
      completion(nil, nil)
    }
  }

  task.resume()
}

func downloadResPDF(from urlString: String, completion: @escaping (URL?) -> Void) {
  guard let url = URL(string: urlString) else {
    print("Invalid URL")
    completion(nil)
    return
  }

  // Create a URLSession data task to download the PDF
  let task = URLSession.shared.downloadTask(with: url) { (tempFileURL, response, error) in
    if let error = error {
      print("Error downloading PDF: \(error)")
      completion(nil)
      return
    }

    guard let tempFileURL = tempFileURL else {
      print("No file URL")
      completion(nil)
      return
    }

    // Move the file to a permanent location
    let fileManager = FileManager.default
    let destinationURL = FileHandler.pdfUrl()

    do {
      // If file exists, remove it first
      if fileManager.fileExists(atPath: destinationURL.path) {
        try fileManager.removeItem(at: destinationURL)
      }

      // Move the file from temp location to permanent destination
      try fileManager.moveItem(at: tempFileURL, to: destinationURL)
      print("File downloaded to: \(destinationURL)")
      completion(destinationURL)
    } catch {
      print("Error saving file: \(error)")
      completion(nil)
    }
  }

  task.resume()
}
//import SwiftUI
//
//struct ContentView: View {
//  var modelContext: ModelContext
//  @State private var jobAppStore: JobAppStore = JobAppStore()
//  @State private var resRefStore: ResRefStore = ResRefStore()
//  @State private var resStore: ResStore = ResStore()
//  @State private var coverRefStore: CoverRefStore = CoverRefStore()
//  @State private var coverLetterStore: CoverLetterStore = CoverLetterStore()
//  @State private var showNewAppSheet: Bool = false
//  @State private var cL : CoverLetter? = nil
//  @AppStorage("scrapingDogApiKey") var scrapingDogApiKey: String = "none"
//
//  @State private var selectedJobApp: JobApp? // Track the selected job application
//
//  var body: some View {
//    NavigationSplitView {
//      List(selection: $selectedJobApp) { // Bind selection to `selectedJobApp`
//        ForEach(Statuses.allCases, id: \.self) { status in
//          let filteredApps = jobAppStore.jobApps.filter { $0.status == status }
//          if !filteredApps.isEmpty {
//            Section(header: Text(status.rawValue)) {
//              ForEach(filteredApps, id: \.self) { selApp in
//                Text(selApp.job_position)
//                  .tag(selApp) // Tag each item for the selection
//                  .contextMenu {
//                    Button(role: .destructive) {
//                      jobAppStore.deleteJobApp(selApp)
//                    } label: {
//                      Label("Delete", systemImage: "trash")
//                    }
//                  }
//              }
//            }
//          }
//        }
//      }
//      .listStyle(.sidebar)
//      .navigationTitle("Job Applications")
//      .safeAreaInset(edge: .bottom) {
//        Button(action: { showNewAppSheet = true }) {
//          Label("Add Application", systemImage: "plus.circle.fill")
//        }
//        .controlSize(.regular)
//        .labelStyle(.titleAndIcon)
//        .padding(.bottom, 10)
//        .background(Color.clear)
//        .frame(maxWidth: .infinity, alignment: .leading)
//        .padding(.leading, 10)
//      }
//    } detail: {
//      VStack(alignment: .leading) {
//        if let selApp = selectedJobApp { // Use the selected job application
//          TabWrapperView()
//            .navigationTitle(selApp.job_position)
//        } else {
//          Text("No Selection")
//            .navigationTitle("Job Details")
//        }
//      }
//      .frame(minWidth: 200, maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
//      .background(
//        VStack {
//          Divider()
//          Spacer()
//        }
//      )
//    }
//    .sheet(isPresented: $showNewAppSheet) {
//      NewAppSheetView(
//        scrapingDogApiKey: scrapingDogApiKey,
//        isPresented: $showNewAppSheet
//      )
//    }
//    .onAppear {
//      resRefStore.initialize(context: modelContext)
//      resStore.initialize(context: modelContext)
//      jobAppStore.initialize(context: modelContext, resStore: resStore)
//      coverRefStore.initialize(context: modelContext)
//      coverLetterStore.initialize(context: modelContext, refStore: coverRefStore)
//    }
//    .environment(jobAppStore).environment(resRefStore).environment(resStore).environment(coverRefStore).environment(coverLetterStore)
//  }
//}
//
//  swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/30/24.
//

import Foundation
import SwiftData

@Observable
final class ResStore {
  var resumes: [Resume] = []

  private var modelContext: ModelContext?
  init() {}
  func initialize(context: ModelContext) {
    self.modelContext = context
    loadResumes()  // Load data from the database when the store is initialized
  }
  private func loadResumes() {
    let descriptor = FetchDescriptor<Resume>()
    do {
      resumes = try modelContext!.fetch(descriptor)
    } catch {
      print("Failed to fetch Resume Refs: \(error)")
    }
  }
  @discardableResult
  func addResume(res: Resume, to jobApp: JobApp) -> Resume {
    resumes.append(res)
    jobApp.addResume(res)
    modelContext!.insert(res)
    saveContext()
    return res
  }

  @discardableResult
  func create(jobApp: JobApp, sources: [ResRef]) -> Resume? {
    if let modelContext = modelContext {
      print("Model context available")
      print("Creating resume for job application: \(jobApp)")

      let resume = Resume(jobApp: jobApp, enabledSources: sources)!
      print("Resume object created")

      if let jsonSource = sources.filter({ $0.type == .jsonSource }).first {
        print("JSON source found: \(jsonSource)")

        // Build the tree and attach it to the resume
        guard let jsonData = jsonSource.content.data(using: .utf8) else {
          print("Error converting JSON content to data")
          return nil
        }

        resume.rootNode = resume.buildTree(from: jsonData, res: resume)
        print("Resume tree built from JSON data")

        // Insert resume into the model context and save
        modelContext.insert(resume)

        do {
          try modelContext.save()
          print("Model context saved after processing JSON data")
        } catch {
          print("Error saving context: \(error)")
          return nil
        }

        print("Resume successfully saved and processed")
        self.addResume(res: resume, to: jobApp)
        print("Resume added to job application")
        return resume
      } else {
        print("No JSON source found")
        return nil
      }
    } else {
      print("Model context not available")
      return nil
    }
  }
  func createDuplicate(originalResume: Resume, context: ModelContext) -> Resume? {
    // Step 1: Create a new Resume instance
    if let jobAppo = originalResume.jobApp {
      guard let newResume = Resume(jobApp: jobAppo, enabledSources: originalResume.enabledSources) else {
        return nil
      }
      TreeNode.childIndexer = 0


      // Step 2: Deep copy the root node and its children
      if let rootNode = originalResume.rootNode {
        let rootNodeCopy = copyTreeNode(node: rootNode, newResume: newResume)
        newResume.rootNode = rootNodeCopy
      }

      // Step 3: Save the new resume to the context
      context.insert(newResume)

      do {
        try context.save()
      } catch {
        print("Failed to save duplicated resume: \(error)")
        return nil
      }

      return newResume
    }
    else {return nil}
  }

  // Recursive function to copy a TreeNode and its children
  func copyTreeNode(node: TreeNode, newResume: Resume) -> TreeNode {
    // Step 1: Create a copy of the current node with the new resume reference
    let copyNode = TreeNode(
      name: node.name,
      value: node.value,
      parent: nil,  // The parent will be set during recursion
      status: node.status,
      resume: newResume
    )

    // Add the copied node to the new resume's nodes array
    newResume.nodes.append(copyNode)

    // Step 2: Recursively copy the children and set the parent-child relationship
    if let children = node.children {
      for child in children {
        let childCopy = copyTreeNode(node: child, newResume: newResume)
        copyNode.addChild(childCopy)  // Attach the child to the copied parent
      }
    }

    // Return the copied node
    return copyNode
  }

  func deleteRes(_ res: Resume) {
    if let index = resumes.firstIndex(of: res) {
      if let rootNode = res.rootNode {
        TreeNode.deleteTreeNode(node: rootNode, context: modelContext!) // Recursively delete rootNode and its children
      }
      if let jobApp = res.jobApp, let parentindex = jobApp.resumes.firstIndex(of: res) {
        jobApp.resumes.remove(at: parentindex)
      }
      resumes.remove(at: index)
      modelContext!.delete(res)
      saveContext()
    }
    else {
      print("no rootnode")
    }
  }
  //Form functionality incomplete
  //    private func populateFormFromObj(_ resRef: JobApp) {
  //        form.populateFormFromObj(jobApp)
  //    }
  //
  //
  //    func editWithForm(_ jobApp:JobApp? = nil) {
  //        let jobAppEditing = jobApp ?? selectedApp
  //        guard let jobAppEditing = jobAppEditing else {
  //            fatalError("No job application available to edit.")
  //        }
  //        self.populateFormFromObj(jobAppEditing)
  //    }
  //    func cancelFormEdit(_ jobApp:JobApp? = nil) {
  //        let jobAppEditing = jobApp ?? selectedApp
  //        guard let jobAppEditing = jobAppEditing else {
  //            fatalError("No job application available to restore state.")
  //        }
  //        self.populateFormFromObj(jobAppEditing)
  //    }
  //
  //    func saveForm(_ jobApp:JobApp? = nil) {
  //        let jobAppToSave = jobApp ?? selectedApp
  //        guard let jobAppToSave = jobAppToSave else {
  //            fatalError("No job application available to save.")
  //        }
  //        jobAppToSave.assignPropsFromForm(form)
  //        saveContext()
  //
  //    }

  // Save changes to the database
  private func saveContext() {
    do {
      try modelContext!.save()
    } catch {
      print("Failed to save context: \(error)")
    }
  }
}
import SwiftData

@Observable final class JobAppStore {
  var jobApps: [JobApp] = []
  var selectedApp: JobApp?
  var form = JobAppForm()
  var resStore: ResStore?

  private var modelContext: ModelContext?
  init() {

  }
  func initialize(context: ModelContext, resStore: ResStore) {
    modelContext = context
    self.resStore = resStore
    loadJobApps()  // Load data from the database when the store is initialized
  }

  // Load JobApps from the database

  private func loadJobApps() {
    let descriptor = FetchDescriptor<JobApp>()
    do {
      jobApps = try modelContext!.fetch(descriptor)
    } catch {
      print("Failed to fetch JobApps: \(error)")
    }
  }
  // Methods to manage jobApps
  func updateJobAppStatus(_ jobApp: JobApp, to newStatus: Statuses) {
    jobApp.status = newStatus
//    saveContext()
    // Handle additional logic like saving or notifying listeners
  }
  func addJobApp(_ jobApp: JobApp) -> JobApp? {
    jobApps.append(jobApp)
    modelContext!.insert(jobApp)
//    saveContext()
    return jobApps.last
  }
  func deleteSelected() {
    guard let deleteMe = selectedApp else {
      fatalError("No job application available to delete.")
    }

    self.deleteJobApp(deleteMe)
    selectedApp = self.jobApps.last  //!FixMe Problematic?
  }
  func deleteJobApp(_ jobApp: JobApp) {

    if let index = jobApps.firstIndex(of: jobApp) {
      if let resStore = resStore {
        jobApp.resumes.forEach { resume in
          resStore.deleteRes(resume)
        }
        jobApps.remove(at: index)
        modelContext!.delete(jobApp)
//        saveContext()  //Error thrown here}
        if self.selectedApp == jobApp {
          self.selectedApp = nil
        }
        if self.selectedApp == nil {
          self.selectedApp = self.jobApps.first
        }
      } else {
        print("ResStore ref not here!")
      }
    }

  }
  private func populateFormFromObj(_ jobApp: JobApp) {
    form.populateFormFromObj(jobApp)
  }

  func editWithForm(_ jobApp: JobApp? = nil) {
    let jobAppEditing = jobApp ?? selectedApp
    guard let jobAppEditing = jobAppEditing else {
      fatalError("No job application available to edit.")
    }
    self.populateFormFromObj(jobAppEditing)
  }
  func cancelFormEdit(_ jobApp: JobApp? = nil) {
    let jobAppEditing = jobApp ?? selectedApp
    guard let jobAppEditing = jobAppEditing else {
      fatalError("No job application available to restore state.")
    }
    self.populateFormFromObj(jobAppEditing)
  }

  func saveForm(_ jobApp: JobApp? = nil) {
    let jobAppToSave = jobApp ?? selectedApp
    guard let jobAppToSave = jobAppToSave else {
      fatalError("No job application available to save.")
    }
    jobAppToSave.assignPropsFromForm(form)
//    saveContext()

  }

  // Save changes to the database
  private func saveContext() {
    print("don't call this manually!")
    do {
      try modelContext!.save()
      print("saved")
    } catch {
      print("Failed to save context: \(error)")
    }
  }
}
//
//  FileManager.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/5/24.
//

import Foundation

class FileHandler {
  static var fontsDone: Bool = true
  init() {
    if !FileHandler.fontsDone {
//      FileHandler.copyFontsToAppSupport()
      FileHandler.fontsDone = true

    }
  }
  // Static file manager and application support directory
  static let fileManager = FileManager.default

  static let appSupportDirectory: URL = {
    // Ensure the Application Support directory exists
    let appSupportDirectory = fileManager.urls(
      for: .applicationSupportDirectory, in: .userDomainMask
    ).first!
    do {
      try fileManager.createDirectory(
        at: appSupportDirectory, withIntermediateDirectories: true, attributes: nil)
    } catch {
      print("Error creating Application Support directory: \(error)")
    }
    return appSupportDirectory
  }()

  static func readJsonUrl(filename: String = "resume-data.json") -> URL? {
    let path = appSupportDirectory.appendingPathComponent(filename)
    if FileManager.default.fileExists(atPath: path.path)
    {
      return path
    } else {
      return nil
    }
  }
  static func jsonUrl(filename: String = "resume-data.json") -> URL {
    return appSupportDirectory.appendingPathComponent(filename)
  }

  static func readPdfUrl(filename: String = "rendered-resume.pdf") -> URL? {
    let path = appSupportDirectory.appendingPathComponent(filename)
    if FileManager.default.fileExists(atPath: path.path)
    {
      return path
    } else {
      return nil
    }
  }
  static func pdfUrl(filename: String = "rendered-resume.pdf") -> URL {
    return appSupportDirectory.appendingPathComponent(filename)
  }
  // Function to save JSON to Application Support
  static func saveJSONToFile(jsonString: String)->URL? {
    let fileURL = FileHandler.jsonUrl()
    do {
      if let jsonData = jsonString.data(using: .utf8) {
        try jsonData.write(to: fileURL)
        print("JSON file saved successfully at \(fileURL.path)")
        return fileURL

      }
    } catch {
      print("Error saving JSON file: \(error)")
    }
    return nil
  }


//  static func copyFontsToAppSupport() {
//    let fileManager = FileManager.default
//
//    // Get the app support directory
//    if let appSupportDirectory = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
//      let destinationURL = appSupportDirectory.appendingPathComponent("_fonts")
//
//      // Create the Application Support subdirectory if it doesn't exist
////      do {
////        try fileManager.createDirectory(at: destinationURL, withIntermediateDirectories: true, attributes: nil)
////      } catch {
////        print("Failed to create directory in Application Support: \(error)")
////        return
////      }
//
//      // Get the folder URL from the bundle
//      if let bundleFolderURL = Bundle.main.url(forResource: "cooper", withExtension: "otf", subdirectory: "scripts") {
//        do {
//          // Copy all contents of the folder from the bundle to Application Support
//          let folderContents = try fileManager.contentsOfDirectory(at: bundleFolderURL, includingPropertiesForKeys: nil)
//          for file in folderContents {
//            let destinationFileURL = destinationURL.appendingPathComponent(file.lastPathComponent)
//
//            // Check if file already exists in
//              try fileManager.copyItem(at: bundleFolderURL, to: appSupportDirectory)
//              print("Copied \(file.lastPathComponent) to Application Support")
//
//          }
//        } catch {
//          print("Failed to copy folder contents: \(error)")
//        }
//      } else {
//        print("Could not locate folder in bundle: scripts/_fonts")
//      }
//    } else {
//      print("Could not locate Application Support directory")
//    }
//  }
}
import SwiftData
import Foundation

@Observable
final class CoverRefStore {
  var storedCoverRefs: [CoverRef] = []
  private var modelContext: ModelContext?

  var defaultSources: [CoverRef] {
    return storedCoverRefs.filter { $0.enabledByDefault == true }
  }

  init() {}

  func initialize(context: ModelContext) {
    self.modelContext = context
    loadCoverRefs()  // Load data from the database when the store is initialized
  }
  var backgroundFacts: [CoverRef] {
    return storedCoverRefs.filter { $0.type == .backgroundFact }
  }

  var writingSamples: [CoverRef] {
    return storedCoverRefs.filter { $0.type == .writingSample }
  }

  private func loadCoverRefs() {
    let descriptor = FetchDescriptor<CoverRef>()
    do {
      storedCoverRefs = try modelContext!.fetch(descriptor)
    } catch {
      print("Failed to fetch Cover Refs: \(error)")
    }
  }

  @discardableResult
  func addCoverRef(_ coverRef: CoverRef) -> CoverRef {
    storedCoverRefs.append(coverRef)
    modelContext?.insert(coverRef)
    saveContext()
    return coverRef
  }

  func deleteCoverRef(_ coverRef: CoverRef) {
    if let index = storedCoverRefs.firstIndex(of: coverRef) {
      storedCoverRefs.remove(at: index)
      modelContext?.delete(coverRef)
      saveContext()
    }
  }

  private func saveContext() {
    do {
      try modelContext?.save()
    } catch {
      print("Failed to save context: \(error)")
    }
  }
}

//
//  swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/30/24.
//

import Foundation
import SwiftData

@Observable
final class CoverLetterStore {
  var coverRefStore: CoverRefStore?
  var cL: CoverLetter?
  private var modelContext: ModelContext?
  init() {}
  func initialize(context: ModelContext, refStore: CoverRefStore) {
    self.modelContext = context
    self.coverRefStore = refStore
    print("CoverLetterStore Initialized")
  }
  @discardableResult
  func addLetter(letter: CoverLetter, to jobApp: JobApp) -> CoverLetter {
    jobApp.coverLetters.append(letter)
    jobApp.selectedCover = letter
    modelContext!.insert(letter)
//    saveContext()
    return letter
  }

  @discardableResult
  func create(jobApp: JobApp) -> CoverLetter {

      print("Model context available")
      print("Creating cover letter for job application: \(jobApp)")

      let letter = CoverLetter(
        enabledRefs: self.coverRefStore!.defaultSources,
        jobApp: jobApp
      )
      print("CoverLetter object created")

      modelContext!.insert(letter)
//      try? modelContext!.save()
      return letter

  }
  func createDuplicate(letter: CoverLetter) -> CoverLetter {
    self.saveContext()
    let newLetter = CoverLetter(
      enabledRefs: letter.enabledRefs,
      jobApp: letter.jobApp ?? nil
    )
    newLetter.includeResumeRefs = letter.includeResumeRefs
    newLetter.content = letter.content
    newLetter.generated = false
    newLetter.encodedMessageHistory = letter.encodedMessageHistory
    newLetter.currentMode = letter.currentMode
    // Copy other necessary properties here

    if let jobApp = letter.jobApp {
      self.addLetter(letter: newLetter, to: jobApp)
    }
    self.saveContext()
    return newLetter
  }
  func deleteLetter(_ letter: CoverLetter) {
    if let jobApp = letter.jobApp {
      if let index = jobApp.coverLetters.firstIndex(of: letter){
        jobApp.coverLetters.remove(at: index)
        modelContext!.delete(letter)
        //      saveContext()
      }
    }
    else {
      print("letter not attached to jobapp!")
    }


  }
 
  // Save changes to the database
  private func saveContext() {
    do {
      try modelContext!.save()
    } catch {
      print("Failed to save context: \(error)")
    }
  }
}
//
//  swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/30/24.
//

import SwiftData

@Observable
final class ResRefStore {
  var resRefs: [ResRef] = []
  private var modelContext: ModelContext?
  var defaultSources: [ResRef] {
    return resRefs.filter { $0.enabledByDefault == true }
  }
  init() {}
  func initialize(context: ModelContext) {
    self.modelContext = context
    loadResRefs()  // Load data from the database when the store is initialized
  }
  private func loadResRefs() {
    let descriptor = FetchDescriptor<ResRef>()
    do {
      resRefs = try modelContext!.fetch(descriptor)
    } catch {
      print("Failed to fetch Resume Refs: \(error)")
    }
  }

  @discardableResult
  func addResRef(_ resRef: ResRef, res: Resume?) -> ResRef {

    resRefs.append(resRef)
    modelContext!.insert(resRef)
    saveContext()
    if let resume = res {
      resume.enabledSources.append(resRef)
    }
    return resRef
  }

  func deleteResRef(_ resRef: ResRef) {
    if let index = resRefs.firstIndex(of: resRef) {
      resRefs.remove(at: index)
      
      modelContext!.delete(resRef)
      saveContext()
    }
  }
  var areRefsOk: Bool {
    return resRefs.contains { $0.type == .resumeSource && $0.enabledByDefault } &&
    resRefs.contains { $0.type == .jsonSource && $0.enabledByDefault }
  }
  //Form functionality incomplete
  //    private func populateFormFromObj(_ resRef: JobApp) {
  //        form.populateFormFromObj(jobApp)
  //    }
  //
  //
  //    func editWithForm(_ jobApp:JobApp? = nil) {
  //        let jobAppEditing = jobApp ?? selectedApp
  //        guard let jobAppEditing = jobAppEditing else {
  //            fatalError("No job application available to edit.")
  //        }
  //        self.populateFormFromObj(jobAppEditing)
  //    }
  //    func cancelFormEdit(_ jobApp:JobApp? = nil) {
  //        let jobAppEditing = jobApp ?? selectedApp
  //        guard let jobAppEditing = jobAppEditing else {
  //            fatalError("No job application available to restore state.")
  //        }
  //        self.populateFormFromObj(jobAppEditing)
  //    }
  //
  //    func saveForm(_ jobApp:JobApp? = nil) {
  //        let jobAppToSave = jobApp ?? selectedApp
  //        guard let jobAppToSave = jobAppToSave else {
  //            fatalError("No job application available to save.")
  //        }
  //        jobAppToSave.assignPropsFromForm(form)
  //        saveContext()
  //
  //    }

  // Save changes to the database
  private func saveContext() {
    do {
      try modelContext!.save()
    } catch {
      print("Failed to save context: \(error)")
    }
  }
}
//
//  ResRef.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/15/24.
//

import Foundation
import SwiftData

enum SourceType: String, CaseIterable, Identifiable, Decodable {
  case background = "Background Resource"
  case resumeSource = "Model Resume"
  case jsonSource = "Model JSON"
  
  var id: String { self.rawValue }
}

@Model
class ResRef: Identifiable {
  var id: String
  var content: String
  var name: String
  var enabledByDefault: Bool
  private var typeRawValue: String
  var enabledResumes: [Resume] = []
  var type: SourceType {
    get {
      return SourceType(rawValue: typeRawValue) ?? .background
    }
    set {
      typeRawValue = newValue.rawValue
    }
  }

  // Custom Decodable initializer

  // CodingKeys enum

  // Initializer for custom creation
  init(
    name: String = "", content: String = "", type: SourceType = SourceType.background,
    enabledByDefault: Bool = false
  ) {
    self.id = UUID().uuidString
    self.content = content
    self.name = name
    self.typeRawValue = type.rawValue
    self.enabledByDefault = enabledByDefault
  }
}
import Foundation
import SwiftData

enum CoverRefType: String, Codable {
  case writingSample = "writingSample"
  case backgroundFact = "backgroundFact"
}

@Model
class CoverRef: Identifiable, Codable {
  var id: String
  var content: String
  var name: String
  var enabledByDefault: Bool
  var type: CoverRefType

  init(
    name: String = "", content: String = "",
    enabledByDefault: Bool = false,  type: CoverRefType
  ) {
    self.id = UUID().uuidString
    self.content = content
    self.name = name
    self.enabledByDefault = enabledByDefault
    self.type = type
  }

  // Manual Codable implementation
  enum CodingKeys: String, CodingKey {
    case id
    case content
    case name
    case enabledByDefault
    case type
  }

  // Required initializer for Decodable
  required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    id = try container.decode(String.self, forKey: .id)
    content = try container.decode(String.self, forKey: .content)
    name = try container.decode(String.self, forKey: .name)
    enabledByDefault = try container.decode(Bool.self, forKey: .enabledByDefault)
    type = try container.decode(CoverRefType.self, forKey: .type)
  }

  // Required function for Encodable
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(content, forKey: .content)
    try container.encode(name, forKey: .name)
    try container.encode(enabledByDefault, forKey: .enabledByDefault)
    try container.encode(type, forKey: .type)
  }
}
import Foundation

extension JobApp {
  static func parseBrightDataJobApp(jobAppStore: JobAppStore, jsonData: Data) -> JobApp? {
    if let jsonArray = (try? JSONSerialization.jsonObject(with: jsonData, options: [])) as? [[String: Any]],
       let jsonDict = jsonArray.first {

      // Create a new JobApp instance
      let jobApp = JobApp()

      // Manually assign attributes
      jobApp.job_position = jsonDict["job_title"] as? String ?? ""
      jobApp.job_location = jsonDict["job_location"] as? String ?? ""
      jobApp.company_name = jsonDict["company_name"] as? String ?? ""
      jobApp.company_linkedin_id = jsonDict["company_id"] as? String ?? ""
      jobApp.job_posting_time = jsonDict["job_posted_time"] as? String ?? ""
      jobApp.job_description = jsonDict["job_summary"] as? String ?? ""
      jobApp.seniority_level = jsonDict["job_seniority_level"] as? String ?? ""
      jobApp.employment_type = jsonDict["job_employment_type"] as? String ?? ""
      jobApp.job_function = jsonDict["job_function"] as? String ?? ""
      jobApp.industries = jsonDict["job_industries"] as? String ?? ""
      jobApp.job_apply_link = jsonDict["apply_link"] as? String ?? ""
      jobApp.posting_url = jsonDict["url"] as? String ?? ""

      // Handle any additional properties or default values
      jobApp.status = .new // or assign based on logic

      // Add jobApp to the store
      jobAppStore.selectedApp = jobAppStore.addJobApp(jobApp)

      return jobApp
    } else {
      print("Failed to parse JSON or JSON structure is unexpected")
      return nil
    }
  }
}
import Foundation
import SwiftData
import SwiftUI

enum Statuses: String, Codable, CaseIterable {
  case new = "New"
  case inProgress = "In Progress"
  case unsubmitted = "Unsubmitted"
  case submitted = "Submitted"
  case interview = "Interview Pending"
  case closed = "Closed"
  case followUp = "Follow up Required"
  case abandonned = "Abandonned"
}

@Model class JobApp: Equatable, Identifiable, Decodable, Hashable {
  @Attribute(.unique) var id: UUID = UUID()

  static func == (lhs: JobApp, rhs: JobApp) -> Bool {
    lhs.id == rhs.id
  }

  func hash(into hasher: inout Hasher) {
    hasher.combine(id)
  }

  @Relationship(deleteRule: .cascade, inverse: \Resume.jobApp)
  var resumes: [Resume] = []

  @Relationship(deleteRule: .cascade, inverse: \CoverLetter.jobApp)
  var coverLetters: [CoverLetter] = []
  var selectedResId: UUID?
  var selectedCoverId: UUID?

  var selectedRes: Resume? {
    get {
      if let id = selectedResId {
        return resumes.first(where: { $0.id == id })
      }
      return resumes.last
    }
    set {
      selectedResId = newValue?.id
    }
  }

  var selectedCover: CoverLetter? {
    get {
      if let id = selectedCoverId {
        return coverLetters.first(where: { $0.id == id })
      }
      return coverLetters.last
    }
    set {
      selectedCoverId = newValue?.id
    }
  }

  var job_position: String
  var job_location: String
  var company_name: String
  var company_linkedin_id: String = ""
  var job_posting_time: String = ""
  var job_description: String
  var seniority_level: String = ""
  var employment_type: String = ""
  var job_function: String = ""
  var industries: String = ""
  var job_apply_link: String = ""
  var posting_url: String = ""
  var status: Statuses = Statuses.new
  var notes: String = ""

  enum CodingKeys: String, CodingKey {
    case job_position
    case job_location
    case company_name
    case company_linkedin_id
    case job_posting_time
    case job_description
    case seniority_level
    case employment_type
    case job_function
    case industries
    case job_apply_link
    case resumes
    case coverLetters
    case selectedRes
    case status
    case posting_url
  }

  var jobListingString: String {
    var descriptionParts: [String] = []

    descriptionParts.append("Job Position: \(job_position)")
    descriptionParts.append("Job Location: \(job_location)")
    descriptionParts.append("Company Name: \(company_name)")

    if !company_linkedin_id.isEmpty {
      descriptionParts.append("Company LinkedIn ID: \(company_linkedin_id)")
    }

    if !job_posting_time.isEmpty {
      descriptionParts.append("Job Posting Time: \(job_posting_time)")
    }

    if !seniority_level.isEmpty {
      descriptionParts.append("Seniority Level: \(seniority_level)")
    }

    if !employment_type.isEmpty {
      descriptionParts.append("Employment Type: \(employment_type)")
    }

    if !job_function.isEmpty {
      descriptionParts.append("Job Function: \(job_function)")
    }

    if !industries.isEmpty {
      descriptionParts.append("Industries: \(industries)")
    }

    if !job_description.isEmpty {
      descriptionParts.append("Job Description: \(job_description)")
    }

    return descriptionParts.joined(separator: "\n")
  }

  @ViewBuilder
  var statusTag: some View {
    switch self.status {
      case .new:
        RoundedTagView(tagText: "New", backgroundColor: .green, foregroundColor: .white)
      case .inProgress:
        RoundedTagView(tagText: "In Progress", backgroundColor: .mint, foregroundColor: .white)
      case .unsubmitted:
        RoundedTagView(tagText: "Unsubmitted", backgroundColor: .cyan, foregroundColor: .white)
      case .submitted:
        RoundedTagView(tagText: "Submitted", backgroundColor: .indigo, foregroundColor: .white)
      case .interview:
        RoundedTagView(tagText: "Interview", backgroundColor: .pink, foregroundColor: .white)
      case .closed:
        RoundedTagView(tagText: "Closed", backgroundColor: .gray, foregroundColor: .white)
      case .followUp:
        RoundedTagView(tagText: "Follow Up", backgroundColor: .yellow, foregroundColor: .white)
      case .abandonned:
        RoundedTagView(tagText: "Abanddonned", backgroundColor: .black, foregroundColor: .white)
    }
  }
  static func pillColor(_ myCase: String) -> Color {
    let myCase = myCase.lowercased()
    switch myCase {
      case "closed": return Color.gray
      case "follow up": return Color.yellow
      case "interview": return Color.pink
      case "submitted": return Color.indigo
      case "unsubmitted": return Color.cyan
      case "in progress": return Color.mint
      case "new": return Color.green
      case "abandonned": return Color.black
      default: return Color.black
    }
  }
  init(
    job_position: String = "",
    job_location: String = "",
    company_name: String = "",
    company_linkedin_id: String = "",
    job_posting_time: String = "",
    job_description: String = "",
    seniority_level: String = "",
    employment_type: String = "",
    job_function: String = "",
    industries: String = "",
    job_apply_link: String = "",
    posting_url: String = ""
  ) {
    self.job_position = job_position
    self.job_location = job_location
    self.company_name = company_name
    self.company_linkedin_id = company_linkedin_id
    self.job_posting_time = job_posting_time
    self.job_description = job_description
    self.seniority_level = seniority_level
    self.employment_type = employment_type
    self.job_function = job_function
    self.industries = industries
    self.job_apply_link = job_apply_link
    self.posting_url = posting_url
  }

  func addResume(_ resume: Resume) {
    if self.status == .new {
      self.status = .inProgress
    }

    // Ensure uniqueness
    if !resumes.contains(where: { $0.id == resume.id }) {
      resumes.append(resume)
    }

    if selectedRes == nil { selectedRes = resume }
  }



  required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    self.job_position = try container.decode(String.self, forKey: .job_position)
    self.job_location = try container.decode(String.self, forKey: .job_location)
    self.company_name = try container.decode(String.self, forKey: .company_name)
    self.company_linkedin_id = try container.decodeIfPresent(String.self, forKey: .company_linkedin_id) ?? ""
    self.job_posting_time = try container.decodeIfPresent(String.self, forKey: .job_posting_time) ?? ""
    self.job_description = try container.decode(String.self, forKey: .job_description)
    self.seniority_level = try container.decodeIfPresent(String.self, forKey: .seniority_level) ?? ""
    self.employment_type = try container.decodeIfPresent(String.self, forKey: .employment_type) ?? ""
    self.job_function = try container.decodeIfPresent(String.self, forKey: .job_function) ?? ""
    self.industries = try container.decodeIfPresent(String.self, forKey: .industries) ?? ""
    self.job_apply_link = try container.decodeIfPresent(String.self, forKey: .job_apply_link) ?? ""
    self.status = try container.decodeIfPresent(Statuses.self, forKey: .status) ?? .new
  }

  public func assignPropsFromForm(_ sourceJobAppForm: JobAppForm) {
    self.job_position = sourceJobAppForm.job_position
    self.job_location = sourceJobAppForm.job_location
    self.company_name = sourceJobAppForm.company_name
    self.company_linkedin_id = sourceJobAppForm.company_linkedin_id
    self.job_posting_time = sourceJobAppForm.job_posting_time
    self.job_description = sourceJobAppForm.job_description
    self.seniority_level = sourceJobAppForm.seniority_level
    self.employment_type = sourceJobAppForm.employment_type
    self.job_function = sourceJobAppForm.job_function
    self.industries = sourceJobAppForm.industries
    self.job_apply_link = sourceJobAppForm.job_apply_link
    self.posting_url = sourceJobAppForm.posting_url
  }
}
import SwiftData

@Observable class JobAppForm {
  var job_position: String = ""
  var job_location: String = ""
  var company_name: String = ""
  var company_linkedin_id: String = ""
  var job_posting_time: String = ""
  var job_description: String = ""
  var seniority_level: String = ""
  var employment_type: String = ""
  var job_function: String = ""
  var industries: String = ""
  var job_apply_link: String = ""
  var posting_url: String = ""

  init() {
  }
  func populateFormFromObj(_ source: JobApp) {
    self.job_position = source.job_position
    self.job_location = source.job_location
    self.company_name = source.company_name
    self.company_linkedin_id = source.company_linkedin_id
    self.job_posting_time = source.job_posting_time
    self.job_description = source.job_description
    self.seniority_level = source.seniority_level
    self.employment_type = source.employment_type
    self.job_function = source.job_function
    self.industries = source.industries
    self.job_apply_link = source.job_apply_link
    self.posting_url = source.posting_url
  }
}
//
//  AppleJobScrape.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/27/24.
//
import SwiftSoup
import Foundation

extension JobApp {

  static func fetchHTMLContent(from urlString: String) async throws -> String {
    guard let url = URL(string: urlString) else {
      throw URLError(.badURL)
    }

    // Configure the URLSession to mimic a browser request
    var request = URLRequest(url: url)
    request.setValue("Mozilla/5.0", forHTTPHeaderField: "User-Agent")

    let (data, response) = try await URLSession.shared.data(for: request)

    // Check for HTTP response errors
    if let httpResponse = response as? HTTPURLResponse, !(200...299).contains(httpResponse.statusCode) {
      throw URLError(.badServerResponse)
    }

    // Convert data to string
    if let htmlContent = String(data: data, encoding: .utf8) {
      return htmlContent
    } else {
      throw URLError(.cannotDecodeContentData)
    }
  }

  static func parseAppleJobListing(jobAppStore: JobAppStore, html: String, url: String) {
    do {
      let doc: Document = try SwiftSoup.parse(html)
      let jobApp = JobApp()
      // Extract job position
      if let jobTitleElement = try doc.select("#jdPostingTitle").first() {
        jobApp.job_position = try jobTitleElement.text()
      }

      // Extract job location
      if let jobLocationElement = try doc.select("#job-location-name").first() {
        let locality = try jobLocationElement.select("span[itemProp=addressLocality]").text()
        let region = try jobLocationElement.select("span[itemProp=addressRegion]").text()
        let country = try jobLocationElement.select("span[itemProp=addressCountry]").text()
        jobApp.job_location = "\(locality), \(region), \(country)"
      }

      // Set company name
      jobApp.company_name = "Apple"

      // Extract job posting time
      if let jobPostDateElement = try doc.select("#jobPostDate").first() {
        jobApp.job_posting_time = try jobPostDateElement.text()
      }

      // Extract job description, combining description, minimum qualifications, and preferred qualifications
      var descriptionText = ""

      if let descriptionElement = try doc.select("#jd-description").first() {
        descriptionText += try descriptionElement.text() + "\n\n"
      }
      if let minQualificationsElement = try doc.select("#jd-minimum-qualifications").first() {
        descriptionText += "Minimum Qualifications:\n"
        descriptionText += try minQualificationsElement.text() + "\n\n"
      }
      if let prefQualificationsElement = try doc.select("#jd-preferred-qualifications").first() {
        descriptionText += "Preferred Qualifications:\n"
        descriptionText += try prefQualificationsElement.text() + "\n"
      }
      jobApp.job_description = descriptionText.trimmingCharacters(in: .whitespacesAndNewlines)

      // Extract job function (department or division)
      if let jobTeamElement = try doc.select("#job-team-name").first() {
        jobApp.job_function = try jobTeamElement.text()
      }
      jobApp.posting_url = url
      
      jobAppStore.selectedApp = jobAppStore.addJobApp(jobApp)
    } catch Exception.Error(let type, let message) {
      print("Type: \(type), Message: \(message)")
    } catch {
      print("Unexpected error: \(error).")
    }
  }
}
import Foundation
import SwiftData
import SwiftUI

enum LeafStatus: String, Codable, Hashable {
  case isEditing = "isEditing"
  case aiToReplace = "aiToReplace"
  case disabled = "leafDisabled"
  case saved = "leafValueSaved"
  case isNotLeaf = "nodeIsNotLeaf"
}

// Example SwiftData model

@Model class TreeNode: Identifiable {
  var id = UUID().uuidString
  var name: String = ""
  var value: String

  private(set) var myIndex: Int = -1
  static public var childIndexer = 0
  @Relationship(deleteRule: .cascade) var children: [TreeNode]? = nil
  weak var parent: TreeNode?

  @Relationship(deleteRule: .noAction) var resume: Resume
  var status: LeafStatus
  private(set) var nodeDepth: Int

  var hasChildren: Bool {
    return !(children?.isEmpty ?? true)
  }
  var aiStatusChildren: Int {
    var count = 0

    // Check if the current node has the desired status
    if self.status == .aiToReplace {
      count += 1
    }

    // Recursively count the descendants with the desired status
    if let children = self.children {
      for child in children {
        count += child.aiStatusChildren
      }
    }

    return count
  }

  init(
    name: String, value: String = "", children: [TreeNode]? = nil,
    parent: TreeNode? = nil, status: LeafStatus = LeafStatus.disabled,
    resume: Resume
  ) {
    self.name = name
    self.value = value
    self.children = children
    self.parent = parent
    self.status = status
    self.nodeDepth = 0
    self.resume = resume
    resume.nodes.append(self)
    // No need to set status again, it's already set by default.
  }
  @discardableResult
  func addChild(_ child: TreeNode) -> TreeNode {
    if self.children == nil {
      self.children = []
    }
    //    print(child.resume.id)
    child.parent = self
    child.myIndex = TreeNode.childIndexer
    child.nodeDepth = self.nodeDepth + 1
    self.children?.append(child)
    TreeNode.childIndexer += 1
    return child
  }
  var growDepth: Bool { return nodeDepth > 2 }
  static func traverseAndExportNodes(node: TreeNode, currentPath: String = "")
    -> [[String: String]]
  {
    var result: [[String: String]] = []
    var newPath: String
    // Construct the current tree path
    if node.parent == nil {
      newPath = "Resume"
    } else {
      newPath =
        currentPath.isEmpty ? node.name : "\(currentPath) > \(node.name)"
    }
    // If the node's status is .aiToReplace, add it to the result array
    if node.status == .aiToReplace {
      if node.name != "" && node.value != "" {

      }

      let nodeData: [String: String] = [
        "id": node.id,
        "value": node.value,
        "tree_path": newPath,
      ]
      result.append(nodeData)
    }

    // Recursively traverse the children
    for child in node.children ?? [] {
      let childResults = traverseAndExportNodes(
        node: child, currentPath: newPath)
      result.append(contentsOf: childResults)
    }

    return result
  }

  /// Updates the values of TreeNode objects based on the provided JSON file.
  /// - Parameters:
  ///   - jsonFileURL: The URL of the JSON file containing the array of {id: String, value: String} objects.
  ///   - context: The SwiftData context used to fetch and update the TreeNode objects.
  /// - Throws: An error if reading the JSON file, parsing JSON, or saving the context fails.
  static func updateValues(from jsonFileURL: URL, using context: ModelContext) throws {
    // Load JSON data from the provided file URL
    let jsonData = try Data(contentsOf: jsonFileURL)

    // Parse JSON data into an array of dictionaries
    guard let jsonArray = try JSONSerialization.jsonObject(
      with: jsonData, options: []) as? [[String: String]] else {
      print("Failed to parse JSON.")
      return
    }

    // Iterate over the array and update corresponding TreeNodes
    for jsonObject in jsonArray {
      if let id = jsonObject["id"], let newValue = jsonObject["value"] {
        // Fetch the corresponding TreeNode from the SwiftData store manually
        let fetchRequest = FetchDescriptor<TreeNode>(
          predicate: #Predicate { $0.id == id }
        )

        if let node = try context.fetch(fetchRequest).first {
          // Update the value of the TreeNode
          node.value = newValue
        } else {
          print("TreeNode with id \(id) not found.")
        }
      } else {
        print("Invalid JSON object: \(jsonObject)")
      }
    }

    // Save the context to persist changes
    try context.save()
  }

  static func deleteTreeNode(node: TreeNode, context: ModelContext) {
    // Recursively delete children
    for child in node.children ?? [] {
      deleteTreeNode(node: child, context: context)
    }
    // Remove from parent's children array if necessary
    if let parent = node.parent, let index = parent.children?.firstIndex(of: node) {
      parent.children?.remove(at: index)
    }
    // Remove from resume.nodes
    if let index = node.resume.nodes.firstIndex(of: node) {
      node.resume.nodes.remove(at: index)
    }
    // Delete the node itself
    context.delete(node)

    // Save context to persist changes
    do {
      try context.save()
    } catch {
      print("Failed to delete TreeNode: \(error)")
    }
  }

  func deepCopy(newResume: Resume) -> TreeNode {
    // Create a copy of the current node with the new resume
    let copyNode = TreeNode(
      name: self.name,
      value: self.value,
      parent: nil,  // The parent will be set during recursion
      status: self.status,
      resume: newResume
    )

    // Recursively copy the children
    if let children = self.children {
      for child in children {
        let childCopy = child.deepCopy(newResume: newResume)
        copyNode.addChild(childCopy)  // Attach the child to the copied parent
      }
    }

    return copyNode
  }

}
//
//  CoverLetterPrompts.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/12/24.
//
import SwiftOpenAI
import Foundation


enum CoverAiMode: String, Codable {
  case generate
  case revise
  case rewrite
  case none

}
struct CoverLetterPrompts {

  static var systemMessage = ChatCompletionParameters.Message(
    role: .system,
    content: .text("You are an expert career advisor and professional writer specializing in crafting exceptional and memorable cover letters. Your task is to create an extraordinarily well-written and memorable cover letter for a job application, based on the job listing and resume provided below. The cover letter should be in plain text with no commentary or annotations—only the text of the letter itself."))

  static func generate(coverLetter: CoverLetter, resume: Resume, mode: CoverAiMode, customFeedbackString: String? = "") -> String {
    let applicant = Applicant() //Todo: Fix Hardcoded applicant info
    let app = coverLetter.jobApp
    let formatter = DateFormatter()
    formatter.dateStyle = .long // Automatically formats as "January 1, 2025"
    let formattedDate = formatter.string(from: Date())
    var resRefString: String = ""
    var prompt: String = ""
    switch mode {
    case .generate:
        if coverLetter.includeResumeRefs {
          let resRefs = resume.bgDocs
            if resRefs.isEmpty {
              resRefString = ""
            } else {
              resRefString = resRefs.map { $0.name + ":\n" + $0.content + "\n\n" }.joined()
            }
        }
      prompt = """
        You are an expert career advisor and professional writer specializing in crafting exceptional and memorable cover letters. Your task is to create an extraordinarily well-written and memorable cover letter for \(applicant.name)'s application to be hired as a \(app?.job_position ?? "") at \(app?.company_name ?? ""). The cover letter should be in plain text with no commentary or annotations—only the text of the letter itself.

        **Instructions:**

        - **Personalization:** Tailor the cover letter specifically to the job listing at \(app?.company_name ?? ""), aligning \(applicant.name)'s skills and experiences with the job requirements.
        - **Highlight Strengths:** Emphasize the most relevant qualifications, achievements, and experiences from \(applicant.name)'s résumé that make them an ideal fit for the position.
        - **Professional Tone:** Maintain a professional and engaging tone throughout the letter.
        - **Memorable Impact:** Craft the letter to leave a lasting impression on the reader, making it stand out among other applications.
        - **Formatting:** Begin with a proper salutation and structure the letter in coherent paragraphs, concluding with a strong closing statement.
        - Date the letter with today's date: \(formattedDate)

        \(applicant.name) has provided the following background information regarding their current job search that may be useful in composing the draft cover letter:
        \(applicant.name)'s contact information:
        \(applicant.name)
        \(applicant.address)
        \(applicant.city), \(applicant.state) \(applicant.zip)
        \(applicant.email)
        \(applicant.websites)
        
        \(applicant.name) provided these additional notes that should be used to draft the cover letter:
        \(coverLetter.backgroundItemsString)
        
        
        **Full Job Listing:**

        \(app?.jobListingString ?? "")

        **Text Version of Résumé to be Submitted with Application:**

        \(resume.textRes)

        \(applicant.name) has also included a few samples of cover letters they wrote for earlier applications that they are particularly satisfied with. Use these writing samples as a guide to the writing style and voice of your cover letter draft:

        \(coverLetter.writingSamplesString)
        
        """
        if coverLetter.includeResumeRefs {
        prompt = prompt + """
        
        ** Extended Summary of Experience and Technical Skills **
        \(applicant.name) has also included these background documents to provide a more detailed summary of his experience and technical skills for additional context for the cover letter draft:
        
        \(resRefString)
        """
        }
    case .revise:
      prompt = """
            Upon reading your latest draft, \(applicant.name) has provided the following feedback:

                \(customFeedbackString ?? "no feedback provided")
        
        requested that you prepare a revised draft that improves upon the original while incorporating \(applicant.name)'s feedback. Your response should only include the plain full text the revised letter draft without any markdown formatting or additonal explanations or reasoning.
        """
    case .rewrite:
      prompt = """
            My initial draft of a cover letter to accompany my application to be hired as a  \(app?.job_position ?? "") at \(app?.company_name ?? "") is included below.
            \(coverLetter.editorPrompt)
        
        Cover Letter initial draft:
        \(coverLetter.content)

        """
      case .none:
        prompt = "none"
    }

    return prompt
  }
  enum EditorPrompts: String, Codable, CaseIterable {
    case improve =
      "Please carefully read the draft and indentify at least three ways the content and quality of the writing can be improved. Provde a new draft that incorporates the identified improvements."
    case zissner =
      "Carefully read the letter as a professional editor, specifically William Zissner incorporating the writing techniques and style he advocates in \"On Writing Well\" Provide a new draft that incorporates Zissner's edits to improve the quality of the writing. "
    case custom =
      "Please provide a revised draft of the provided cover letter incorporating the following feedback: "
  }
}
import Foundation
import SwiftData
import SwiftOpenAI

@Model
class CoverLetter: Identifiable, Hashable {
  var jobApp: JobApp? = nil
  @Attribute(.unique) var id: UUID = UUID()  // Explicit id field
  var createdDate: Date = Date()
  var moddedDate: Date = Date()
  var content: String = ""
  var generated: Bool = false
  var includeResumeRefs: Bool = false
  var encodedEnabledRefs: Data?  // Store as Data
  var encodedMessageHistory: Data?  // Store as Data
  var currentMode: CoverAiMode? = CoverAiMode.none
  var editorPrompt: CoverLetterPrompts.EditorPrompts = CoverLetterPrompts.EditorPrompts.zissner
  var modDate: String {
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "hh:mm a 'on' MM/dd/yy"
    return dateFormatter.string(from: moddedDate)
  }

  // Computed properties to decode arrays
  var enabledRefs: [CoverRef] {
    get {
      guard let data = encodedEnabledRefs else { return [] }
      return (try? JSONDecoder().decode([CoverRef].self, from: data)) ?? []
    }
    set {
      encodedEnabledRefs = try? JSONEncoder().encode(newValue)
    }
  }
  var messageHistory: [MessageParams] {
    get {
      guard let data = encodedMessageHistory else {
        return []
      }
      do {
        return try JSONDecoder().decode([MessageParams].self, from: data)
      } catch {
        fatalError("Failed to decode messageHistory: \(error.localizedDescription)")
      }
    }
    set {
      do {
        encodedMessageHistory = try JSONEncoder().encode(newValue)

      } catch {
        fatalError("Failed to encode messageHistory: \(error.localizedDescription)")
      }
    }
  }

  init(
    enabledRefs: [CoverRef],
    jobApp: JobApp?
  ) {
    self.encodedEnabledRefs = try? JSONEncoder().encode(enabledRefs)
    self.jobApp = jobApp ?? nil
  }
  var backgroundItemsString: String {
    return enabledRefs.filter { $0.type == CoverRefType.backgroundFact }
      .map { $0.content }.joined(separator: "\n\n")
  }
  var writingSamplesString: String {
    return enabledRefs.filter { $0.type == CoverRefType.writingSample }
      .map { $0.content }.joined(separator: "\n\n")
  }
}

@Model
class MessageParams: Identifiable, Codable {
  var id: String = UUID().uuidString
  var content: String
  var role: MessageRole

  init(content: String, role: MessageRole) {
    self.content = content
    self.role = role
  }

  // Manual Codable implementation
  enum CodingKeys: String, CodingKey {
    case id
    case content
    case role
  }

  // Required initializer for Decodable
  required init(from decoder: Decoder) throws {
    let container = try decoder.container(keyedBy: CodingKeys.self)
    id = try container.decode(String.self, forKey: .id)
    content = try container.decode(String.self, forKey: .content)
    role = try container.decode(MessageRole.self, forKey: .role)
  }

  // Required function for Encodable
  func encode(to encoder: Encoder) throws {
    var container = encoder.container(keyedBy: CodingKeys.self)
    try container.encode(id, forKey: .id)
    try container.encode(content, forKey: .content)
    try container.encode(role, forKey: .role)
  }

  // Make MessageRole conform to Codable
  enum MessageRole: String, Codable {
    case user = "user"
    case assistant = "assistant"
    case system = "system"
    case none = "none"
  }
}
//
//  ResumeQuery.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/25/24.
//

import Foundation
import SwiftOpenAI

@Observable class ResumeApiQuery {
  static let revNodeArraySchema =
    JSONSchemaResponseFormat(
      name: "revNode_array_response",
      strict: true,
      schema: JSONSchema(
        type: .object,
        properties: [
          "revArray": JSONSchema(
            type: .array,
            items: JSONSchema(
              type: .object,
              properties: [
                "id": JSONSchema(
                  type: .string,
                  description:
                    "The unique identifier for the node provided in the original EditableNode"
                ),
                "oldValue": JSONSchema(
                  type: .string,
                  description:
                    "The original value before revision provided in the original EditableNode"),
                "newValue": JSONSchema(
                  type: .string,
                  description:
                    "The proposed new value after revision"),
                "valueChanged": JSONSchema(
                  type: .boolean,
                  description:
                    "Indicates if the value is changed by the proposed revision."
                ),
                "why": JSONSchema(
                  type: .string,
                  description:
                    "Explanation for the proposed revision. Note that an explanation is not required: set this value to a blank string if the reason is trivial or obvious."
                ),
              ],
              required: ["id", "oldValue", "newValue", "valueChanged", "why"],
              additionalProperties: false
            ))
        ],
        required: ["revArray"],
        additionalProperties: false))

  let systemMessage = ChatCompletionParameters.Message(
    role: .system,
    content: .text(
      "You are an expert career coach with a specialization in crafting and refining technical resumes to optimize them for job applications. With extensive experience in helping candidates secure interviews at top companies, you understand the importance of aligning resume content with job descriptions and the subtleties of tailoring resumes to specific roles. \n\nYour task is to use the information provided—such as the candidate’s current resume, job listing details, and additional background resources—to customize and optimize the resume. You should mirror the language and specific skills mentioned in the job listing where appropriate, ensuring that the resume is tailored to meet the expectations of potential employers while staying true to the candidate’s actual skills and experiences. Your goal is to make the resume as compelling as possible for the target position, increasing the chances of the candidate being selected for an interview"
    ))

  let applicant: Applicant
  var queryString: String = ""
  let attentionGrab: Int = 2
  let res: Resume
  var backgroundDocs: String {
    let bgrefs = res.bgDocs
    if bgrefs.isEmpty {
      return ""
    } else {
      return bgrefs.map { $0.name + ":\n" + $0.content + "\n\n" }.joined()
    }

  }
  var resumeText: String {
    let sources = res.enabledSources
    if sources.isEmpty { return "" }

    return sources.first { $0.type == SourceType.resumeSource }?.content
      ?? ""
  }
  var resumeJson: String {
    let sources = res.enabledSources
    if sources.isEmpty {
      return ""
    }

    return sources.first { $0.type == SourceType.jsonSource }?.content ?? ""
  }
  var jobListing: String {
    //        print(res.jobApp?.jobListingString ?? "")
    return res.jobApp?.jobListingString ?? ""
  }

  var updatableFieldsString: String {
    if let rootNode = res.rootNode {
      let exportDict = TreeNode.traverseAndExportNodes(node: rootNode)


      do {
        let updatableJsonData = try JSONSerialization.data(
          withJSONObject: exportDict, options: .prettyPrinted)
        return String(data: updatableJsonData, encoding: .utf8) ?? ""
      } catch {
        print("Error serializing JSON: \(error.localizedDescription)")
        return ""
      }
    }
    else {print("rootnode error")
    return ""}
  }

  init(resume: Resume) {
    applicant = Applicant()  //To Do allow for general applicant name etc. (Needs UI)
    self.res = resume

  }
  func revisionPrompt(_ fb: [FeedbackNode])->String {
    let json = fbToJson(fb)
    let prompt = """
    \(applicant.name) has reviewed your proposed revsion and has provided feedback. Please revise and rewrite as specified for each FeedbackNode below. Provide your updated revisions as an array of RevNodes (schema attached).  The RevNodeArray should  only include RevNodes for each of the FeedbackNodes below for which your action is required (newValue != oldValue). No response is required for any FeedbackMode for which no action is required. 
        
        Feedback Nodes:
        \(json ?? "none provided")
    """
    return prompt
  }
  var wholeResumeQueryString: String {
    var attentionGrabLanguage: String

    switch self.res.attentionGrab {
    case 0:
      attentionGrabLanguage = ""
    case 1:
      attentionGrabLanguage =
        "Make the résumé stand out by emphasizing key skills and experiences without going overboard."
    case 2:
      attentionGrabLanguage =
        "Ensure the résumé is memorable and attention-grabbing, while maintaining a focus on relevance and truthfulness."
    case 3:
      attentionGrabLanguage =
        "Make a strong impression with the résumé, prioritizing memorability and uniqueness, even if it pushes some boundaries."
    case 4:
      attentionGrabLanguage =
        "Make every effort to make this résumé memorable and attention-grabbing above all else. Making any sort of impression is more important than making a positive impression. Make this résumé something the recruiter is certain to remember, even if it pushes some boundaries."
    default:
      attentionGrabLanguage = ""
    }

    // Start building the prompt string
    let prompt = """
      ================================================================================
      Latest Résumé:
      \(resumeText)
      ================================================================================
      This is the most recent version of \(applicant.name)'s résumé, rendered in plain text. The résumé was generated from the following JSON data using a command-line utility and a Handlebars-based template. The utility also creates HTML and PDF versions.

      Résumé Source JSON:
      \(resumeJson)
      ================================================================================
      ================================================================================
      Goal:
      Our primary objective is to secure \(applicant.name) an interview for the following position:

      Job Listing:
      \(jobListing)

      Task:
      Starting with \(applicant.name)'s latest résumé, your task is to utilize the background resources provided below to customize the résumé. The goal is to ensure it is finely tailored to the job listing.

      - **Do Not** fabricate experience.
      - **Do** highlight and frame the skills and experiences in a way that is most relevant and compelling for the position.
      - **Do** mirror the specific language and skills mentioned in the job listing, as long as they are consistent with \(applicant.name)'s actual skills and experience. This will help align the résumé more closely with the employer’s expectations and increase the likelihood of passing through automated screening systems.

      For example, if the job listing emphasizes 'Statistical Process Control (SPC),' ensure that Christopher’s experience with similar methodologies is clearly highlighted and described in similar terms.

      Guidance:
      Leverage the provided resources to make the résumé as compelling as possible for the job listing. Focus on enhancing the relevance of the résumé content by aligning it with the job description and emphasizing \(applicant.name)’s qualifications. \(attentionGrabLanguage)

      Prioritize the most relevant background information from the documents provided, particularly those that align directly with the job listing requirements. Use this information to inform your customizations, ensuring that the final résumé is targeted, effective, and stands out.
      ================================================================================
      ================================================================================
      You may only modify the résumé values in the following array of EditableNodes:
      \(updatableFieldsString)

      An EditableNode includes (1) the résumé value (which your customizations will change) (2) an id, which will be used to update the values in the resume source programatically, and must be referenced in your response and (3) a text tree path which is provided to aid in understanding the values in the context of the resume)

      ================================================================================

      You will provide your suggested résumé revsions as an RevArray (schema attached), an array of RevNodes that is needed to obtain feedback on each of your proposed revisions. Although the number of RevNodes should match the number of Editible nodes in the original set, you do not need to revise the value of every EditibleNode. For those values that are acceptable without revision, set newValue to "" and valueUpdated to False. 

      ================================================================================
      ================================================================================
      Background Resources:
      Below are additional resources that may provide context and supporting information for your task:
      \(backgroundDocs)
      ================================================================================
      ================================================================================

      Reminder:
      As you finalize the customized résumé, ensure that:
      - **No experience is fabricated.**
      - Skills and experiences are framed in a way that is relevant, compelling, and truthful.
      - The writing is memorable and attention-grabbing to increase the likelihood of catching a recruiter’s eye and prompting a follow-up.
      - The language and skills from the job listing are mirrored where appropriate and consistent with \(applicant.name)’s actual experience.
      - The RevArray should have an element for every EditbleNode provided.
      - The final résumé is compelling, accurate, and aligned with the job listing’s requirements.
      """

    // Print or return the final prompt
    return prompt

  }
}
//
//  ChatStructuredOutputProvider.swift
//  SwiftOpenAIExample
//
//  Created by James Rochabrun on 8/10/24.
//

import Foundation
import SwiftOpenAI

@Observable
final class ResumeChatProvider {

  private let service: OpenAIService
  private var streamTask: Task<Void, Never>? = nil
  var message: String = ""
  var messages: [String] = []
  var messageHist: [ChatCompletionParameters.Message] = []
  var errorMessage: String = ""
  var lastRevNodeArray: [ProposedRevisionNode] = []


  // MARK: - Initializer

  init(service: OpenAIService) {
    
    self.service = service

  }
  private func convertJsonToNodes(_ jsonString: String?) -> [ProposedRevisionNode]? {

    guard let jsonString = jsonString, let jsonData = jsonString.data(using: .utf8) else {
      print("Error converting string to data")
      return nil
    }

    do {
      // Decode the JSON data into RevisionsContainer
      let revisionsContainer = try JSONDecoder().decode(RevisionsContainer.self, from: jsonData)

      // Return the array of ProposedRevisionNode
      return revisionsContainer.revArray
    } catch {
      print("Failed to decode JSON: \(error)")
      return nil
    }
  }

  // MARK: - Public Methods
  func unloadResponse() -> [ProposedRevisionNode]? {
    if let nodes = convertJsonToNodes(messages[0]) {
      messages.removeFirst()
      self.lastRevNodeArray = nodes
      return nodes
    } else {
      return nil
    }
  }
  func startChat(
    parameters: ChatCompletionParameters
  ) async throws {
    do {

      let choices = try await service.startChat(parameters: parameters).choices
      self.messages = choices.compactMap(\.message.content).map { $0.asJsonFormatted() }
      assert(messages.count == 1)
      print(self.messages.last ?? "Nothin")
      self.lastRevNodeArray = convertJsonToNodes(messages.last) ?? []
      messageHist
        .append(
          .init(role: .assistant, content: .text(choices.last?.message.content ?? ""))
        )
      self.errorMessage = choices.first?.message.refusal ?? ""
    } catch APIError.responseUnsuccessful(let description, let statusCode) {
      self.errorMessage =
        "Network error with status code: \(statusCode) and description: \(description)"
    } catch {
      self.errorMessage = error.localizedDescription
    }
  }

  func startStreamedChat(
    parameters: ChatCompletionParameters
  ) async throws {
    streamTask = Task {
      do {
        let stream = try await service.startStreamedChat(parameters: parameters)
        for try await result in stream {
          let firstChoiceDelta = result.choices.first?.delta
          let content = firstChoiceDelta?.refusal ?? firstChoiceDelta?.content ?? ""
          self.message += content
          if result.choices.first?.finishReason != nil {
            self.message = self.message.asJsonFormatted()
          }
        }
      } catch APIError.responseUnsuccessful(let description, let statusCode) {
        self.errorMessage =
          "Network error with status code: \(statusCode) and description: \(description)"
      } catch {
        self.errorMessage = error.localizedDescription
      }
    }
  }

  func cancelStream() {
    streamTask?.cancel()
  }
}

/// Helper that allows to display the JSON Schema.
extension String {
  func asJsonFormatted() -> String {
    guard let data = self.data(using: .utf8) else { return self }
    do {
      // Parse JSON string to Any object
      if let jsonObject = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
        // Traverse and strip quotes from string values
        let cleanedObject = stripQuotes(from: jsonObject)

        // Convert back to data with pretty-printing
        let prettyPrintedData = try JSONSerialization.data(
          withJSONObject: cleanedObject, options: [.prettyPrinted, .sortedKeys])

        // Convert formatted data back to string
        return String(data: prettyPrintedData, encoding: .utf8) ?? self
      }
    } catch {
      print("Error formatting JSON: \(error)")
    }
    return self
  }

  // Recursive function to traverse and strip quotes from string values in a dictionary
  private func stripQuotes(from dictionary: [String: Any]) -> [String: Any] {
    var newDict = dictionary
    for (key, value) in dictionary {
      if let stringValue = value as? String {
        // Strip quotes from the string value
        newDict[key] = stringValue.trimmingCharacters(in: CharacterSet(charactersIn: "\""))
      } else if let nestedDict = value as? [String: Any] {
        // Recursively strip quotes in nested dictionaries
        newDict[key] = stripQuotes(from: nestedDict)
      } else if let arrayValue = value as? [Any] {
        // Recursively process arrays
        newDict[key] = stripQuotes(from: arrayValue)
      }
    }
    return newDict
  }

  // Recursive function to traverse and strip quotes from string values in an array
  private func stripQuotes(from array: [Any]) -> [Any] {
    return array.map { value in
      if let stringValue = value as? String {
        return stringValue.trimmingCharacters(in: CharacterSet(charactersIn: "\""))
      } else if let nestedDict = value as? [String: Any] {
        return stripQuotes(from: nestedDict)
      } else if let nestedArray = value as? [Any] {
        return stripQuotes(from: nestedArray)
      } else {
        return value
      }
    }
  }
}
import Foundation
import SwiftOpenAI
import SwiftUI

@Observable
final class CoverChatProvider {

  private let service: OpenAIService
  var message: String = ""
  var messages: [String] = []
  var messageHist: [ChatCompletionParameters.Message] = []
  var errorMessage: String = ""
  var resultsAvailable: Bool = false
  var lastResponse: String = ""

  // MARK: - Initializer

  init(service: OpenAIService) {

    self.service = service

  }

  func startChat(
    parameters: ChatCompletionParameters,
    onComplete: (_: String) -> Void
  ) async throws {
    do {
      print("sending request")
      let choices = try await service.startChat(parameters: parameters).choices
      self.messages = choices.compactMap(\.message.content).map {
        $0.asJsonFormatted()
      }
      assert(messages.count == 1)
      print(self.messages.last ?? "Nothin")
      messageHist
        .append(
          .init(
            role: .assistant,
            content: .text(choices.last?.message.content ?? ""))
        )
      self.lastResponse = choices.last?.message.content ?? ""
      self.resultsAvailable = true
      self.errorMessage = choices.first?.message.refusal ?? ""
      onComplete(self.lastResponse)
    } catch APIError.responseUnsuccessful(let description, let statusCode) {
      self.errorMessage =
        "Network error with status code: \(statusCode) and description: \(description)"
    } catch {
      self.errorMessage = error.localizedDescription
    }
  }
  func processResults(
    newMessage: String,
    coverLetter: CoverLetter,
    buttons: Binding<CoverLetterButtons>
  ) {
    print("processResults")

    coverLetter.generated = true
    coverLetter.messageHistory.append(
      .init(content: newMessage, role: .assistant))
    coverLetter.content = newMessage
    print(newMessage)
    buttons.wrappedValue.runRequested = false
    self.resultsAvailable = false

  }
  func coverChatRevise(
    res: Resume?,
    jobAppStore: JobAppStore,
    chatProvider: CoverChatProvider,
    buttons: Binding<CoverLetterButtons>,
    customFeedback: Binding<String>
  ) {
    Task {
      print("reviseAction")
      buttons.wrappedValue.runRequested = true
      defer {
        //        var myButtons = buttons.wrappedValue
        //        myButtons.runRequested = false
        customFeedback.wrappedValue = ""
      }

      guard let resume = res, let cL = jobAppStore.selectedApp?.selectedCover
      else {
        print("guard fail")
        return
      }

      print("revise")
      let prompt = CoverLetterPrompts.generate(
        coverLetter: cL, resume: resume, mode: cL.currentMode ?? .revise,
        customFeedbackString: customFeedback.wrappedValue)
      let myContent: ChatCompletionParameters.Message.ContentType = .text(
        prompt)
      cL.messageHistory.append(.init(content: prompt, role: .user))
      self.messageHist = cL.messageHistory.map { messageParam in
        ChatCompletionParameters.Message(
          role: ChatCompletionParameters.Message.Role(
            rawValue: messageParam.role.rawValue) ?? .user,  // Assuming a fallback to `.user`
          content: .text(messageParam.content),  // Assuming content is text-based
          refusal: nil,  // Assuming no refusal messages
          name: nil,  // Assuming no specific name
          audio: nil,  // Assuming no audio data
          functionCall: nil,  // Deprecated; set to nil
          toolCalls: nil,  // Assuming no tool calls
          toolCallID: nil  // Assuming no tool call ID
        )
      }

      print("message count: \(self.messageHist.count)")
      let parameters = ChatCompletionParameters(
        messages: self.messageHist,
        model: .gpt4o20241120,
        responseFormat: .text
      )
      try await self.startChat(
        parameters: parameters,
        onComplete: { @MainActor newMessage in
          processResults(
            newMessage: newMessage,
            coverLetter: cL,
            buttons: buttons
          )
        })

    }
  }
  func coverChatAction(
    res: Resume?,
    jobAppStore: JobAppStore,
    chatProvider: CoverChatProvider,
    buttons: Binding<CoverLetterButtons>
  ) {
    Task {
      print("chatAction")
      buttons.wrappedValue.runRequested = true
//      defer {
//        buttons.wrappedValue.runRequested = false
        //         var myButtons = buttons.wrappedValue
        //          myButtons.runRequested = false
//      }

      guard let resume = res, let cL = jobAppStore.selectedApp?.selectedCover
      else {
        print("guard fail")
        return
      }

      print("generate")
      let prompt = CoverLetterPrompts.generate(
        coverLetter: cL, resume: resume, mode: cL.currentMode ?? .generate)
      print("prompt: \(prompt)")
      let myContent: ChatCompletionParameters.Message.ContentType = .text(
        prompt)
      self.messageHist = [
        CoverLetterPrompts.systemMessage,
        .init(role: .user, content: myContent),
      ]
      cL.messageHistory = [
        .init(
          content: {
            switch CoverLetterPrompts.systemMessage.content {
            case .text(let text): return text
            case .contentArray(_): return ""  // Handle as needed
            }
          }(), role: .system),
        .init(content: prompt, role: .user),
      ]
      print("handler message count: \(self.messageHist.count)")
      print("CL message count:  \(cL.messageHistory.count)")
      let parameters = ChatCompletionParameters(
        messages: self.messageHist,
        model: .gpt4o20241120,
        responseFormat: .text
      )
      try await self.startChat(
        parameters: parameters,
        onComplete: { @MainActor newMessage in
          processResults(
            newMessage: newMessage,
            coverLetter: cL,
            buttons: buttons
          )
        })

    }
  }
}

//
//  StackSecondView.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/2/24.
//

import SwiftUI

struct StackSecondView: View {
  var body: some View {
    Text( /*@START_MENU_TOKEN@*/"Hello, World!" /*@END_MENU_TOKEN@*/)
  }
}
//
//  InsetGroupStyle.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/13/24.
//

import SwiftUI

extension View {
  func insetGroupedStyle<V: View>(header: V) -> some View {
    return GroupBox(label: header.padding(.top).padding(.bottom, 6)) {
      Form {
        self.padding(.vertical, 3).padding(.horizontal, 5)

      }.padding(.horizontal).padding(.vertical)
    }
  }
}
//
//  CustomToolbarButtonStyle.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/22/24.
//

import SwiftUI

struct CustomToolbarButtonStyle: ButtonStyle {
  func makeBody(configuration: Configuration) -> some View {
    configuration.label
      .padding(3)
      .cornerRadius(5)
      .background(Color.blue.opacity(0.3))
      .foregroundStyle(.gray)
      .scaleEffect(configuration.isPressed ? 1.2 : 1)
      .animation(.easeOut(duration: 0.2), value: configuration.isPressed)
  }
}
//
//  StackNavigationView.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/2/24.
//
import SwiftUI

struct StackNavigationView<RootContent>: View where RootContent: View {
  @Binding var currentSubview: AnyView
  @Binding var showingSubview: Bool

  let rootView: () -> RootContent

  init(
    currentSubview: Binding<AnyView>, showingSubview: Binding<Bool>,
    @ViewBuilder rootView: @escaping () -> RootContent
  ) {
    self._currentSubview = currentSubview
    self._showingSubview = showingSubview
    self.rootView = rootView
  }
  var body: some View {
    VStack {
      if !showingSubview {
        rootView()
      } else {
        StackNavigationSubview(isVisible: $showingSubview) {
          currentSubview
        }
        .transition(.move(edge: .trailing))
      }
    }
  }
  private struct StackNavigationSubview<Content>: View where Content: View {
    @Binding var isVisible: Bool
    let contentView: () -> Content
    var body: some View {
      VStack {
        contentView()  // subview
      }
      .toolbar {
        ToolbarItem(placement: .navigation) {
          Button(
            action: {
              withAnimation(.easeOut(duration: 0.3)) {
                isVisible = false
              }
            },
            label: {
              Label("back", systemImage: "chevron.left")
            })
        }
      }
    }

  }
}
//
//  StackRootView.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/2/24.
//

import SwiftUI

struct StackRootView: View {
  @State private var currentSubview = AnyView(StackSecondView())
  @State private var showingSubview = false
  var body: some View {
    StackNavigationView(currentSubview: $currentSubview, showingSubview: $showingSubview) {
      Text("I'm the rootview")
      Button(
        action: {
          showSubview(
            view: AnyView(
              Text("Subview!").frame(maxWidth: .infinity, maxHeight: .infinity).background(
                Color.white)))
        },
        label: {
          Text("go to subview")
        })
    }
    .frame(
      minWidth: 500, idealWidth: 500, maxWidth: 500, minHeight: 500, idealHeight: 500,
      maxHeight: 500)
  }
  private func showSubview(view: AnyView) {
    withAnimation(.easeOut(duration: 0.3)) {
      currentSubview = view
      showingSubview = true
    }
  }
}
import SwiftUI

struct RefRow: View {
  @Environment(CoverLetterStore.self) private var coverLetterStore: CoverLetterStore
  @Bindable var cL: CoverLetter
  @Bindable var element: CoverRef
  @Bindable var coverRefStore: CoverRefStore
  @State var isButtonHovering = false
  var showPreview: Bool

  var body: some View {
    HStack {
      Toggle(
        isOn: Binding<Bool>(
          get: {
            cL.enabledRefs.contains { $0.id == element.id }
          },
          set: { isEnabled in
            guard let oldCL = coverLetterStore.cL else { return }

            if oldCL.generated {
              // Make a new copy
              let newCL = coverLetterStore.createDuplicate(letter: oldCL)
              if isEnabled {
                newCL.enabledRefs.append(element)
              } else {
                newCL.enabledRefs.removeAll { $0.id == element.id }
              }
              coverLetterStore.cL = newCL
            } else {
              // Mutate the existing cL in place
              if isEnabled {
                cL.enabledRefs.append(element)
              } else {
                cL.enabledRefs.removeAll { $0.id == element.id }
              }
            }
          }
        )
      ) {
        HStack {
          // Show either content or name
          if showPreview {
            Text(element.content)
              .contextMenu {
                Button(role: .destructive) {
                  coverRefStore.deleteCoverRef(element)
                } label: {
                  Label("Delete", systemImage: "trash")
                }
              }
          } else {
            Text(element.name)
              .contextMenu {
                Button(role: .destructive) {
                  coverRefStore.deleteCoverRef(element)
                } label: {
                  Label("Delete", systemImage: "trash")
                }
              }
          }

          Spacer()

          // A trash button for quick deletion
          Button(action: {
            coverRefStore.deleteCoverRef(element)
          }) {
            Image(systemName: "trash.fill")
              .foregroundColor(isButtonHovering ? .red : .gray)
              .font(.system(size: 15))
              .padding(2)
              .background(
                isButtonHovering
                ? Color.red.opacity(0.3)
                : Color.gray.opacity(0.3)
              )
              .cornerRadius(5)
          }
          .onHover { hover in
            isButtonHovering = hover
          }
          .buttonStyle(PlainButtonStyle())
          .padding(4)
        }
      }
    }
  }

}
import SwiftUI

@ToolbarContentBuilder
func CoverLetterToolbar(
  buttons: Binding<CoverLetterButtons>,
  refresh: Binding<Bool>

) -> some ToolbarContent {
  ToolbarItem(placement: .automatic) {
    CoverLetterAiView(
      buttons: buttons,
      refresh: refresh
    ).onAppear{print("foo")}

  }
  ToolbarItem(placement: .automatic) {
    Button(action: {
      buttons.wrappedValue.showInspector.toggle()
    }) {
      Label("Toggle Inspector", systemImage: "sidebar.right")
    }.onAppear{print("Toolbar Cover Letter")}
  }
}
import SwiftUI

struct CoverRefView: View {
  @Environment(CoverRefStore.self) var coverRefStore: CoverRefStore
  @Environment(CoverLetterStore.self) var coverLetterStore: CoverLetterStore

  var body: some View {
    // Only show the wrapped view if we have a cL
    if let letter = coverLetterStore.cL {
      CoverRefViewWrapped(coverRefStore: coverRefStore, cL: letter)
    }
  }
}

struct CoverRefViewWrapped: View {
  @Environment(CoverLetterStore.self) var coverLetterStore: CoverLetterStore

  // Using `@Bindable` from SwiftData/SwiftUI so that
  // we can do `$coverRefStore` updates if needed.
  @Bindable var coverRefStore: CoverRefStore
  @Bindable var cL: CoverLetter

  @State private var showAddBackgroundFactSheet = false
  @State private var showAddWritingSampleSheet = false

  var body: some View {
    List {
      // ======= Background section =======
      Text("Resume Background Documents")
        .font(.headline)
        .foregroundColor(.primary)
        .padding(.vertical, 5)
        .background(Color.clear)

      // Instead of directly binding to $cL.includeResumeRefs,
      // use a custom Binding that either:
      // (a) sets `cL.includeResumeRefs` if `generated == false`
      // (b) or creates a new cL with `includeResumeRefs` changed
      Toggle(isOn: includeResumeBinding) {
        Text("Include Resume Background")
      }

      Text("Cover Letter Background Facts")
        .font(.headline)
        .foregroundColor(.primary)
        .padding(.vertical, 5)
        .background(Color.clear)
        .sheet(isPresented: $showAddBackgroundFactSheet) {
          AddCoverRefForm(
            coverRefStore: coverRefStore,
            type: .backgroundFact,
            cL: cL,
            showMe: $showAddBackgroundFactSheet
          )
        }

      // Show existing background facts
      ForEach(coverRefStore.backgroundFacts, id: \.id) { fact in
        RefRow(
          cL: cL,
          element: fact,
          coverRefStore: coverRefStore,
          showPreview: true
        )
        .listRowBackground(Color.clear)
      }

      Button(action: {
        showAddBackgroundFactSheet.toggle()
      }) {
        Label("Add Background Fact", systemImage: "plus")
      }
      .listRowBackground(Color.clear)

      // ======= Writing Samples section =======
      Text("Writing Samples")
        .font(.headline)
        .foregroundColor(.primary)
        .padding(.vertical, 5)
        .background(Color.clear)
        .sheet(isPresented: $showAddWritingSampleSheet) {
          AddCoverRefForm(
            coverRefStore: coverRefStore,
            type: .writingSample,
            cL: cL,
            showMe: $showAddWritingSampleSheet
          )
        }

      ForEach(coverRefStore.writingSamples, id: \.id) { sample in
        RefRow(
          cL: cL,
          element: sample,
          coverRefStore: coverRefStore,
          showPreview: false
        )
        .listRowBackground(Color.clear)
      }

      Button(action: {
        showAddWritingSampleSheet.toggle()
      }) {
        Label("Add Writing Sample", systemImage: "plus")
      }
      .listRowBackground(Color.clear)
    }
    // If you want a plain look
    .listStyle(PlainListStyle())
    .scrollContentBackground(.hidden)
    .background(Color.clear)
  }

  // MARK: - Custom Binding for `includeResumeRefs`
  private var includeResumeBinding: Binding<Bool> {
    Binding<Bool>(
      get: { cL.includeResumeRefs },
      set: { newValue in
        guard let oldCL = coverLetterStore.cL else { return }
        if oldCL.generated {
          // If it's generated, create a *new* copy with updated value
          let newCL = coverLetterStore.createDuplicate(letter: oldCL)
          newCL.includeResumeRefs = newValue
          coverLetterStore.cL = newCL
        } else {
          // Otherwise, just mutate the existing cL
          cL.includeResumeRefs = newValue
        }
      }
    )
  }
}
import SwiftUI

struct CoverLetterView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(CoverRefStore.self) private var coverRefStore: CoverRefStore
  @Environment(CoverLetterStore.self) private var coverLetterStore:
    CoverLetterStore

  @Binding var buttons: CoverLetterButtons
  @State private var selectedInspectorTab: InspectorTab = .references  // State to manage selected tab

  var body: some View {
    contentView()
  }

  @ViewBuilder
  private func contentView() -> some View {
    @Bindable var coverLetterStore = coverLetterStore
    @Bindable var jobAppStore = jobAppStore

    if let jobApp = $jobAppStore.wrappedValue.selectedApp,
      let res = jobApp.selectedRes
    {

      let resBinding = Binding(
        get: { res },
        set: { jobApp.selectedRes = $0 }
      )

      VStack {
        CoverLetterContentView(
          res: resBinding,
          jobApp: jobApp,
          buttons: $buttons
        )
      }
      .inspector(isPresented: $buttons.showInspector) {
        if $coverLetterStore.wrappedValue.cL != nil {
          VStack(alignment: .leading) {
            // Segmented Picker without a label for switching between "References" and "Revisions"
            Picker("", selection: $selectedInspectorTab) {
              Text("References").tag(InspectorTab.references)
              Text("Revisions").tag(InspectorTab.revisions)
            }
            .pickerStyle(SegmentedPickerStyle())  // Segmented control style

            // Conditionally display content based on the selected tab
            switch selectedInspectorTab {
            case .references:
              CoverRefView(
              )
            case .revisions:
              CoverRevisionsView(
                buttons: $buttons
              )  // Placeholder for your yet-to-be-written Revisions panel
            }
          }
          .frame(maxHeight: .infinity, alignment: .top)  // Ensure the content aligns at the top
          .padding()  // Optional padding
        } else {
          EmptyView()
        }
      }
    } else {
      Text(
        jobAppStore.selectedApp?.selectedRes == nil
          ? "job app nil" : "No nil fail"
      )
      .onAppear {
        if jobAppStore.selectedApp == nil {
          print("no job app")
        } else if jobAppStore.selectedApp?.selectedRes == nil {
          print("no resume")
        }
      }
    }
  }
}

// Enum to manage the tab selection
enum InspectorTab {
  case references
  case revisions
}

// Placeholder for the Revisions view (to be written)

struct CoverLetterContentView: View {
  @Environment(CoverRefStore.self) private var coverRefStore: CoverRefStore
  @Environment(CoverLetterStore.self) private var coverLetterStore:
    CoverLetterStore
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Binding var res: Resume
  @Bindable var jobApp: JobApp
  @Binding var buttons: CoverLetterButtons

  var body: some View {
    @Bindable var coverLetterStore = coverLetterStore
    @Bindable var jobAppStore = jobAppStore
    @Bindable var bindStore = jobAppStore
    if let app = jobAppStore.selectedApp,
      let cL = jobAppStore.selectedApp?.selectedCover
    {
      @Bindable var bindApp = app
      VStack {
        HStack {
          Picker(
            "Load existing cover letter",
            selection: Binding(
              get: {  bindApp.selectedCover },
              set: { newCoverLetter in
                bindApp.selectedCover = newCoverLetter
              }
            )
          ) {
            ForEach(
              app.coverLetters.sorted(by: { $0.moddedDate < $1.moddedDate }),
              id: \.id
            ) { letter in
              if letter.generated {
                Text("Generated at \(letter.modDate)")
                  .tag(letter as CoverLetter?)
              }
              else {
                Text("Ungenerated draft").tag(letter as CoverLetter?)
              }
            }
          }.padding()
          if $buttons.wrappedValue.runRequested {
            ProgressView()
          } else {
            EmptyView()
          }
        }
        Text("AI generated text at \(cL.modDate)")
          .font(.caption)
          .italic()

        // ScrollView that occupies all available vertical space
        if (cL.generated) {

          ScrollView {
            Text(cL.content)
              .font(.body)
              .padding()
          }
          .frame(maxHeight: .infinity)  // Make the ScrollView fill the available vertical space
          .id(cL.id)  // Force SwiftUI to recognize content change

          .onChange(of: bindApp.selectedCover) {
            oldval, newCover in
            print("Cover letter changed to: \(newCover?.modDate ?? "None")")
          }
        }
        else {
          EmptyView()
          Spacer().frame(maxHeight: .infinity)
        }
      }
    }
    else {
      EmptyView()
    }
  }
}
import SwiftUI

struct AddCoverRefForm: View {
  @Bindable var coverRefStore: CoverRefStore
  @State private var newCoverRefName = ""
  @State private var newCoverRefContent = ""
  @State private var newCoverRefEnabledByDefault = true
  @State private var isTargeted: Bool = false

  var type: CoverRefType
  @Bindable var cL: CoverLetter
  @Binding var showMe: Bool
  @FocusState var isFocused: Bool

  var body: some View {
    Form {
      TextField("Name", text: $newCoverRefName)
      TextEditor(text: $newCoverRefContent)
        .padding(5)
        .focusable(true)      // (1) Mark it focusable on macOS
        .focused($isFocused)
        .onTapGesture { isFocused = true }
        .onChange(of: isFocused) { print("isFocused changed to:", isFocused) }
        .frame(maxWidth: .infinity, minHeight: 200)
        .overlay(
          RoundedRectangle(cornerRadius: 6)
            .stroke(
              ( isTargeted || isFocused ) ? .blue : .secondary,
              lineWidth: ( isTargeted || isFocused ) ? 2 : 0.25
            )
        )
      Toggle("Enabled by Default", isOn: $newCoverRefEnabledByDefault)

      HStack {
        Button("Add") {
          saveForm()
          resetForm()
          dismissForm()
        }
        .keyboardShortcut(.defaultAction)
        Button("Cancel") {
          dismissForm()
        }
        .keyboardShortcut(.cancelAction)
      }
      .padding(.top)
    }
    .padding()
    .frame(minWidth: 400, maxWidth: 600)
//    .navigationTitle("Add \(type == .backgroundFact ? "Background Fact" : "Writing Sample")")
    .onDrop(of: ["public.file-url"], isTargeted: $isTargeted) { providers in handleOnDrop(providers: providers) }
    .onChange(of: isTargeted) { print("isTargeted:", isTargeted) }
  }
  private func saveForm() {
    let newCoverRef = CoverRef(
      name: self.newCoverRefName,
      content: self.newCoverRefContent,
      enabledByDefault: self.newCoverRefEnabledByDefault,
      type: self.type
    )

//    if self.type == .backgroundFact {
//      coverRefStore.append(newCoverRef)
//    } else if self.type == .writingSample {
//      self.writingSamples.append(newCoverRef)
//    }
    
    let newRef = coverRefStore.addCoverRef(newCoverRef)

      cL.enabledRefs.append(newRef)
    
  }
   func handleOnDrop(providers: [NSItemProvider]) -> Bool {
    for provider in providers {
      if provider.hasItemConformingToTypeIdentifier("public.file-url") {
        provider.loadItem(forTypeIdentifier: "public.file-url", options: nil) { item, error in
          guard let urlData = item as? Data,
                let url = URL(dataRepresentation: urlData, relativeTo: nil) else {
            return
          }

          // Extract the file name
          let fileName = url.deletingPathExtension().lastPathComponent

          // Read the file contents
          do {
            let text = try String(contentsOf: url, encoding: .utf8)

              self.newCoverRefName = fileName
              self.newCoverRefContent = text
            self.self.newCoverRefEnabledByDefault = true
              saveForm()

          } catch {
            print("Error reading file: \(error.localizedDescription)")
          }
        }

        // If we handle a valid file drop, return true
        continue
      }
      else {

        return false
      }
    }
   resetForm()
   dismissForm()
    return true
  }






  private func resetForm() {
    newCoverRefName = ""
    newCoverRefContent = ""
    newCoverRefEnabledByDefault = true
  }

  private func dismissForm() {
    showMe = false
  }
}
//
//  RevisionsView.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/14/24.
//

import SwiftOpenAI
import SwiftUI

struct CoverRevisionsView: View {
  @AppStorage("openAiApiKey") var openAiApiKey: String = "none"
  @Binding var buttons: CoverLetterButtons

  var body: some View {

    RevisionsViewContent(
      service: OpenAIServiceFactory.service(
        apiKey: openAiApiKey, debugEnabled: false),
      buttons: $buttons
    )
    .onAppear { print("Ai Cover Letterv2") }

  }
}
struct RevisionsViewContent: View {
  @Environment(CoverLetterStore.self) private var coverLetterStore: CoverLetterStore
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @State var tempMode: CoverLetterPrompts.EditorPrompts = .zissner
  @State var aiMode: CoverAiMode = .none
  @State private var customFeedback: String = ""
  @Binding var buttons: CoverLetterButtons
  let service: OpenAIService

  // Use @Bindable for chatProvider
  @Bindable var chatProvider: CoverChatProvider

  init(
    service: OpenAIService,
    buttons: Binding<CoverLetterButtons>
  ) {
    self.service = service
    self._buttons = buttons
    self.chatProvider = CoverChatProvider(service: service)
  }

  var body: some View {
    VStack {
      Picker("", selection: $tempMode) {
        ForEach(CoverLetterPrompts.EditorPrompts.allCases, id: \.self) { status in
          Text(String(describing: status).capitalized)  // Using the enum case name instead of raw value
            .tag(status)
        }
      }
      .pickerStyle(SegmentedPickerStyle())

      // Conditionally show the text input box
      if tempMode == .custom {  // Assuming .custom is one of the enum cases
        TextField("Revision Feedback", text: $customFeedback) // Binding variable for text
          .textFieldStyle(RoundedBorderTextFieldStyle())
          .padding()
      }

      if !$buttons.wrappedValue.runRequested {
        Button((tempMode == .custom ) ? "Revise" : "Rewrite") {
          rewriteBut(
            coverLetterStore: coverLetterStore,
            jobAppStore: jobAppStore,
            chatProvider: chatProvider,
            buttons: $buttons,
            customFeedback: $customFeedback
          )
        }
      }
        else {
        ProgressView()
      }
    }
  }

  // Add a binding variable for the text field
  func rewriteBut(
    coverLetterStore: CoverLetterStore,
    jobAppStore: JobAppStore,
    chatProvider: CoverChatProvider,
    buttons: Binding<CoverLetterButtons>,
    customFeedback: Binding<String>
  ) {
    
    let oldContent = jobAppStore.selectedApp!.selectedCover!.content
    var newCL = coverLetterStore.createDuplicate(
      letter: jobAppStore.selectedApp!.selectedCover!
    )
    jobAppStore.selectedApp!.selectedCover = newCL  // Assign new instance\
    jobAppStore.selectedApp!.selectedCover!.currentMode = ((tempMode == .custom) ? .revise : .rewrite)
    jobAppStore.selectedApp!.selectedCover!.content = oldContent
    jobAppStore.selectedApp!.selectedCover!.editorPrompt = tempMode
    print("revise cover letter")
    chatProvider.coverChatRevise(
      res: jobAppStore.selectedApp!.selectedRes,
      jobAppStore: jobAppStore,
      chatProvider: chatProvider,
      buttons: buttons,
      customFeedback: customFeedback
    )
  }
}
import SwiftData
import SwiftUI

struct JobAppDetailView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore  // Explicit
  @Binding var tab: TabList
  @Binding var buttons: SaveButtons
  @State private var showingDeleteConfirmation: Bool = false

  var body: some View {
    ScrollView {
      let form = jobAppStore.form
      if let selectedApp = jobAppStore.selectedApp {
        VStack {
          HeaderView(
            showingDeleteConfirmation: $showingDeleteConfirmation, buttons: $buttons, tab: $tab)

          JobAppPostingDetailsSection(buttons: $buttons)

          JobAppDescriptionSection(buttons: $buttons)

          JobAppInformationSection(buttons: $buttons)

          ApplySection(buttons: $buttons)
        }
        .padding(.horizontal).padding(.vertical)
//        .navigationTitle(
//          buttons.edit
//            ? "Editing \(form.job_position) at \(form.company_name)"
//            : "\(selectedApp.job_position) at \(selectedApp.company_name)"
//        )
        .onChange(of: buttons.edit) { oldValue, newValue in
          if newValue {
            jobAppStore.editWithForm()
          }
        }
        .onChange(of: buttons.cancel) { oldValue, newValue in
          if newValue && buttons.edit {
            jobAppStore.cancelFormEdit()  // revert changes
            buttons.edit = false
            buttons.cancel = false
          }
        }
        .onChange(of: buttons.save) { oldValue, newValue in
          if newValue && buttons.edit {
            jobAppStore.saveForm()

            buttons.edit = false
            buttons.save = false
          }
        }
      } else {
        Text("No job application selected")
          .padding()
      }
    }
  }
}
import SwiftUI

//func binding(for optionalString: Binding<String?>, default value: String = "")
//-> Binding<String>
//{
//    return Binding<String>(
//        get: { optionalString.wrappedValue ?? value },
//        set: { newValue in
//            optionalString.wrappedValue = newValue.isEmpty ? nil : newValue
//        }
//    )
//}

struct JobAppPostingDetailsSection: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore  // Explicit type
  @Binding var buttons: SaveButtons

  var body: some View {
    Section {
      Cell(
        leading: "Job Position", trailingKeys: \JobApp.job_position,
        formTrailingKeys: \JobAppForm.job_position, isEditing: $buttons.edit)
      Cell(
        leading: "Job Location", trailingKeys: \JobApp.job_location,
        formTrailingKeys: \JobAppForm.job_location, isEditing: $buttons.edit)
      Cell(
        leading: "Company Name", trailingKeys: \JobApp.company_name,
        formTrailingKeys: \JobAppForm.company_name, isEditing: $buttons.edit)
      Cell(
        leading: "Company LinkedIn ID", trailingKeys: \JobApp.company_linkedin_id,
        formTrailingKeys: \JobAppForm.company_linkedin_id, isEditing: $buttons.edit)
      Cell (
        leading: "Posting URL", trailingKeys: \JobApp.posting_url,
        formTrailingKeys: \JobAppForm.posting_url, isEditing: $buttons.edit)
      Cell(
        leading: "Job Posting Time", trailingKeys: \JobApp.job_posting_time,
        formTrailingKeys: \JobAppForm.job_posting_time, isEditing: $buttons.edit)
    }
    .insetGroupedStyle(header: Text("Posting Details"))
  }
}
import Foundation
import SwiftUI

struct NewAppSheetView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(\.dismiss) private var dismiss

  @AppStorage("scrapingDogApiKey") var scrapingDogApiKey: String = "none"
  @AppStorage("brightDataApiKey") var brightDataApiKey: String = "none"

  @AppStorage("preferredApi") var preferredApi: apis  = .scrapingDog

  @State private var isLoading: Bool = false
  @State private var urlText: String = ""
  @State private var delayed: Bool = false
  @State private var verydelayed: Bool = false

  @Binding var isPresented: Bool

  var body: some View {
    VStack {
      if isLoading {
        VStack {
          ProgressView("Fetching job details...")
            .progressViewStyle(CircularProgressViewStyle())
            .padding()
          if delayed {
            Text("Fetch results not ready. Trying again in 10s").font(.caption)
          }
          if verydelayed {
            Text("Something suss going on with scraper. Trying again in 200s").font(.caption)
          }
        }
      } else {
        Text("Enter LinkedIn Job URL")
        TextField(
          "https://www.linkedin.com/jobs/view/3951765732", text: $urlText
        )
        .textFieldStyle(RoundedBorderTextFieldStyle())
        .padding()

        HStack {
          Button("Cancel") {
            isPresented = false
          }
          Spacer()
          Button("Scrape URL") {
            Task {
              await handleNewApp()
            }
          }
        }
      }
    }
    .padding()
  }

  private func handleNewApp() async {
    if let url = URL(string: urlText) {
      switch url.host {
        case "www.linkedin.com":
          isLoading = true
          if(preferredApi == .scrapingDog) {
            print("linkedin")
            if let jobID = url.pathComponents.last {
              await ScrapingDogfetchLinkedInJobDetails(jobID: jobID, posting_url: url)
            }
          }
          if (preferredApi == .brightData) {
            print("brightData Linked in")
            await BrightDatafetchLinkedInJobDetails(posting_url: url)
          }
        case "jobs.apple.com":
          isLoading = true
          Task {
            do {
              let htmlContent = try await JobApp.fetchHTMLContent(from: urlText)
              JobApp.parseAppleJobListing(
                jobAppStore: jobAppStore, html: htmlContent, url: urlText)
              if let jobApp = jobAppStore.selectedApp {
                // Now you can access the extracted data from jobApp
                print("Job Position: \(jobApp.job_position)")
                print("Job Location: \(jobApp.job_location)")
                print("Company Name: \(jobApp.company_name)")
                print("Job Posting Time: \(jobApp.job_posting_time)")
                print("Job Description: \(jobApp.job_description)")
                print("Job Function: \(jobApp.job_function)")

              }
              isLoading = false
              isPresented = false
            } catch {
              print("Error fetching HTML content: \(error)")

            }
          }
          print("apple")
        default:
          print("only apple and linked in are supported")
      }
      return
    }

  }

  private func ScrapingDogfetchLinkedInJobDetails(jobID: String, posting_url: URL) async {
    let apiKey = scrapingDogApiKey
    let requestURL =
    "https://api.scrapingdog.com/linkedinjobs?api_key=\(apiKey)&job_id=\(jobID)"

    guard let url = URL(string: requestURL) else { return }

    do {
      print(requestURL)
      let (data, response) = try await URLSession.shared.data(from: url)

      if let httpResponse = response as? HTTPURLResponse,
         httpResponse.statusCode != 200
      {
        // Handle HTTP error (non-200 status code)
        print("HTTP error: \(httpResponse.statusCode)")
        isLoading = false
        return
      }

      let jobDetails = try JSONDecoder().decode([JobApp].self, from: data)
      if let jobDetail = jobDetails.first {
        jobDetail.posting_url = posting_url.absoluteString
        jobAppStore.selectedApp = jobAppStore.addJobApp(jobDetail)
        isPresented = false
      }
    } catch {
      // Handle network or decoding error
      print("Error: \(error)")
    }

    isLoading = false
  }
  private func BrightDatafetchLinkedInJobDetails(posting_url: URL) async {
    let apiKey = brightDataApiKey
    let requestURL_string = "https://api.brightdata.com/datasets/v3/trigger?dataset_id=gd_lpfll7v5hcqtkxl6l"

    guard let requestUrl = URL(string: requestURL_string) else { return }

    // Create the URLRequest
    var request = URLRequest(url: requestUrl)
    request.httpMethod = "POST"

    // Set the headers
    request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")

    // The job URL you have as a starting point
    let payload = [
      ["url": posting_url.absoluteString]
    ]

    do {
      // Serialize the payload to JSON data
      let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
      request.httpBody = jsonData

      // Perform the request
      let (data, response) = try await URLSession.shared.data(for: request)

      // Check the HTTP response status
      guard let httpResponse = response as? HTTPURLResponse else {
        print("Invalid response")
        isLoading = false
        isPresented = false

        return
      }

      if httpResponse.statusCode == 200 {
        // Parse the response to get the snapshot_id
        if let jsonObject = try? JSONSerialization.jsonObject(with: data, options: []),
           let jsonDict = jsonObject as? [String: Any],
           let snapshotId = jsonDict["snapshot_id"] as? String {

          print("Received snapshot_id: \(snapshotId)")

          // Wait for the data to be ready (optional, depending on API behavior)
          try await Task.sleep(nanoseconds: 5 * 1_000_000_000) // Sleep for 5 seconds

          // Second Request: Retrieve the snapshot data
          try await fetchSnapshotData(snapshotId: snapshotId, posting_url: posting_url)

        } else {
          isLoading = false
          isPresented = false

          print("Failed to parse snapshot_id from response")
        }
      } else {
        // Handle HTTP error
        isLoading = false
        isPresented = false

        print("HTTP error: \(httpResponse.statusCode)")
        if let responseBody = String(data: data, encoding: .utf8) {
          print("Response body: \(responseBody)")
        }
      }
    } catch {
      // Handle errors (e.g., serialization, network errors)
      isLoading = false
      isPresented = false

      print("Error during first request: \(error.localizedDescription)")
    }
    isLoading = false
  }

  func fetchSnapshotData(snapshotId: String, posting_url: URL) async throws {
    // Construct the request URL for the snapshot
    let snapshotURLString = "https://api.brightdata.com/datasets/v3/snapshot/\(snapshotId)?format=json"
    guard let snapshotURL = URL(string: snapshotURLString) else {
      print("Invalid snapshot URL")
      return
    }

    // Create the URLRequest
    var snapshotRequest = URLRequest(url: snapshotURL)
    snapshotRequest.httpMethod = "GET"

    // Set the Authorization header
    snapshotRequest.setValue("Bearer \(brightDataApiKey)", forHTTPHeaderField: "Authorization")

    // Initialize a retry counter
    var retryCount = 0
    let maxRetries = 2

    var snapshotData: Data?
    var httpResponse: HTTPURLResponse?

    repeat {
      // Perform the snapshot request
      let (data, response) = try await URLSession.shared.data(for: snapshotRequest)

      // Check the HTTP response status
      guard let responseHttp = response as? HTTPURLResponse else {
        print("Invalid snapshot response")
        return
      }
      httpResponse = responseHttp
      snapshotData = data

      if httpResponse?.statusCode == 202 {
        // Data not ready, wait and retry
        if retryCount < 1 {
          print("Snapshot not ready (HTTP 202), waiting 10 seconds before retrying...")
          delayed = true
          try await Task.sleep(nanoseconds: 10 * 1_000_000_000) // Sleep for 10 seconds
          retryCount += 1

        }
        else if (retryCount < maxRetries){
          print("Snapshot still not ready (HTTP 202), waiting 10 seconds before retrying...")
          delayed = false
          verydelayed = true
          try await Task.sleep(nanoseconds: 200 * 1_000_000_000) // Sleep for 10 seconds

        }
          else {
          print("Snapshot not ready after retries")
          isLoading = false
          // Optionally, you can throw an error or handle it as needed
          return
        }
      } else {
        delayed = false
        // Exit the loop if status code is not 202
        break
      }
    } while retryCount <= maxRetries

    if httpResponse?.statusCode == 200, let data = snapshotData {
      // Process the snapshot data
      if let jobDetail = JobApp.parseBrightDataJobApp(jobAppStore: jobAppStore, jsonData: data) {
        print("parsed BrightData!")
      }
      else {
        print("parsing error :(")
      }
      isLoading = false
      isPresented = false


    } else {
      // Handle HTTP error
      isLoading = false
      if let statusCode = httpResponse?.statusCode {
        print("HTTP error during snapshot request: \(statusCode)")
      } else {
        print("Unknown HTTP error during snapshot request")
      }
      if let data = snapshotData, let responseBody = String(data: data, encoding: .utf8) {
        print("Response body: \(responseBody)")
      }
    }
  }
}
import SwiftUI

struct ApplySection: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Binding var buttons: SaveButtons

  var body: some View {
    Section {
      Cell(
        leading: "Job Apply Link", trailingKeys: \JobApp.job_apply_link,
        formTrailingKeys: \JobAppForm.job_apply_link, isEditing: $buttons.edit)
    }
    .insetGroupedStyle(header: Text("Apply"))
  }
}
import SwiftData
import SwiftUI

struct JobAppDescriptionSection: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Binding var buttons: SaveButtons

  var body: some View {
    if let selApp = jobAppStore.selectedApp {
      @Bindable var boundSelApp = selApp
      Section {
        if buttons.edit {
          TextField("", text: $boundSelApp.job_description, axis: .vertical)
            .lineLimit(15...20)
            .padding(.all, 3)
        } else {
          Text(boundSelApp.job_description.isEmpty ? "none listed" : boundSelApp.job_description)
            .padding(.all, 3)
            .foregroundColor(.secondary)
            .italic(boundSelApp.job_description.isEmpty)
        }
      }
      .insetGroupedStyle(header: Text("Job Description"))
    } else {
      // Handle the case where selectedApp is nil
      Text("No job application selected.")
        .padding()
    }
  }
}
import SwiftData
import SwiftUI

struct HeaderView: View {
  @Binding var showingDeleteConfirmation: Bool
  @Binding var buttons: SaveButtons
  @Binding var tab: TabList
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore  // Explicit type

  var body: some View {
    HStack {
      Spacer()
      if buttons.edit {
        Button {
          showingDeleteConfirmation = true
        } label: {
          Label("Delete Job Application", systemImage: "trash")
            .padding(5)
            .foregroundColor(.red)
        }
        .buttonStyle(.plain)
        .confirmationDialog(
          "Are you sure you want to delete this job application?",
          isPresented: $showingDeleteConfirmation,
          titleVisibility: .visible
        ) {
          Button("Delete", role: .destructive) {
            buttons.edit = false
            jobAppStore.deleteSelected()
            tab = TabList.none
          }
          Button("Cancel", role: .cancel) {
            // Just dismiss the dialog
          }
        }
      }
    }
    .padding(.vertical, 0)
  }
}
import SwiftUI

struct JobAppInformationSection: View {

  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @State private var isHovered: Bool = false
  @Binding var buttons: SaveButtons

  var body: some View {
    Section {

      Cell(
        leading: "Seniority Level", trailingKeys: \JobApp.seniority_level,
        formTrailingKeys: \JobAppForm.seniority_level, isEditing: $buttons.edit)
      Cell(
        leading: "Employment Type", trailingKeys: \JobApp.employment_type,
        formTrailingKeys: \JobAppForm.employment_type, isEditing: $buttons.edit)
      Cell(
        leading: "Job Function", trailingKeys: \JobApp.job_function,
        formTrailingKeys: \JobAppForm.job_function, isEditing: $buttons.edit)
      Cell(
        leading: "Industries", trailingKeys: \JobApp.industries,
        formTrailingKeys: \JobAppForm.industries, isEditing: $buttons.edit)
    }
    .insetGroupedStyle(header: Text("Job Information"))
  }
}
import SwiftUI

struct BuildToolbar: ToolbarContent {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(ResStore.self) private var resStore: ResStore
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore

  @State var attention: Int = 2

  @Binding var selectedTab: TabList
  @State var saveIsHovering: Bool = false
  @Binding var listingButtons: SaveButtons
  @Binding var letterButtons: CoverLetterButtons
  @Binding var refresh: Bool

  var body: some ToolbarContent {
    if let selApp = jobAppStore.selectedApp {

      // Use individual toolbar item functions
      ToolbarItem(placement: .navigation) {
        selApp.statusTag
      }

      twoTierTextToolbar(
        headline: selApp.job_position,
        caption: selApp.company_name
      )

      // Always show resumePicker regardless of selectedTab
      if selApp.selectedRes != nil {
        resumePicker(selectedApp: selApp)
      }
      @Bindable var selApp = selApp
      // Toolbar content specific to the selected tab
      toolbarContent(for: selectedTab, selRes: $selApp.selectedRes, selApp: selApp)
    }
  }

  @ToolbarContentBuilder
  func toolbarContent(for tab: TabList, selRes: Binding<Resume?>, selApp: JobApp) -> some ToolbarContent {
    switch tab {
      case .listing:
        listingToolbarItem()
      case .resume:
        resumeToolbarContent(selRes: selRes, selectedApp: jobAppStore.selectedApp, attention: $attention)
      case .coverLetter:
        if let _ = selApp.selectedCover {
          CoverLetterToolbar(buttons: $letterButtons, refresh: $refresh)
        } else {
          ToolbarItem { Text("No Cover Letter Available") } // Handle case where cover letter is nil
        }
      case .submitApp, .none:
        emptyToolbarItem()
    }
  }

  func twoTierTextToolbar(
    headline: String, caption: String,
    alignment: HorizontalAlignment = .leading
  ) -> some ToolbarContent {
    ToolbarItem(placement: .navigation) {
      VStack(alignment: alignment) {
        Text(headline).font(.headline)
        Text(caption).lineLimit(1).font(.caption)
      }
    }
  }

  func saveButton() -> ToolbarItem<Void, some View> {
    ToolbarItem(placement: .primaryAction) {
      Button(action: {
        print("Save button pressed")
        listingButtons.save.toggle()
      }) {
        Image(systemName: "checkmark.circle")
          .font(.system(size: 40, weight: .light))
          .foregroundColor(saveIsHovering ? .accentColor : .primary)
          .onHover { hovering in
            saveIsHovering = hovering
          }
      }
      .help("Save changes")
    }
  }

  func toggleEditButton() -> ToolbarItem<Void, some View> {
    ToolbarItem(placement: .automatic) {
      Button(action: {
        listingButtons.edit.toggle()
        print("Edit button toggled")
      }) {
        Image(systemName: "pencil.and.list.clipboard")
          .font(.system(size: 20, weight: .light))
          .foregroundColor(listingButtons.edit ? .accentColor : .primary)
      }
      .applyConditionalButtonStyle(editMode: listingButtons.edit)
      .help("Edit job listing")
    }
  }

  @ToolbarContentBuilder
  func listingToolbarItem() -> some ToolbarContent {
    if listingButtons.edit {
      saveButton()
    }
    toggleEditButton()
  }

  @ToolbarContentBuilder
  func resumePicker(selectedApp: JobApp) -> some ToolbarContent {
    @Bindable var selectedApp = selectedApp
    ToolbarItemGroup(placement: .automatic) {
      Spacer()
      Picker(
        "Load existing résumé draft",
        selection: $selectedApp.selectedRes
      ) {
        Text("None").tag(nil as Resume?)
        ForEach(selectedApp.resumes, id: \.self) { resume in
          Text("Created at \(resume.createdDateString)")
            .tag(Optional(resume) as Resume?)
            .help("Select a resume to customize")
        }
      }
      .frame(maxHeight: .infinity, alignment: .trailing)
      .onChange(of: selectedApp.selectedRes){oldValue, newValue in $refresh.wrappedValue.toggle()}
    }
  }

  struct NoHoverButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
      configuration.label
        .contentShape(Rectangle())
        .background(
          configuration.isPressed ? Color.gray.opacity(0.2) : Color.clear
        )
    }
  }
}

extension View {
  func applyConditionalButtonStyle(editMode: Bool) -> some View {
    if editMode {
      return AnyView(self.buttonStyle(BuildToolbar.NoHoverButtonStyle()))
    } else {
      return AnyView(self.buttonStyle(PlainButtonStyle()))
    }
  }
}

func emptyToolbarItem() -> some ToolbarContent {
  ToolbarItem(placement: .automatic) {
    Spacer()
  }
}

func buildToolbar(
  selectedTab: Binding<TabList>,
  listingButtons: Binding<SaveButtons>,
  letterButtons: Binding<CoverLetterButtons>,
  refresh: Binding<Bool>
) -> some ToolbarContent {
  BuildToolbar(
    selectedTab: selectedTab,
    listingButtons: listingButtons,
    letterButtons: letterButtons,
    refresh: refresh
  )
}
import SwiftUI
enum apis: String, Identifiable, CaseIterable {
  var id: Self { self }
  case scrapingDog = "Scraping Dog"
  case brightData  = "Bright Data"
}


struct SettingsView: View {
  @AppStorage("scrapingDogApiKey") var scrapingDogApiKey: String = "none"
  @AppStorage("openAiApiKey") var openAiApiKey: String = "none"
  @AppStorage("brightDataApiKey") var brightDataApiKey: String = "none"
  @AppStorage("preferredApi") var preferredApi: apis  = .scrapingDog


  @State private var isEditingScrapingDog = false
  @State private var isEditingBrightData = false
  @State private var isEditingOpenAI = false

  @State private var editedScrapingDogApiKey = ""
  @State private var editedOpenAiApiKey = ""
  @State private var editedBrightDataApiKey = ""

  @State private var isHoveringCheckmark = false
  @State private var isHoveringXmark = false



  var body: some View {
    VStack(alignment: .leading, spacing: 10) {  // Reduced spacing between label and table
      Text("API Keys")
        .font(.headline)
        .padding(.bottom, 5)  // Slightly smaller padding for tighter layout

      VStack(spacing: 0) {
        apiKeyRow(
          label: "Scraping Dog",
          icon: "dog.fill",
          value: $scrapingDogApiKey,
          isEditing: $isEditingScrapingDog,
          editedValue: $editedScrapingDogApiKey,
          isHoveringCheckmark: $isHoveringCheckmark,
          isHoveringXmark: $isHoveringXmark
        )
        Rectangle()
          .fill(Color.gray.opacity(0.5))
          .frame(height: 0.5)  // Thinner separator
          .edgesIgnoringSafeArea(.horizontal)  // Extend to edges
        apiKeyRow(
          label: "OpenAI",
          icon: "sparkles",
          value: $openAiApiKey,
          isEditing: $isEditingOpenAI,
          editedValue: $editedOpenAiApiKey,
          isHoveringCheckmark: $isHoveringCheckmark,
          isHoveringXmark: $isHoveringXmark
        )
        Rectangle()
          .fill(Color.gray.opacity(0.5))
          .frame(height: 0.5)  // Thinner separator
          .edgesIgnoringSafeArea(.horizontal)  // Extend to edges
        apiKeyRow(
          label: "Bright Data",
          icon: "sun.max",
          value: $brightDataApiKey,
          isEditing: $isEditingBrightData,
          editedValue: $editedBrightDataApiKey,
          isHoveringCheckmark: $isHoveringCheckmark,
          isHoveringXmark: $isHoveringXmark
        )


      } .padding(10)
        .background(Color(NSColor.windowBackgroundColor).opacity(0.9))
        .cornerRadius(8)
        .overlay(
          RoundedRectangle(cornerRadius: 8)
            .stroke(Color.gray.opacity(0.7), lineWidth: 1)  // Hardcoded border color
        )

      Spacer()
      Picker("Preferred API", selection: $preferredApi) {
        ForEach(apis.allCases) { api in
          Text(api.rawValue)
        }
      }
      .pickerStyle(.radioGroup)

      }
    .padding()
    .frame(width: 400, height: 250)
  }

  @ViewBuilder
  private func apiKeyRow(
    label: String, icon: String, value: Binding<String>, isEditing: Binding<Bool>,
    editedValue: Binding<String>, isHoveringCheckmark: Binding<Bool>, isHoveringXmark: Binding<Bool>
  ) -> some View {
    HStack {
      HStack {
        Image(systemName: icon)
        Text(label)
          .fontWeight(.medium)
          .foregroundColor(.black)
      }
      Spacer()

      if isEditing.wrappedValue {
        HStack {
          TextField("Enter API Key", text: editedValue)
            .textFieldStyle(PlainTextFieldStyle())
            .foregroundColor(.gray)

          Button(action: {
            value.wrappedValue = editedValue.wrappedValue
            isEditing.wrappedValue = false
          }) {
            Image(systemName: "checkmark.circle.fill")
              .foregroundColor(isHoveringCheckmark.wrappedValue ? .green : .gray)
          }
          .buttonStyle(BorderlessButtonStyle())
          .onHover { hovering in
            isHoveringCheckmark.wrappedValue = hovering
          }

          Button(action: {
            isEditing.wrappedValue = false
          }) {
            Image(systemName: "xmark.circle.fill")
              .foregroundColor(isHoveringXmark.wrappedValue ? .red : .gray)
          }
          .buttonStyle(BorderlessButtonStyle())
          .onHover { hovering in
            isHoveringXmark.wrappedValue = hovering
          }
        }
        .frame(maxWidth: 200)
      } else {
        HStack {
          Text(value.wrappedValue)
            .italic()
            .foregroundColor(.gray)
            .fontWeight(.light)
          Image(systemName: "square.and.pencil")
            .onTapGesture {
              editedValue.wrappedValue = value.wrappedValue
              isEditing.wrappedValue = true
            }
            .foregroundColor(.gray)
        }
      }
    }
    .padding(.vertical, 8)
  }
}
//
//  ContentViewLaunch.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/31/24.
//

import SwiftUI

struct ContentViewLaunch: View {
  @Environment(\.modelContext) private var modelContext
  var body: some View {
    ContentView(modelContext: modelContext)
  }
}
import SwiftUI

struct TabWrapperView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(ResStore.self) private var resStore: ResStore
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore
  @Environment(CoverRefStore.self) private var coverRefStore: CoverRefStore
  @Environment(CoverLetterStore.self) private var coverLetterStore: CoverLetterStore
  @State var tabRefresh: Bool = false
  @State private var listingButtons: SaveButtons = SaveButtons(edit: false, save: false, cancel: false)
  @State private var selectedTab: TabList = TabList.listing
  @State private var refPopup: Bool = false
  @State private var coverLetterButtons: CoverLetterButtons = CoverLetterButtons(showInspector: true, runRequested: false)

  var body: some View {
    @Bindable var jobAppStore = jobAppStore
    if let jobApp = jobAppStore.selectedApp {
      @Bindable var jobApp = jobApp
      
      
      VStack {
        TabView(selection: $selectedTab) {
          JobAppDetailView(tab: $selectedTab, buttons: $listingButtons)
            .tabItem {
              Label(TabList.listing.rawValue, systemImage: "newspaper")
            }
            .tag(TabList.listing)
          
          ResumeViewSetup(refresh: $tabRefresh, currentTab: selectedTab)
            .tabItem {
              Label(TabList.resume.rawValue, systemImage: "person.crop.rectangle.stack")
            }
            .tag(TabList.resume)
          
          if let _ = jobAppStore.selectedApp {
            
            
            CoverLetterView(buttons: $coverLetterButtons)
              .tabItem {
                Label(TabList.coverLetter.rawValue, systemImage: "person.2.crop.square.stack")
              }
              .tag(TabList.coverLetter)
          }
          if let _ = jobAppStore.selectedApp {
            ResumeExportView()
              .tabItem {
                Label(TabList.submitApp.rawValue, systemImage: "paperplane")
              }
              .tag(TabList.submitApp)
          }
        }
        .padding(.all)

        if tabRefresh {EmptyView()}
      }
      .toolbar {
        buildToolbar(
          selectedTab: $selectedTab,
          listingButtons: $listingButtons,
          letterButtons: $coverLetterButtons,
          refresh: $tabRefresh
        )
      }
      .onAppear {
        if  let selectedApp = jobAppStore.selectedApp {
          if selectedApp.selectedRes == nil {
            print("nil res")
            if resRefStore.areRefsOk {
              selectedApp.selectedRes = resStore.create(jobApp: selectedApp, sources: resRefStore.defaultSources)
            } else {
              print("refs not ok")
              refPopup = true
            }
          }
        }
        updateMyLetter()
      }
      .onChange(of: jobAppStore.selectedApp) { _, _ in
        updateMyLetter()
      }
      .sheet(isPresented: $refPopup) {
        ResRefView(
          refPopup: $refPopup,
          isSourceExpanded: true,
          tab: $selectedTab
        )
        .padding()
      }
    }
  }

  func updateMyLetter() {
    print("update cover letter")
    if let selectedApp = jobAppStore.selectedApp {
      if let lastLetter = selectedApp.coverLetters.last {
        coverLetterStore.cL = lastLetter
      } else {
        coverLetterStore.cL = coverLetterStore.create(jobApp: selectedApp)
      }
    } else {
      coverLetterStore.cL = nil
    }
  }

}

struct SaveButtons {
  var edit: Bool = false
  var save: Bool = false
  var cancel: Bool = false
}

struct CoverLetterButtons {
  var showInspector: Bool = false
  var runRequested: Bool = false
}
import SwiftData
import SwiftUI

struct ContentView: View {
  var modelContext: ModelContext
  @State private var jobAppStore: JobAppStore = JobAppStore()
  @State private var resRefStore: ResRefStore = ResRefStore()
  @State private var resStore: ResStore = ResStore()
  @State private var coverRefStore: CoverRefStore = CoverRefStore()
  @State private var coverLetterStore: CoverLetterStore = CoverLetterStore()
  @State private var showNewAppSheet: Bool = false
  @State private var cL : CoverLetter? = nil
  @AppStorage("scrapingDogApiKey") var scrapingDogApiKey: String = "none"

  var body: some View {

    NavigationSplitView {
      List(
        selection: $jobAppStore.selectedApp
      ) { ForEach(Statuses.allCases, id: \.self) { status in
        let filteredApps = jobAppStore.jobApps.filter { $0.status == status }
        if !filteredApps.isEmpty {
          Section(header: RoundedTagView(tagText: status.rawValue, backgroundColor: JobApp.pillColor(status.rawValue), foregroundColor: .white)
) {
            ForEach(filteredApps) { selApp in
              Text("\(selApp.company_name): \(selApp.job_position)" )
                .tag(selApp) // Tag each item for the selection
                .contextMenu {
                  Button(role: .destructive) {
                    jobAppStore.deleteJobApp(selApp)
                  } label: {
                    Label("Delete", systemImage: "trash")
                  }
                }
            }
          }
        }
      }
      }
      .listStyle(.sidebar)
//      .navigationTitle("Job Applications")
      .safeAreaInset(edge: .bottom) {
        Button(action: { showNewAppSheet = true }) {
          Label("Add Application", systemImage: "plus.circle.fill")
        }
        .controlSize(.regular)
        .labelStyle(.titleAndIcon)
        .padding(.bottom, 10)
        .background(Color.clear)
        .buttonStyle(BlackOnHoverButtonStyle())
        .frame(maxWidth: .infinity, alignment: .leading)
        .padding(.leading, 10)
      }
    } detail: {
      VStack(alignment: .leading) {
        if let selApp = jobAppStore.selectedApp {
          TabWrapperView()
//            .navigationTitle(selApp.job_position)
        } else {
          Text("No Selection")
//            .navigationTitle("Job Details")
        }
      }
      .frame(minWidth: 200, maxWidth: .infinity, maxHeight: .infinity, alignment: .center)
      .background(
        VStack {
          Divider()
          Spacer()
        }
      )
    }
    .sheet(isPresented: $showNewAppSheet) {
      NewAppSheetView(
        scrapingDogApiKey: scrapingDogApiKey,
        isPresented: $showNewAppSheet
      )
    }
    .onAppear {
      resRefStore.initialize(context: modelContext)
      resStore.initialize(context: modelContext)
      jobAppStore.initialize(context: modelContext, resStore: resStore)
      coverRefStore.initialize(context: modelContext)
      coverLetterStore.initialize(context: modelContext, refStore: coverRefStore)



    }
    .environment(jobAppStore)
    .environment(resRefStore)
    .environment(resStore)
    .environment(coverRefStore)
    .environment(coverLetterStore)  }
}



struct BlackOnHoverButtonStyle: ButtonStyle {
  @State private var isHovered = false

  func makeBody(configuration: Configuration) -> some View {
    configuration.label
      .foregroundColor(isHovered ? .black : .primary)
      .onHover { hovering in
        isHovered = hovering
      }
  }
}
//
//  TabList.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/9/24.
//


enum TabList: String {
  case listing = "Job Listing"
  case resume = "Customize Résumé"
  case coverLetter = "Compose Cover Letter"
  case submitApp = "Submit Application"
  case none = "None"
}import AppKit
import SwiftUI

struct Cell: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore?
  @Environment(\.openURL) private var openURL
  var leading: String
  var trailingKeys: KeyPath<JobApp, String>
  var formTrailingKeys: WritableKeyPath<JobAppForm, String>
  @Binding var isEditing: Bool
  //    @State private var isHovered: Bool = false

  var body: some View {
    HStack {
      Text(leading)
      Spacer()
      if isEditing {
        if let store = jobAppStore {
          TextField(
            "",
            text: Binding(
              get: { store.form[keyPath: formTrailingKeys] },
              set: { store.form[keyPath: formTrailingKeys] = $0 })
          )
          .textFieldStyle(.roundedBorder)
        } else {
          Text("Error: Store not available")
        }
      } else {
        HStack {
          if let app = jobAppStore?.selectedApp {
            let val = app[keyPath: trailingKeys]
            Text(val.isEmpty ? "none listed" : val)
              .foregroundColor(false ? .blue : .secondary)
              .italic(val.isEmpty)
              .lineLimit(1)

            if isValidURL(val) {
              Button(action: {
                if let url = URL(string: val) {
                  openURL(url)
                } else {
                  print("URL Problem")
                }
              }) {
                Image(systemName: "arrow.up.right.square")
                  .foregroundColor(
                    false ? .blue : .secondary)
              }
              .buttonStyle(PlainButtonStyle())
            }

          } else {
            Text("No app selected")
              .foregroundColor(.red)
          }
        }
        //                .onHover { hover in
        //                    if let app = jobAppStore?.selectedApp {
        //                        let trailing = app[keyPath: trailingKeys]
        //                        if isValidURL(trailing) {
        //                            isHovered = hover
        //                        } else {
        //                            isHovered = false
        //                        }
        //
        //                    }
        //                }
      }
    }
    .onAppear {
      // Debugging print statements, safely

    }
  }

  private func isValidURL(_ urlString: String) -> Bool {
    if let url = URL(string: urlString) {
      return NSWorkspace.shared.urlForApplication(toOpen: url) != nil
    }
    return false
  }
}
import SwiftUI

struct ImageButton: View {
  let systemName: String?
  let name: String?
  var defaultColor: Color?
  var activeColor: Color?
  let imageSize: CGFloat
  let action: () -> Void

  @State private var isHovered = false
  @State private var isActive = false

  init(
    systemName: String? = nil, name: String? = nil, imageSize: CGFloat = 35,
    defaultColor: Color? = Color.secondary, activeColor: Color? = Color.accentColor,
    action: @escaping () -> Void
  ) {
    // Validation: Ensure either systemName or name is provided, but not both or none
    if (systemName == nil && name == nil) || (systemName != nil && name != nil) {
      fatalError("You must provide either `systemName` or `name`, but not both or none.")
    }
    self.imageSize = imageSize
    self.systemName = systemName
    self.name = name
    self.defaultColor = defaultColor
    self.activeColor = activeColor
    self.action = action
  }

  var body: some View {
    imageView()
      .resizable()
      .aspectRatio(contentMode: .fit)
      .frame(width: imageSize, height: imageSize)
      .foregroundColor(
        (isActive || isHovered) ? activeColor ?? Color.accentColor : defaultColor ?? Color.secondary
      )
      .onHover { hovering in
        isHovered = hovering
      }
      .onTapGesture {
        isActive = true
        action()
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.75) {
          isActive = false
        }
      }
  }

  private func imageView() -> Image {
    let baseName = currentImageName()
    // Check if systemName is nil or not, and use the appropriate initializer
    if systemName != nil {
      return Image(systemName: baseName)
    } else {
      return Image(baseName)
    }
  }

  private func currentImageName() -> String {
    let baseName = systemName ?? name ?? ""
    return isActive ? baseName + ".fill" : baseName
  }
}
import SwiftUI

struct RoundedTagView: View {
  var tagText: String
  var backgroundColor: Color = .blue
  var foregroundColor: Color = .white

  var body: some View {
    Text(tagText.capitalized)
      .font(.caption)
      .padding(.vertical, 4)
      .padding(.horizontal, 8)
      .background(backgroundColor)
      .foregroundColor(foregroundColor)
      .cornerRadius(10)
  }
}
import SwiftUI
struct Colors  {
  static let ltGray = Color(red: 245 / 255, green: 245 / 255, blue: 245 / 255)
  static let midLtGray = Color(red: 235 / 255, green: 235 / 255, blue: 235 / 255)
  static let midGray = Color(red: 225 / 255, green: 225 / 255, blue: 225 / 255)

}
struct CustomStepper: View {
  @Binding var value: Int
  @State var isPlusHovering: Bool = false
  @State var isMinusHovering: Bool = false
  var range: ClosedRange<Int>
  var body: some View {
    HStack(spacing: 0) {
      // Decrement button (-)
      Button(action: {
        if value > range.lowerBound {
          value -= 1
        }
      }) {
        Text("–")
          .frame(width: 24, height: 24)
          .background(isMinusHovering ? Colors.ltGray : Color.clear )
          .foregroundColor(.primary)  // Text color for button
      }
      .buttonStyle(PlainButtonStyle()).onHover{hover in isMinusHovering = hover}  // Disable default button style

      // Divider between the buttons and value
      Divider()
        .frame(height: 22)
        .background(Colors.midGray)

      // Value display
      Text("\(value)")
        .frame(width: 24, height: 24)
        .background(Color.clear)
        .foregroundColor(.primary)  // Text color for value

      // Divider between value and increment button
      Divider()
        .frame(height: 22)
        .background(Colors.midGray)

      // Increment button (+)
      Button(action: {
        if value < range.upperBound {
          value += 1
        }
      }) {
        Text("+")
          .frame(width: 24, height: 24)
          .background(isPlusHovering ? Colors.ltGray : Color.clear)
          .foregroundColor(.primary)  // Text color for button
      }
      .buttonStyle(PlainButtonStyle())
      .onHover{hovering in
        isPlusHovering = hovering}// Disable default button style
    }
    .font(.body)  // Set the font size
    .cornerRadius(8)  // Rounded corners
    .overlay(
      RoundedRectangle(cornerRadius: 8)
        .stroke(Colors.ltGray, lineWidth: 1)
    )  // Add border around the entire stepper
    .background(Colors.midLtGray)  // Use tertiary background color to match design
    .clipShape(RoundedRectangle(cornerRadius: 8))  // Clip the shape to match the rounded corners
  }
}



import SwiftOpenAI
import SwiftUI

struct AiFunctionView: View {
  @Binding var attentionGrab: Int
  @Binding var res: Resume?
  @AppStorage("openAiApiKey") var openAiApiKey: String = "none"

  init(res: Binding<Resume?>, attn: Binding<Int>) {
    self._res = res
    self._attentionGrab = attn
  }

  var body: some View {
    if let myRes = res {
      AiCommsView(
        service: OpenAIServiceFactory.service(apiKey: openAiApiKey, debugEnabled: true),
        query: myRes.generateQuery(attentionGrab: attentionGrab), 
        res: $res
      )
      .onAppear { myRes.debounceExport() } // Use `myRes` instead of force-unwrapping
    } else {
      Text("No Resume Available") // Optionally, handle the case when `res` is nil
    }
  }
}
import SwiftUI

struct ReviewCommentView: View {
  @Binding var comment: String
  @Binding var isCommenting: Bool
  let saveAction: () -> Void  // Closure without parameters

  var body: some View {
    VStack(alignment: .leading) {
      Text("Comments/Instructions to improve text generation")
        .font(.footnote)
      TextField("Reviewer Comments", text: $comment)
        .lineLimit(3...10)
      HStack {
        Button(
          "Save",
          action: {
            isCommenting = false
            saveAction()  // Call the closure directly
          })
        Button(
          "Cancel",
          action: {
            isCommenting = false
          })
      }
    }.padding()
  }
}
//
//  ChatStructuredOutputDemoView.swift
//  SwiftOpenAIExample
//
//  Created by James Rochabrun on 8/10/24.
//

import Foundation
import SwiftOpenAI
import SwiftUI

struct AiCommsView: View {
  @State private var q: ResumeApiQuery
  @State private var chatProvider: ResumeChatProvider
  @State private var revisions: [ProposedRevisionNode] = []
  @State private var currentRevNode: ProposedRevisionNode? = nil
  @State var currentFeedbackNode: FeedbackNode? = nil
  @State private var isLoading = false
  @State private var sheetOn: Bool = false
  @State private var aiResub: Bool = false
  @Binding var myRes: Resume?
  @State private var fbnodes: [FeedbackNode] = []
  init(service: OpenAIService, query: ResumeApiQuery, res: Binding<Resume?>) {
    _chatProvider = State(initialValue: ResumeChatProvider(service: service))
    _q = State(initialValue: query)
    _myRes = res
  }

  var body: some View {
    exec_query
      .sheet(isPresented: $sheetOn) {
        print("sheet dismissed")
      } content: {
        if sheetOn {
          ReviewView(
            revisionArray: $revisions,
            feedbackArray: $fbnodes,
            currentFeedbackNode: $currentFeedbackNode,
            currentRevNode: $currentRevNode,
            sheetOn: $sheetOn,
            selRes: $myRes,
            aiResub: $aiResub
          )
          .frame(minWidth: 650)
        }
      }
      .onChange(of: chatProvider.lastRevNodeArray) { oldValue, newValue in
        sheetOn = true
        revisions = validateRevs(res: myRes, revs: newValue) ?? []  // Updated this call
        currentRevNode = revisions[0]
        if currentRevNode != nil{
          currentFeedbackNode = FeedbackNode(
            id: currentRevNode!.id,
            originalValue: currentRevNode!.oldValue,
            proposedRevision: currentRevNode!.newValue,
            actionRequested: .unevaluated
          )
        }
        aiResub = false
        fbnodes = []
      }
      .onChange(of: aiResub) { oldValue, newValue in
        if newValue {
          chatAction(hasRevisions: true)
        }
      }
  }

  var exec_query: some View {
    HStack(spacing: 4) {
      VStack {
        if !isLoading {
          if (
            (myRes?.rootNode?.aiStatusChildren ?? 0)
            > 0) {
            Button(action: {
              print("Notloading")
              chatAction()
            }) {

              Image("ai-squiggle")
                .font(.system(size: 20, weight: .regular))
            }
            .help("Create new Résumé")
          } else {
            Image("ai-squiggle.slash").font(.system(size: 20, weight: .regular)).help("Select fields for ai update")

          }
        } else {
          ProgressView().scaleEffect(0.75, anchor: .center)  // Show a loading indicator when isLoading is true
        }
      }
      .padding()
    }
  }

  // Validation function for revisions
  func validateRevs(res: Resume?, revs: [ProposedRevisionNode]) -> [ProposedRevisionNode]? {
    print("Validating revisions...")
    var validRevs = revs
    if let myRes = res {
      let updateNodes = myRes.getUpdatableNodes()

      for (index, item) in validRevs.enumerated() {
        // Check by ID first
        if let matchedNode = updateNodes.first(where: { $0["id"] == item.id }) {
          print("\(item.id) found")
          continue
        } else if let matchedByValue = updateNodes.first(where: { $0["oldValue"] == item.oldValue }), let id = matchedByValue["id"] {
          // Update revision's ID if matched by value
          validRevs[index].id = id
          print("\(item.id) updated")

        } else {
          print("No match found for revision: \(item.id) - \(item.oldValue)")
        }
      }
      return validRevs
    }
    return nil
  }

  func chatAction(hasRevisions: Bool = false) {
    Task {
      print("chatAction")
      isLoading = true
      defer { isLoading = false }  // ensure isLoading is set to false when the task completes

      if !hasRevisions {
        let content: ChatCompletionParameters.Message.ContentType = .text(q.wholeResumeQueryString)

        chatProvider.messageHist = [
          q.systemMessage,
          .init(role: .user, content: content)
        ]
      } else {
        chatProvider.messageHist.append(.init(role: .user, content: .text(q.revisionPrompt(fbnodes))))
      }

      let parameters = ChatCompletionParameters(
        messages: chatProvider.messageHist,
        model: .gpt4o20240806,
        responseFormat: .jsonSchema(ResumeApiQuery.revNodeArraySchema)
      )
      try await chatProvider.startChat(parameters: parameters)
    }
  }
}
import SwiftData
import SwiftUI

struct ReviewView: View {
  @Environment(ResStore.self) private var resStore
  @Binding var revisionArray: [ProposedRevisionNode]
  @Binding var feedbackArray: [FeedbackNode]
  @State private var feedbackIndex: Int = 0
  @Binding var currentFeedbackNode: FeedbackNode?
  @Binding var currentRevNode: ProposedRevisionNode?
  @Binding var sheetOn: Bool
  @Binding var selRes: Resume?
  @State private var updateNodes: [[String: String]] = []
  @Binding var aiResub: Bool
  @State var isEditingResponse: Bool = false
  @State var isCommenting: Bool = false
  @State var isMoreCommenting: Bool = false

  var body: some View {
    if let selRes = selRes {
      if aiResub {
        VStack {
          Text("Submitting Feedback to AI").padding()
          ProgressView().padding()
        }
      } else {
        VStack {
          if let currentRevNode = currentRevNode, let currentFeedbackNode = currentFeedbackNode {
            VStack(spacing: 4) {
              ZStack {
                LinearGradient(
                  gradient: Gradient(colors: [.cyan, .blue]),
                  startPoint: .top, endPoint: .bottom
                )
                .mask {
                  RoundedRectangle(
                    cornerRadius: 18, style: .continuous)
                }
                .shadow(color: .black.opacity(0.1), radius: 8, x: 0, y: 4)
                Image(systemName: "sparkles")
                  .imageScale(.large)
                  .foregroundStyle(.white)
                  .font(.system(.largeTitle, weight: .light))
                  .rotationEffect(.degrees(90), anchor: .center)
                  .shadow(color: .black.opacity(0.25), radius: 2, x: 0, y: 3)
              }
              .frame(width: 50, height: 50)
              .clipped()
              .padding(.bottom, 8)
              Text("Evaluate Proposed Revisions")
                .font(.system(.title, weight: .semibold))
                .multilineTextAlignment(.center)
              Text("Reviewing \(feedbackIndex + 1) of \(revisionArray.count)")
                .font(.caption2)
                .fontWeight(.light)
            }
            .fixedSize(horizontal: false, vertical: true)
            .padding(.top, 60)
            .padding(.bottom, 45)
            VStack(alignment: .leading, spacing: 15) {
              HStack(alignment: .top) {
                VStack(alignment: .leading, spacing: 3) {
                  Text("Original Text")
                    .font(.system(.headline, weight: .semibold))
                    .transition(.move(edge: .trailing))
                  Text(currentRevNode.oldValue)
                    .font(.system(.headline, weight: .light))
                    .foregroundStyle(.secondary)
                    .transition(.move(edge: .trailing))
                }
                .fixedSize(horizontal: false, vertical: true)
              }
              if currentRevNode.valueChanged {
                HStack(alignment: .top) {
                  VStack(alignment: .leading, spacing: 3) {
                    Text("Proposed Revision")
                      .font(.system(.title2, weight: .semibold))
                      .transition(.move(edge: .trailing))
                    if isEditingResponse {
                      HStack(spacing: 10) {
                        TextField(
                          "RevisedText",
                          text: Binding(
                            get: { currentFeedbackNode.proposedRevision },
                            set: { newValue in
                              self.currentFeedbackNode?.proposedRevision = newValue
                            }
                          ),
                          axis: .vertical
                        ).lineLimit(4...10)
                        Spacer()
                        ImageButton(
                          systemName: "checkmark.circle",
                          imageSize: 20,
                          activeColor: Color.green,
                          action: {
                            saveAndNext(response: .acceptedWithChanges)
                          }
                        )
                        ImageButton(
                          systemName: "x.circle",
                          imageSize: 20,
                          activeColor: Color.red,
                          action: {
                            isEditingResponse = false
                          }
                        )
                      }
                      .frame(maxWidth: .infinity)
                    } else {
                      Text(currentRevNode.newValue)
                        .font(.system(.title2, weight: .light))
                        .transition(.move(edge: .trailing))
                        .foregroundStyle(.secondary)
                    }
                  }
                  .fixedSize(horizontal: false, vertical: true)
                }
              }
              if currentRevNode.valueChanged {
                HStack(alignment: .top) {
                  VStack(alignment: .leading, spacing: 3) {
                    Text("Explanation")
                      .font(.system(.headline, weight: .semibold))
                      .transition(.move(edge: .trailing))
                    Text(currentRevNode.why)
                      .font(.system(.headline, weight: .light))
                      .foregroundStyle(.secondary)
                      .transition(.move(edge: .trailing))
                  }
                  .fixedSize(horizontal: false, vertical: true)
                }
              }
            }
            .padding(.leading, 30)
            .padding(.trailing, 30)
            Text(currentRevNode.valueChanged ? "Accept proposed revision?" : "Accept original value unchanged?")
              .padding()
              .font(.title2)
            HStack(spacing: 25) {
              if currentRevNode.valueChanged {
                ImageButton(
                  systemName: "hand.thumbsdown.circle",
                  activeColor: Color.purple,
                  action: { isCommenting = true }
                ).help("Reject Revision with comment.").popover(isPresented: $isCommenting) {
                  ReviewCommentView(
                    comment: Binding(
                      get: { currentFeedbackNode.reviewerComments },
                      set: { newValue in
                        self.currentFeedbackNode?.reviewerComments = newValue
                      }
                    ),
                    isCommenting: $isCommenting,
                    saveAction: {
                      saveAndNext(response: .revise)
                    }
                  )
                }
                ImageButton(
                  systemName: "trash.circle",
                  activeColor: Color.red,
                  action: {
                    saveAndNext(response: .rewriteNoComment)
                  }
                ).help("Try again. Reject Revision without comment.")
              } else {
                ImageButton(
                  systemName: "hand.thumbsdown.circle",
                  activeColor: Color.purple,
                  action: { isMoreCommenting = true }
                ).popover(isPresented: $isMoreCommenting) {
                  ReviewCommentView(
                    comment: Binding(
                      get: { currentFeedbackNode.reviewerComments },
                      set: { newValue in
                        self.currentFeedbackNode?.reviewerComments = newValue
                      }
                    ),
                    isCommenting: $isCommenting,
                    saveAction: {
                      saveAndNext(response: .mandatedChange)
                    }
                  )
                }
                ImageButton(
                  systemName: "trash.circle",
                  activeColor: Color.red,
                  action: {
                    saveAndNext(response: .mandatedChangeNoComment)
                  }
                )
              }
              if currentRevNode.valueChanged {
                ImageButton(
                  name: "ai-rejected", imageSize: 43, activeColor: Color.indigo,
                  action: { saveAndNext(response: .restored) }
                )
                ImageButton(
                  systemName: "pencil.circle",
                  action: { isEditingResponse = true }
                )
              }
              ImageButton(
                systemName: "hand.thumbsup.circle",
                activeColor: Color.green,
                action: {
                  saveAndNext(response: currentRevNode.valueChanged ? .accepted : .noChange)
                }
              ).help("Approve revision")
            }
          } else {
            // Handle the case where currentRevNode or currentFeedbackNode is nil
            Text("No revision to display").padding()
          }
        }
        .frame(maxWidth: .infinity)
        .clipped()
        .padding(.top, 0)
        .padding(.bottom, 40)
        .padding(.horizontal, 20)
        .onChange(of: aiResub) { oldValue, newValue in
          print("aiResub changed from \(oldValue ? "true":"false") to \(newValue ? "true":"false")")
          if !newValue {
            currentRevNode = revisionArray.first
            feedbackIndex = 0
            feedbackArray = []
          }
        }
        .onAppear {
          if updateNodes.isEmpty {
            updateNodes = selRes.getUpdatableNodes()
          }
        }
      }
    }
    else { Text("No valid Res") }
  }

  func saveAndNext(response: PostReviewAction) {
    if let currentFeedbackNode = currentFeedbackNode {
    currentFeedbackNode.actionRequested = response
      switch response {
        case .accepted:
          nextNode()
          
        case .acceptedWithChanges:
          isEditingResponse = false
          nextNode()
        case .restored:
          currentFeedbackNode.proposedRevision =
          currentFeedbackNode.originalValue
          nextNode()
        case .revise:
          isCommenting = false
          nextNode()
        case .rewriteNoComment:
          nextNode()
        case .mandatedChangeNoComment:
          isCommenting = false
          nextNode()
        case .mandatedChange:
          nextNode()
        case .noChange:
          nextNode()
          
        default:
          print("default")
      }
    }

  }
  func nextNode() {
    @Environment(\.modelContext)  var context: ModelContext

    if let currentFeedbackNode = currentFeedbackNode {
      feedbackArray.append(currentFeedbackNode)
      print(feedbackArray.count)
      feedbackIndex += 1
    }
    if feedbackIndex < revisionArray.count {
      withAnimation(.easeInOut(duration: 0.5)) {
        currentRevNode = revisionArray[feedbackIndex]
        if let currentRevNode = currentRevNode {
          currentFeedbackNode = FeedbackNode(
            id: currentRevNode.id,
            originalValue: currentRevNode.oldValue,
            proposedRevision: currentRevNode.newValue,
            actionRequested: .unevaluated
          )
        }
      }
    } else {

      applyChanges()
      let aiActions: Set<PostReviewAction> = [
        .revise, .mandatedChange, .mandatedChangeNoComment, .rewriteNoComment
      ]

      if feedbackArray.contains(where: { node in
        aiActions.contains(node.actionRequested)
      }) {
        for fb in feedbackArray {
          print(fb.proposedRevision)
          print("Action: \(String(describing: fb.actionRequested))")
        }
        aiResubmit()
      } else {
        if var selRes = selRes {

          if var selRes = resStore.createDuplicate(originalResume: selRes, context: context) {

            selRes.debounceExport()
          }

        }
        sheetOn = false
      }

    }
  }

  func applyChanges() {
    feedbackArray.forEach { node in
      if node.actionRequested == .accepted || node.actionRequested == .acceptedWithChanges {
        if let selRes = selRes{
          if let treeNode = selRes.nodes.first(where: { $0.id == node.id }) {
            treeNode.value = node.proposedRevision
          } else {
            print("node not found")
            print(node.id)
          }
        }
      }
    }
  }

  func aiResubmit() {
    feedbackIndex = 0
    aiResub = true
  }

  func fetchModelByID(id: String, context: ModelContext) -> TreeNode? {
    var descriptor = FetchDescriptor<TreeNode>()
    descriptor.predicate = #Predicate { $0.id == id }
    descriptor.fetchLimit = 1
    return try? context.fetch(descriptor).first
  }
}
//
//  CoverLetterAi.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/12/24.
//

import Foundation
import SwiftOpenAI
import SwiftUI

struct CoverLetterAiView: View {
  @AppStorage("openAiApiKey") var openAiApiKey: String = "none"
  @Binding var buttons: CoverLetterButtons
  @Binding var refresh: Bool

  var body: some View {

    CoverLetterAiContentView(
      service: OpenAIServiceFactory.service(
        apiKey: openAiApiKey, debugEnabled: false),
      buttons: $buttons, refresh: $refresh
    )
    .onAppear { print("Ai Cover Letter") }

  }
}

struct CoverLetterAiContentView: View {
  @Environment(CoverLetterStore.self) private var coverLetterStore: CoverLetterStore
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore

  @State var aiMode: CoverAiMode = .none
  @Binding var buttons: CoverLetterButtons
  @Binding var refresh: Bool
  let service: OpenAIService

  // Use @Bindable for chatProvider
  @Bindable var chatProvider: CoverChatProvider

  init(
    service: OpenAIService,
    buttons: Binding<CoverLetterButtons>,
    refresh: Binding<Bool>
  ) {
    self.service = service
    self._buttons = buttons
    self.chatProvider = CoverChatProvider(service: service)
    self._refresh = refresh
  }

  var body: some View {
    if jobAppStore.selectedApp?.selectedCover != nil {
      @Bindable var cL = jobAppStore.selectedApp!.selectedCover!

      HStack(spacing: 4) {
        VStack {
          if !$buttons.wrappedValue.runRequested {
            Button(action: {
              print("Not loading")
              if !cL.generated {
                cL.currentMode = .generate
              } else {
                @Bindable var newCL = coverLetterStore.createDuplicate(letter: cL)
                cL = newCL  // Assign new instance
                print("new cover letter")
              }

              chatProvider.coverChatAction(res: jobAppStore.selectedApp?.selectedRes,
                                           jobAppStore: jobAppStore,
                                           chatProvider: chatProvider,
                                           buttons: $buttons)
            }) {
              Image("ai-squiggle")
                .font(.system(size: 20, weight: .regular))
            }
            .help("Generate new Cover Letter")
          } else {
            ProgressView()
              .scaleEffect(0.75, anchor: .center)
          }
        }
        .padding()
        .onAppear { print("AI content") }
      }

//      .onChange(of: buttons.runRequested) { oldValue, newValue in
//        if newValue {
//          chatAction(res: jobAppStore.selectedApp?.selectedRes)
//        }
      }
    }
  }

//`//
////  AiPanelView.swift
////  PhysicsCloudResume
////
////  Created by Christopher Culbreath on 8/25/24.
////
//
//import SwiftUI
//
//struct AiPanelView: View {
//  @Binding var res: Resume
//  @State var attentionGrab: Int = 2
//  @AppStorage("openAiApiKey") var openAiApiKey: String = "none"
//
//  @State private var isButHover: Bool = false
//
//  var body: some View {
//    let q = res.generateQuery(attentionGrab: attentionGrab)
//    GroupBox {
//      VStack {
//        HStack {
//          Button( action: {print("nope")}) {
//            Image(
//              isButHover
//                ? "ai-squiggle.bubble.left.fill"
//                : "ai-squiggle.bubble.left"
//            )
//            .foregroundColor(.pink)
//            .font(.system(size: 22))
//            .fontWeight(.light)
//          }.buttonStyle(.borderless).onHover { hover in
//            isButHover = hover
//          }
//          Stepper("Attenion grabbing intensity \(attentionGrab)", value: $attentionGrab, in: 0...4)
//        }
//        ChatView(key: openAiApiKey, apiQuery: q, res: $res)
//      }.frame(maxWidth: .infinity, minHeight: 100)
//    }
//  }
//}

import SwiftUI

struct ResumeExportView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @State private var selectedResume: Resume?
  @State private var selectedCoverLetter: CoverLetter?
  @State private var selectedStatus: Statuses = .new  // Initial state
  var body: some View {
    if (jobAppStore.selectedApp != nil) {
      @Bindable var jobApp: JobApp = jobAppStore.selectedApp!

      VStack(alignment: .leading, spacing: 20) {

        // Resume Section Header
        Text("Resume")
          .font(.headline)
          .padding(.top)

        // Resume Picker
        Picker("Select a Resume", selection: $selectedResume) {
          Text("None").tag(nil as Resume?)
          ForEach(jobApp.resumes.sorted(by: { $0.createdDateString > $1.createdDateString }), id: \.self) { resume in
            Text("Created at \(resume.createdDateString)")
              .tag(resume as Resume?)
              .help("Select a resume to customize")
          }
        }
        .pickerStyle(MenuPickerStyle())

        // Export Buttons for Resume
        HStack(spacing: 15) {
          Button("Export PDF") {
            exportResumePDF()
          }
          Button("Export Text") {
            exportResumeText()
          }
          Button("Export JSON") {
            exportResumeJSON()
          }
        }


        // Divider after Resume Section
        Divider()

        // Cover Letter Section Header
        Text("Cover Letter")
          .font(.headline)

        // Cover Letter Picker

        Picker("Select a Cover Letter", selection: $selectedCoverLetter) {
          Text("None").tag(nil as CoverLetter?)
          ForEach(jobApp.coverLetters.sorted(by: { $0.moddedDate > $1.moddedDate }), id: \.id) { coverLetter in
            Text("Generated at \(coverLetter.modDate)").tag(coverLetter as CoverLetter?)
          }
        }
        .pickerStyle(MenuPickerStyle())

        // Export Button for Cover Letter
        Button("Export Cover Letter Text") {
          exportCoverLetterText()
        }


        // Divider after Cover Letter Section
        Divider()

        // Application Status Section Header
        Text("Application Status")
          .font(.headline)

        // Segmented Picker for jobApp status
        Picker("", selection: $selectedStatus) {
          ForEach(Statuses.allCases, id: \.self) { status in
            Text(status.rawValue)
              .tag(status)
          }
        }
        .pickerStyle(SegmentedPickerStyle())
        .onChange(of: selectedStatus) { oldValue, newStatus in
          jobApp.status = newStatus
          jobAppStore
            .updateJobAppStatus(jobApp, to: newStatus) // Assuming you have an update method
        }
        TextEditor(text:$jobApp.notes)


      }
      .padding()
      .frame(maxHeight: .infinity, alignment: .top)  // Align content to the top of the view
      .onAppear {
        if let jobApp = jobAppStore.selectedApp {
          selectedStatus = jobApp.status  // Set initial status when the view appears
        }
      }
    }
    else {
      EmptyView()
    }
  }


  // Export Resume PDF
  private func exportResumePDF() {
    guard let resume = selectedResume, let pdfData = resume.pdfData else {
      print("No PDF data available for this resume")
      return
    }

    let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
    let fileURL = downloadsURL.appendingPathComponent("\(resume.jobApp?.job_position ?? "unknown").pdf")

    do {
      try pdfData.write(to: fileURL)
      print("PDF exported to \(fileURL)")
    } catch {
      print("Failed to export PDF: \(error)")
    }
  }

  // Export Resume Text
  private func exportResumeText() {
    guard let resume = selectedResume else {
      print("No resume selected")
      return
    }

    let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
    let fileURL = downloadsURL.appendingPathComponent("\(resume.jobApp?.job_position ?? "unknown").txt")

    do {
      try resume.textRes.write(to: fileURL, atomically: true, encoding: .utf8)
      print("Text file exported to \(fileURL)")
    } catch {
      print("Failed to export resume text: \(error)")
    }
  }

  // Export Resume JSON
  private func exportResumeJSON() {
    guard let resume = selectedResume else {
      print("No resume selected")
      return
    }

    let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
    let fileURL = downloadsURL.appendingPathComponent("\(resume.jobApp?.job_position ?? "unknown").json")

    let jsonString = resume.jsonTxt

    do {
      try jsonString.write(to: fileURL, atomically: true, encoding: .utf8)
      print("JSON file exported to \(fileURL)")
    } catch {
      print("Failed to export resume JSON: \(error)")
    }
  }

  // Export Cover Letter Text
  private func exportCoverLetterText() {
    guard let coverLetter = selectedCoverLetter else {
      print("No cover letter selected")
      return
    }

    let downloadsURL = FileManager.default.urls(for: .downloadsDirectory, in: .userDomainMask).first!
    let fileURL = downloadsURL.appendingPathComponent("\(coverLetter.jobApp?.job_position ?? "")_CoverLetter.txt")

    do {
      try coverLetter.content.write(to: fileURL, atomically: true, encoding: .utf8)
      print("Cover letter text file exported to \(fileURL)")
    } catch {
      print("Failed to export cover letter text: \(error)")
    }
  }
}
//
//  CreateNewResumeView.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/18/24.
//

import SwiftData
import SwiftUI

struct CreateNewResumeView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore
  @Environment(ResStore.self) private var resStore: ResStore
  @Binding var refresh: Bool
  var body: some View {
    let selApp: JobApp = jobAppStore.selectedApp!

    VStack {
      Text("No resumes available")
        .font(.title)
      Button(action: {
        resStore.create(jobApp: selApp, sources: resRefStore.defaultSources)
        refresh.toggle()}) {
        Text("Create Résumé")
          .buttonStyle(.borderedProminent)
          .controlSize(.regular)
          .buttonBorderShape(.capsule)
      }
    }.onAppear { print("create app bitches") }
  }
}
//
//  ResumeSplitView.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/31/24.
//

import SwiftUI

struct ResumeSplitView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Binding var isWide: Bool
  @Binding var tab: TabList
  var body: some View {
    if let selApp = jobAppStore.selectedApp {
      if let selRes = selApp.selectedRes {
        @Bindable var selApp = selApp

        HSplitView {
          if let rootNode = selRes.rootNode {

            ResumeDetailView(
              selRes: $selApp.selectedRes,
              tab: $tab,
              rootNode: rootNode,
              isWide: $isWide

            )
            .frame(
              minWidth: isWide ? 350 : 200,
              idealWidth: isWide ? 500 : 300,
              maxWidth: 600,
              maxHeight: .infinity
            ).onAppear{print("RootNode")
              //          print(rootNode.resume.id)
            }
            .layoutPriority(1)  // Ensures this view gets priority in layout
          }

            ResumePDFView(resume: selRes)
              .frame(
                minWidth: 300, idealWidth: 400,
                maxWidth: .infinity, maxHeight: .infinity
              )
              .layoutPriority(1)  // Less priority, but still resizable
          }
        }
      }
    }
  }

//
//  ResumePDFView.swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/20/24.
//

import PDFKit
import SwiftUI

struct ResumePDFView: View {
  @Bindable var resume: Resume
  @State private var needsUpdate: Bool = false

  var body: some View {
    @State var isUpdating = resume.isUpdating

    VStack {
      if let pdfData = resume.pdfData {
        PDFKitWrapper(pdfView: pdfViewer(pdfData: pdfData))
          .frame(maxWidth: .infinity, maxHeight: .infinity).overlay(alignment: .topTrailing){
            if isUpdating {
              ProgressView().scaleEffect(0.5, anchor: .center).padding(.top, 2).padding(.trailing, 2)
            }
          }
      } else {
        Text("No PDF available")
      }
    }
    .onAppear {
      if resume.pdfData == nil {
        if let fileURL = FileHandler.readPdfUrl() {
          resume.loadPDF(from: fileURL)
        }
      }
    }
//    .onChange(of: resume.pdfData) {
//      needsUpdate.toggle()  // Update the view when pdfData changes
//    }
  }
}

func pdfViewer(pdfData: Data) -> PDFView {
  let pdfDoc = PDFDocument(data: pdfData)
  let pdfView = PDFView()
  pdfView.document = pdfDoc
  pdfView.autoScales = true
  return pdfView
}

struct PDFKitWrapper: NSViewRepresentable {
  let pdfView: PDFView

  func makeNSView(context: Context) -> PDFView {
    return pdfView
  }

  func updateNSView(_ nsView: PDFView, context: Context) {
    // Update the NSView if needed
    nsView.document = pdfView.document
  }

  typealias NSViewType = PDFView
}
import SwiftUI

struct ResumeViewSetup: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore
  @Environment(ResStore.self) private var resStore: ResStore
  @Binding var refresh: Bool
  @State private var isWide = false
  @State var currentTab: TabList


  var body: some View {
    VStack {
      if let jobApp = jobAppStore.selectedApp {
        if jobApp.resumes.isEmpty {
          CreateNewResumeView(refresh: $refresh)
        } else {


          ResumeSplitView(isWide: $isWide, tab: $currentTab)
        }
      } else {
        Text("No job application selected.")
      }
    }
  }
}
//
//  AddResRefView.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 12/30/24.
//

import SwiftUI

struct AddResRefView: View {
  @State private var isTargeted: Bool = false
  @State var newSourceName: String = ""
  @State var newSourceContent: String = ""
  @State var newSourceType: SourceType = SourceType.background
  @State var newEnabledByDefault: Bool = true
  @Binding var isSheetPresented: Bool
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore
  @FocusState private var isFocused: Bool
  @Binding var refPopup: Bool
  var jobApp: JobApp
    var body: some View {
      Form {
        Section(header: Text("Add New Source").font(.headline)) {
          VStack (alignment: .leading){
            HStack(alignment: .top) {
              Text("Source Name:")
                .frame(width: 150, alignment: .trailing)
              TextField("", text: $newSourceName)
                .frame(maxWidth: .infinity)
            }
            HStack(alignment: .top) {
              Text("Content:")
                .frame(width: 150, alignment: .trailing)
                .padding(.trailing, 9)
              TextEditor(text: $newSourceContent)
                .padding(5)
                .focusable(true)      // (1) Mark it focusable on macOS
                .focused($isFocused)
                .onTapGesture { isFocused = true }
                .onChange(of: isFocused) { print("isFocused changed to:", isFocused) }
                .frame(maxWidth: .infinity, minHeight: 200)
                .overlay(
                  RoundedRectangle(cornerRadius: 6)
                    .stroke(
                      ( isTargeted || isFocused ) ? .blue : .secondary,
                      lineWidth: ( isTargeted || isFocused ) ? 2 : 0.25
                    )
                )
            }
            HStack(alignment: .top) {
              Text("Source Type:")
                .frame(width: 150, alignment: .trailing)
              Picker("", selection: $newSourceType) {
                ForEach(SourceType.allCases, id: \.self) { sourceType in
                  Text(sourceType.rawValue).tag(sourceType)
                }
              }
              .pickerStyle(RadioGroupPickerStyle())
              .frame(maxWidth: .infinity, alignment: .leading)
            }
          }
          HStack {
            Text("Enabled by Default:")
              .frame(width: 150, alignment: .trailing)
            Toggle("", isOn: $newEnabledByDefault)
              .toggleStyle(SwitchToggleStyle())
          }
          HStack {
            Spacer()
            Button("Cancel") {
              isSheetPresented = false
            }
            .buttonStyle(.bordered)
            Spacer()
            Button("Save") {
              saveRefForm()
              resetRefForm()
              closePopup()
            }
            .buttonStyle(.borderedProminent)
            Spacer()
          }
          .padding(.top)
        }
      }
      .padding()
      .frame(minWidth: 400)
      .onDrop(of: ["public.file-url"], isTargeted: $isTargeted) { providers in handleOnDrop(providers: providers) }
      .onChange(of: isTargeted) { print("isTargeted:", isTargeted) }
    }
  private func saveRefForm() {
    let newSource = ResRef(
      name: newSourceName,
      content: newSourceContent,
      type: newSourceType,
      enabledByDefault: newEnabledByDefault
    )
    resRefStore.addResRef(newSource, res: jobApp.selectedRes)

  }
  private func resetRefForm() {
    newSourceName = ""
    newSourceContent = ""
    newSourceType = .background
    newEnabledByDefault = true
  }
  private func handleOnDrop(providers: [NSItemProvider]) -> Bool {
    for provider in providers {
      if provider.hasItemConformingToTypeIdentifier("public.file-url") {
        provider.loadItem(forTypeIdentifier: "public.file-url", options: nil) { item, error in
          guard let urlData = item as? Data,
                let url = URL(dataRepresentation: urlData, relativeTo: nil) else {
            return
          }

          // Extract the file name

          // Read the file contents
          do {
            let fileName = url.deletingPathExtension().lastPathComponent
            print(fileName)
            let text = try String(contentsOf: url, encoding: .utf8)

              self.newSourceName = fileName
              self.newSourceContent = text
            saveRefForm()

          } catch {
            print("Error reading file: \(error.localizedDescription)")
          }
        }

        // If we handle a valid file drop, return true
        continue
      }
      else {return false}
    }
    resetRefForm()
    closePopup()
    return true
  }
  private func closePopup() {
    isSheetPresented = false
    if resRefStore.areRefsOk {
      print("refs okay")
      $refPopup.wrappedValue = false
    } else {
      print("refs not okay")
    }
  }



}

//
//  ResumeToolbar.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/10/24.
//
import SwiftUI


@ToolbarContentBuilder
func resumeToolbarContent(selRes: Binding<Resume?>, selectedApp: JobApp?, attention: Binding<Int>) -> some ToolbarContent {
      // Ensure selRes has a value if it is nil



      // ToolbarItem: Custom Stepper for attention control
//      ToolbarItem(placement: .automatic) {
//        CustomStepper(value: attention, range: 0...4)
//          .padding(.vertical, 0)
//          .overlay {
//            Text("Attention Grab")
//              .font(.caption2)
//              .padding(.vertical, 0)
//              .lineLimit(1)
//              .minimumScaleFactor(0.9)
//              .fontWeight(.light)
//              .offset(y: 18)
//          }
//          .offset(y: -1)
//          .padding(.trailing, 2)
//          .padding(.leading, 6)
//      }

      // ToolbarItem: AiFunctionView or fallback text
      ToolbarItem(placement: .automatic) {
        if selRes.wrappedValue?.rootNode != nil {
          AiFunctionView(res: selRes, attn: attention)
        } else {
          Text(":(")
        }
      }

    }
  
import SwiftData
import SwiftUI

import SwiftData
import SwiftUI

struct ResRefView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Environment(ResRefStore.self) private var resRefStore: ResRefStore
  @Binding var refPopup: Bool
  @State var isSourceExpanded: Bool = true
  @State var isSheetPresented: Bool = false

  @Binding var tab: TabList


  var body: some View {
    @Bindable var jobAppStore = jobAppStore
    if let jobApp = jobAppStore.selectedApp {
      LazyVStack(alignment: .leading) {
        HStack {
          // Chevron icon with rotation based on isSourceExpanded
          Image(systemName: "chevron.right")
            .rotationEffect(.degrees(isSourceExpanded ? 90 : 0))
            .animation(.easeInOut(duration: 0.1), value: isSourceExpanded)
            .foregroundColor(.primary)
          Text("Résumé Source Documents")
            .font(.headline)
          Spacer()

          if jobApp.selectedRes != nil {
            if !(jobApp.selectedRes!.hasValidRefsEnabled) {
              HStack {
                Spacer().frame(minWidth: 10)
                Text("Choose one resume source and one JSON source")
                  .foregroundColor(.purple)
                  .font(.caption)
                  .multilineTextAlignment(.trailing)
                  .fontWeight(.light)
                  .frame(minWidth: 150)
                Image(systemName: "exclamationmark.triangle")
                  .foregroundColor(.purple)
                  .fontWeight(.light)
                  .font(.system(size: 20))
              }
              .padding(.horizontal, 10)
              .padding(.vertical, 5)
              .background(Color.gray.opacity(0.3))
              .cornerRadius(5)
            }
          }
        }
        // Attach the onTapGesture here to the HStack for expanding/collapsing the section
        .contentShape(Rectangle())  // Makes the whole HStack tappable
        .onTapGesture {
          withAnimation {
            isSourceExpanded.toggle()
          }
        }

        // Conditionally display the content based on isSourceExpanded
        if isSourceExpanded {
          VStack(alignment: .leading, spacing: 0) {
            ForEach(resRefStore.resRefs, id: \.self) { child in
              Divider()
              SourceRowView(sourceNode: child, tab: $tab)
                .transition(.move(edge: .top)).contextMenu {
                  Button(role: .destructive) {
                    resRefStore.deleteResRef(child)
                  } label: {
                    Label("Delete", systemImage: "trash")
                  }
                }
            }
            HStack {
              Spacer()
              Button(action: {
                // Resetting states with @State properties
                isSheetPresented = true
              }) {
                Image(systemName: "plus.app")
                Text("Add Source")
              }
              .buttonStyle(.bordered)
              .padding()
            }
            .frame(maxWidth: .infinity)
            .sheet(isPresented: $isSheetPresented) {
              AddResRefView(isSheetPresented: $isSheetPresented, refPopup: $refPopup, jobApp: jobApp )
            }
          }
        }
      }
    }
  }
  struct ToggleTextRow: View {
    @Environment(JobAppStore.self) private var jobAppStore: JobAppStore

    let leadingText: String
    @State var sourceNode: ResRef

    var body: some View {
      if let res = jobAppStore.selectedApp?.selectedRes {
        Toggle(
          "",
          isOn: Binding<Bool>(
            get: { res.enabledSources.contains(sourceNode) },
            set: { newValue in
              if newValue {
                if !res.enabledSources.contains(sourceNode) {
                  res.enabledSources.append(sourceNode)
                }
              } else {
                if let index = res.enabledSources.firstIndex(of: sourceNode) {
                  res.enabledSources.remove(at: index)
                }
              }
            }
          )
        )
        .toggleStyle(.switch)
      } else {
        EmptyView()
      }
    }
  }
  struct SourceRowView: View {
    @Environment(ResRefStore.self) private var resRefStore: ResRefStore
    @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
    @State var sourceNode: ResRef
    @State private var isButtonHovering = false
    @Binding var tab: TabList
    var isChecked: Bool {
      if let res = jobAppStore.selectedApp?.selectedRes {
        return res.enabledSources.contains(sourceNode)
      } else {
        return false
      }
    }

    var body: some View {
      if let res = jobAppStore.selectedApp?.selectedRes {
        @Bindable var res = res
        HStack {
          HStack(spacing: 15) {
            ToggleTextRow(
              leadingText: sourceNode.content,
              sourceNode: sourceNode
            )
            VStack(alignment: .leading) {
              Text(sourceNode.type.rawValue).font(.caption)
                .foregroundColor(isChecked ? .primary : .secondary)
              Text(sourceNode.name)
                .foregroundColor(isChecked ? .primary : .secondary)
            }
          }
          .padding(.vertical, 2).padding(.leading, 25)
          Spacer().frame(maxWidth: .infinity)

          Button(action: {
            resRefStore.deleteResRef(sourceNode)
          }) {
            Image(systemName: "trash.fill")
              .foregroundColor(isButtonHovering ? .red : .gray)
              .font(.system(size: 15))
              .padding(2)
              .background(isButtonHovering ? Color.red.opacity(0.3) : Color.gray.opacity(0.3))
              .cornerRadius(5)
          }
          .buttonStyle(PlainButtonStyle())
          .padding(4)
        }
        .background(Color.clear)
        .cornerRadius(5)
      }
    }
  }
}
import SwiftData
import SwiftUI

struct ResumeDetailView: View {
  @Environment(JobAppStore.self) private var jobAppStore: JobAppStore
  @Binding var selRes: Resume?
  @Binding var tab: TabList
  let rootNode: TreeNode
  @Binding var isWide: Bool
  @State var dummypopup: Bool = false
  @State var refresher: Bool = false
  var body: some View {

    ScrollView {
      VStack(alignment: .leading, spacing: 10) {

        //        AiPanelView(res: $selRes)  // Pass the unwrapped Binding
        ResRefView(
          refPopup: $dummypopup,
          isSourceExpanded: false,
          tab: $tab
        )  // Pass the unwrapped Binding
      }
      nodeView(rootNode, refresher: $refresher)
    }

  }
  @ViewBuilder
  func nodeView(_ node: TreeNode, refresher: Binding<Bool>) -> some View {
    if node.hasChildren {
      NodeWithChildrenView(
        node: node, isExpanded: node.parent == nil, isWide: $isWide, refresher: refresher)
    } else {
      NodeLeafView(node: node, refresher: $refresher)
    }
  }
}

struct NodeWithChildrenView: View {
  let node: TreeNode
  @State var isExpanded: Bool
  @State var isHovering = false
  @Binding var isWide: Bool
  @Binding var refresher: Bool

  init(node: TreeNode, isExpanded: Bool, isWide: Binding<Bool>, refresher: Binding<Bool>) {
    self.node = node
    self._isExpanded = State(initialValue: isExpanded)
    self._isWide = isWide
    self._refresher = refresher
  }

  var body: some View {
    VStack(alignment: .leading) {
      HStack {
        Image(systemName: "chevron.right")
          .rotationEffect(.degrees(isExpanded ? 90 : 0))
          .animation(.easeInOut(duration: 0.1), value: isExpanded)
          .foregroundColor(.primary)
          .onTapGesture {
            withAnimation {
              isExpanded.toggle()
              if !isExpanded { isWide = false }
            }
          }
        if node.parent == nil {
          HeaderTextRow()
        } else {
          AlignedTextRow(
            leadingText: "\(node.name)", trailingText: nil,
            nodeStatus: node.status
          )
        }
        Spacer()

        // Add the badge for aiStatusChildren count
        if node.aiStatusChildren > 0
          && (!isExpanded || node.parent == nil
            || node.parent?.parent == nil)
        {
          Text("\(node.aiStatusChildren)")
            .font(.caption).fontWeight(.medium)
            .padding(.horizontal, 10)  // Increase horizontal padding for a wider shape
            .padding(.vertical, 4)
            .background(Color.blue.opacity(0.2))
            .foregroundColor(.blue)
            .cornerRadius(10)
        }
      }
      .padding(.horizontal, 10)
      .padding(.vertical, 5)
      .background(isHovering ? Color.gray.opacity(0.3) : Color.clear)
      .cornerRadius(5)
      //            .onHover { hovering in
      //                isHovering = hovering
      //            }
      .onTapGesture {
        withAnimation {
          isExpanded.toggle()
          if isExpanded == false {
            isWide = false
          }
        }
      }

      if isExpanded, let children = node.children {
        LazyVStack(alignment: .leading, spacing: 0) {
          ForEach(
            children.sorted(by: { $0.myIndex < $1.myIndex }),
            //            children,
            id: \.self
          ) { child in

            Divider()
            nodeView(child).onAppear {
              if child.nodeDepth > 2 {
                isWide = true
              }
            }
            .transition(isWide ? .opacity : .move(edge: .top))
          }
        }
        .padding(.leading, 25)
      }

    }
  }
  @ViewBuilder
  func nodeView(_ node: TreeNode) -> some View {
    if node.hasChildren {
      NodeWithChildrenView(node: node, isExpanded: false, isWide: $isWide, refresher: $refresher)
    } else {
      NodeLeafView(node: node, refresher: $refresher)
    }
  }
}

struct NodeLeafView: View {
  @Environment(\.modelContext) private var context
  @State var node: TreeNode
  @State private var isHoveringSparkles = false
  @State private var isHoveringEdit = false
  @State private var addHovering = false
  @State private var isEditing = false
  @State private var tempValue: String = ""
  @Binding var refresher: Bool
  init(
    node: TreeNode,
    isHoveringSparkles: Bool = false,
    isHoveringEdit: Bool = false,
    isEditing: Bool = false,
    refresher: Binding<Bool>
  ) {
    self.node = node
    self.isHoveringSparkles = isHoveringSparkles
    self.isHoveringEdit = isHoveringEdit
    self.isEditing = isEditing
    self.tempValue = ""
    self._refresher = refresher
  }
  var body: some View {
    HStack(spacing: 5) {

      if node.value.isEmpty {
        Spacer().frame(width: 50)
        Text(node.name)
          .foregroundColor(.gray)
      } else {
        if node.status != LeafStatus.disabled {
          Button(action: {
            toggleNodeStatus()
          }) {
            Image(systemName: "sparkles")
              .foregroundColor(
                node.status == LeafStatus.saved
                  ? .gray : .accentColor
              )
              .font(.system(size: 14))
              .padding(2)
              .background(
                isHoveringSparkles
                  ? (node.status == LeafStatus.saved
                    ? Color.gray.opacity(0.3)
                    : Color.accentColor.opacity(0.3))
                  : Color.clear
              )
              .cornerRadius(5)
          }
          .buttonStyle(PlainButtonStyle())
          .onHover { hovering in
            isHoveringSparkles = hovering
          }
        }
        if node.status == LeafStatus.disabled {
          Image(systemName: "lock.fill")
            .foregroundColor(.gray)
            .font(.system(size: 12))
        }

        if isEditing {
          HStack(spacing: 10) {
            Button(action: {
              isEditing = false
              TreeNode.deleteTreeNode(node: node, context: context)
            }) { Image(systemName: "trash") }
            .buttonStyle(PlainButtonStyle())
            TextEditor(text: $tempValue)
              .frame(minHeight: 100)  // Adjust the height as needed
              .padding(5)
              .background(Color.primary.opacity(0.1))
              .cornerRadius(5)
              .frame(maxWidth: .infinity)

          }
          HStack(spacing: 10) {
            Button(action: {
              saveChanges()
            }) {
              Image(systemName: "checkmark.circle.fill")
                .foregroundColor(
                  isHoveringEdit ? .green : .secondary
                )
                .font(.system(size: 14))
            }
            .buttonStyle(PlainButtonStyle())
            //                        .onHover { hovering in
            //                            isHoveringEdit = hovering
            //                        }

            Button(action: {
              cancelChanges()
            }) {
              Image(systemName: "xmark.circle.fill")
                .foregroundColor(
                  isHoveringEdit ? .red : .secondary
                )
                .font(.system(size: 14))
            }
            .buttonStyle(PlainButtonStyle())
            .onHover { hovering in
              isHoveringEdit = hovering
            }
          }
        } else {
          HStack {
            AlignedTextRow(
              leadingText: node.name,
              trailingText: node.value,
              nodeStatus: node.status
            )
            if node.status != LeafStatus.disabled {
              Button(action: { addLeaf(sibling: node, refresher: $refresher) }) {
                Image(systemName: "plus.circle.fill")
                  .foregroundColor(addHovering ? .green : .secondary)
                  .font(.system(size: 14))
              }.buttonStyle(PlainButtonStyle())
                .onHover { hovering in
                  addHovering = hovering
                }
            }
          }
          Spacer()

          if node.status != LeafStatus.disabled {
            HStack(spacing: 10) {
              Button(action: {
                startEditing()
              }) {
                Image(systemName: "square.and.pencil")
                  .foregroundColor(
                    isHoveringEdit
                      ? node.status
                        == LeafStatus.aiToReplace
                        ? .primary : .accentColor
                      : (node.status
                        == LeafStatus.aiToReplace
                        ? .accentColor : .secondary)
                  )
                  .font(.system(size: 14))
                  .padding(5)
              }
              .buttonStyle(PlainButtonStyle())
              .onHover { hovering in
                isHoveringEdit = hovering
              }
            }
          }
        }
      }
    }.onChange(of: node.value) {
      node.resume.debounceExport()
    }
    .padding(.vertical, 4)
    .background(
      node.status == LeafStatus.aiToReplace
        ? Color.accentColor.opacity(0.3) : Color.clear
    )
    .cornerRadius(5)
  }
  private func addLeaf(sibling: TreeNode, refresher: Binding<Bool>) {
    let newNode = TreeNode(
      name: sibling.name,
      value: sibling.value,
      status: LeafStatus.saved,
      resume: sibling.resume
    )
    if sibling.parent != nil {sibling.parent!.addChild(newNode)
      refresher.wrappedValue.toggle()}
  }
  private func deleteNode(node: TreeNode) {

    TreeNode.deleteTreeNode(node: node, context: context)  // Call the deletion function on the node

  }
  private func startEditing() {
    tempValue = node.value
    isEditing = true
  }

  private func saveChanges() {
    node.value = tempValue
    node.status = .saved
    isEditing = false
  }

  private func cancelChanges() {
    isEditing = false
  }

  private func toggleNodeStatus() {
    if node.status == LeafStatus.saved {
      node.status = LeafStatus.aiToReplace
    } else if node.status == LeafStatus.aiToReplace {
      node.status = LeafStatus.saved
    }
  }
}
@ViewBuilder
func HeaderTextRow() -> some View {
  let leadingText = "Résumé Field Values"
  HStack {
    Text(leadingText).font(.headline)
  }
  .cornerRadius(5)
  .padding(.vertical, 2)
}

@ViewBuilder
func AlignedTextRow(
  leadingText: String,
  trailingText: String?,
  nodeStatus: LeafStatus  // Pass the status as a parameter
) -> some View {
  let indent: CGFloat = 100.0
  @State var isHovering = false

  HStack {
    Text(leadingText)
      .foregroundColor(
        nodeStatus == .aiToReplace ? .accentColor : .secondary
      )
      .fontWeight(nodeStatus == .aiToReplace ? .medium : .regular)
      .frame(
        width: (trailingText == nil || trailingText!.isEmpty)
          ? nil : leadingText == "" ? 15 : indent,
        alignment: .leading)

    if let trailingText = trailingText, !trailingText.isEmpty {
      Text(trailingText)
        .foregroundColor(
          nodeStatus == .aiToReplace ? .accentColor : .secondary
        )
        .fontWeight(.regular)
        .frame(
          minWidth: 0, maxWidth: .infinity, alignment: .leading)
    }
  }
  .cornerRadius(5)
  .padding(.vertical, 2)
}
//
//  JSONParser.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/16/24.
//


//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2021 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
import OrderedCollections
import Foundation

internal struct JSONParser {
    var reader: DocumentReader
    var depth: Int = 0

    init(bytes: [UInt8]) {
        self.reader = DocumentReader(array: bytes)
    }

    mutating func parse() throws -> JSONValue {
        try reader.consumeWhitespace()
        let value = try self.parseValue()
        #if DEBUG
        defer {
            guard self.depth == 0 else {
                preconditionFailure("Expected to end parsing with a depth of 0")
            }
        }
        #endif

        // ensure only white space is remaining
        var whitespace = 0
        while let next = reader.peek(offset: whitespace) {
            switch next {
            case ._space, ._tab, ._return, ._newline:
                whitespace += 1
                continue
            default:
                throw JSONError.unexpectedCharacter(ascii: next, characterIndex: reader.readerIndex + whitespace)
            }
        }

        return value
    }

    // MARK: Generic Value Parsing

    mutating func parseValue() throws -> JSONValue {
        var whitespace = 0
        while let byte = reader.peek(offset: whitespace) {
            switch byte {
            case UInt8(ascii: "\""):
                reader.moveReaderIndex(forwardBy: whitespace)
                return .string(try reader.readString())
            case ._openbrace:
                reader.moveReaderIndex(forwardBy: whitespace)
                let object = try parseObject()
                return .object(object)
            case ._openbracket:
                reader.moveReaderIndex(forwardBy: whitespace)
                let array = try parseArray()
                return .array(array)
            case UInt8(ascii: "f"), UInt8(ascii: "t"):
                reader.moveReaderIndex(forwardBy: whitespace)
                let bool = try reader.readBool()
                return .bool(bool)
            case UInt8(ascii: "n"):
                reader.moveReaderIndex(forwardBy: whitespace)
                try reader.readNull()
                return .null
            case UInt8(ascii: "-"), UInt8(ascii: "0") ... UInt8(ascii: "9"):
                reader.moveReaderIndex(forwardBy: whitespace)
                let number = try self.reader.readNumber()
                return .number(number)
            case ._space, ._return, ._newline, ._tab:
                whitespace += 1
                continue
            default:
                throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: self.reader.readerIndex)
            }
        }

        throw JSONError.unexpectedEndOfFile
    }


    // MARK: - Parse Array -

    mutating func parseArray() throws -> [JSONValue] {
        precondition(self.reader.read() == ._openbracket)
        guard self.depth < 512 else {
            throw JSONError.tooManyNestedArraysOrDictionaries(characterIndex: self.reader.readerIndex - 1)
        }
        self.depth += 1
        defer { depth -= 1 }

        // parse first value or end immediatly
        switch try reader.consumeWhitespace() {
        case ._space, ._return, ._newline, ._tab:
            preconditionFailure("Expected that all white space is consumed")
        case ._closebracket:
            // if the first char after whitespace is a closing bracket, we found an empty array
            self.reader.moveReaderIndex(forwardBy: 1)
            return []
        default:
            break
        }

        var array = [JSONValue]()
        array.reserveCapacity(10)

        // parse values
        while true {
            let value = try parseValue()
            array.append(value)

            // consume the whitespace after the value before the comma
            let ascii = try reader.consumeWhitespace()
            switch ascii {
            case ._space, ._return, ._newline, ._tab:
                preconditionFailure("Expected that all white space is consumed")
            case ._closebracket:
                reader.moveReaderIndex(forwardBy: 1)
                return array
            case ._comma:
                // consume the comma
                reader.moveReaderIndex(forwardBy: 1)
                // consume the whitespace before the next value
                if try reader.consumeWhitespace() == ._closebracket {
                    // the foundation json implementation does support trailing commas
                    reader.moveReaderIndex(forwardBy: 1)
                    return array
                }
                continue
            default:
                throw JSONError.unexpectedCharacter(ascii: ascii, characterIndex: reader.readerIndex)
            }
        }
    }

    // MARK: - Object parsing -

    mutating func parseObject() throws -> OrderedDictionary<String, JSONValue> {
        precondition(self.reader.read() == ._openbrace)
        guard self.depth < 512 else {
            throw JSONError.tooManyNestedArraysOrDictionaries(characterIndex: self.reader.readerIndex - 1)
        }
        self.depth += 1
        defer { depth -= 1 }

        // parse first value or end immediatly
        switch try reader.consumeWhitespace() {
        case ._space, ._return, ._newline, ._tab:
            preconditionFailure("Expected that all white space is consumed")
        case ._closebrace:
            // if the first char after whitespace is a closing bracket, we found an empty array
            self.reader.moveReaderIndex(forwardBy: 1)
            return [:]
        default:
            break
        }

        var object = OrderedDictionary<String, JSONValue>()
        object.reserveCapacity(20)

        while true {
            let key = try reader.readString()
            let colon = try reader.consumeWhitespace()
            guard colon == ._colon else {
                throw JSONError.unexpectedCharacter(ascii: colon, characterIndex: reader.readerIndex)
            }
            reader.moveReaderIndex(forwardBy: 1)
            try reader.consumeWhitespace()
            object[key] = try self.parseValue()

            let commaOrBrace = try reader.consumeWhitespace()
            switch commaOrBrace {
            case ._closebrace:
                reader.moveReaderIndex(forwardBy: 1)
                return object
            case ._comma:
                reader.moveReaderIndex(forwardBy: 1)
                if try reader.consumeWhitespace() == ._closebrace {
                    // the foundation json implementation does support trailing commas
                    reader.moveReaderIndex(forwardBy: 1)
                    return object
                }
                continue
            default:
                throw JSONError.unexpectedCharacter(ascii: commaOrBrace, characterIndex: reader.readerIndex)
            }
        }
    }
}

extension JSONParser {

    struct DocumentReader {
        let array: [UInt8]

        private(set) var readerIndex: Int = 0

        private var readableBytes: Int {
            self.array.endIndex - self.readerIndex
        }

        var isEOF: Bool {
            self.readerIndex >= self.array.endIndex
        }


        init(array: [UInt8]) {
            self.array = array
        }

        subscript<R: RangeExpression<Int>>(bounds: R) -> ArraySlice<UInt8> {
            self.array[bounds]
        }

        mutating func read() -> UInt8? {
            guard self.readerIndex < self.array.endIndex else {
                self.readerIndex = self.array.endIndex
                return nil
            }

            defer { self.readerIndex += 1 }

            return self.array[self.readerIndex]
        }

        func peek(offset: Int = 0) -> UInt8? {
            guard self.readerIndex + offset < self.array.endIndex else {
                return nil
            }

            return self.array[self.readerIndex + offset]
        }

        mutating func moveReaderIndex(forwardBy offset: Int) {
            self.readerIndex += offset
        }

        @discardableResult
        mutating func consumeWhitespace() throws -> UInt8 {
            var whitespace = 0
            while let ascii = self.peek(offset: whitespace) {
                switch ascii {
                case ._space, ._return, ._newline, ._tab:
                    whitespace += 1
                    continue
                default:
                    self.moveReaderIndex(forwardBy: whitespace)
                    return ascii
                }
            }

            throw JSONError.unexpectedEndOfFile
        }

        mutating func readString() throws -> String {
            try self.readUTF8StringTillNextUnescapedQuote()
        }

        mutating func readNumber() throws -> String {
            try self.parseNumber()
        }

        mutating func readBool() throws -> Bool {
            switch self.read() {
            case UInt8(ascii: "t"):
                guard self.read() == UInt8(ascii: "r"),
                      self.read() == UInt8(ascii: "u"),
                      self.read() == UInt8(ascii: "e")
                else {
                    guard !self.isEOF else {
                        throw JSONError.unexpectedEndOfFile
                    }

                    throw JSONError.unexpectedCharacter(ascii: self.peek(offset: -1)!, characterIndex: self.readerIndex - 1)
                }

                return true
            case UInt8(ascii: "f"):
                guard self.read() == UInt8(ascii: "a"),
                      self.read() == UInt8(ascii: "l"),
                      self.read() == UInt8(ascii: "s"),
                      self.read() == UInt8(ascii: "e")
                else {
                    guard !self.isEOF else {
                        throw JSONError.unexpectedEndOfFile
                    }

                    throw JSONError.unexpectedCharacter(ascii: self.peek(offset: -1)!, characterIndex: self.readerIndex - 1)
                }

                return false
            default:
                preconditionFailure("Expected to have `t` or `f` as first character")
            }
        }

        mutating func readNull() throws {
            guard self.read() == UInt8(ascii: "n"),
                  self.read() == UInt8(ascii: "u"),
                  self.read() == UInt8(ascii: "l"),
                  self.read() == UInt8(ascii: "l")
            else {
                guard !self.isEOF else {
                    throw JSONError.unexpectedEndOfFile
                }

                throw JSONError.unexpectedCharacter(ascii: self.peek(offset: -1)!, characterIndex: self.readerIndex - 1)
            }
        }

        // MARK: - Private Methods -

        // MARK: String

        enum EscapedSequenceError: Swift.Error {
            case expectedLowSurrogateUTF8SequenceAfterHighSurrogate(index: Int)
            case unexpectedEscapedCharacter(ascii: UInt8, index: Int)
            case couldNotCreateUnicodeScalarFromUInt32(index: Int, unicodeScalarValue: UInt32)
        }

        private mutating func readUTF8StringTillNextUnescapedQuote() throws -> String {
            guard self.read() == ._quote else {
                throw JSONError.unexpectedCharacter(ascii: self.peek(offset: -1)!, characterIndex: self.readerIndex - 1)
            }
            var stringStartIndex = self.readerIndex
            var copy = 0
            var output: String?

            while let byte = peek(offset: copy) {
                switch byte {
                case UInt8(ascii: "\""):
                    self.moveReaderIndex(forwardBy: copy + 1)
                    guard var result = output else {
                        // if we don't have an output string we create a new string
                        return try makeString(at: stringStartIndex ..< stringStartIndex + copy)
                    }
                    // if we have an output string we append
                    result += try makeString(at: stringStartIndex ..< stringStartIndex + copy)
                    return result

                case 0 ... 31:
                    // All Unicode characters may be placed within the
                    // quotation marks, except for the characters that must be escaped:
                    // quotation mark, reverse solidus, and the control characters (U+0000
                    // through U+001F).
                    var string = output ?? ""
                    let errorIndex = self.readerIndex + copy
                    string += try makeString(at: stringStartIndex ... errorIndex)
                    throw JSONError.unescapedControlCharacterInString(ascii: byte, in: string, index: errorIndex)

                case UInt8(ascii: "\\"):
                    self.moveReaderIndex(forwardBy: copy)
                    if output != nil {
                        output! += try makeString(at: stringStartIndex ..< stringStartIndex + copy)
                    } else {
                        output = try makeString(at: stringStartIndex ..< stringStartIndex + copy)
                    }

                    let escapedStartIndex = self.readerIndex

                    do {
                        let escaped = try parseEscapeSequence()
                        output! += escaped
                        stringStartIndex = self.readerIndex
                        copy = 0
                    } catch EscapedSequenceError.unexpectedEscapedCharacter(let ascii, let failureIndex) {
                        output! += try makeString(at: escapedStartIndex ..< self.readerIndex)
                        throw JSONError.unexpectedEscapedCharacter(ascii: ascii, in: output!, index: failureIndex)
                    } catch EscapedSequenceError.expectedLowSurrogateUTF8SequenceAfterHighSurrogate(let failureIndex) {
                        output! += try makeString(at: escapedStartIndex ..< self.readerIndex)
                        throw JSONError.expectedLowSurrogateUTF8SequenceAfterHighSurrogate(in: output!, index: failureIndex)
                    } catch EscapedSequenceError.couldNotCreateUnicodeScalarFromUInt32(let failureIndex, let unicodeScalarValue) {
                        output! += try makeString(at: escapedStartIndex ..< self.readerIndex)
                        throw JSONError.couldNotCreateUnicodeScalarFromUInt32(
                            in: output!, index: failureIndex, unicodeScalarValue: unicodeScalarValue
                        )
                    }

                default:
                    copy += 1
                    continue
                }
            }

            throw JSONError.unexpectedEndOfFile
        }

        private func makeString<R: RangeExpression<Int>>(at range: R) throws -> String {
            let raw = array[range]
            guard let str = String(bytes: raw, encoding: .utf8) else {
                throw JSONError.invalidUTF8Sequence(Data(raw), characterIndex: range.relative(to: array).lowerBound)
            }
            return str
        }

        private mutating func parseEscapeSequence() throws -> String {
            precondition(self.read() == ._backslash, "Expected to have an backslash first")
            guard let ascii = self.read() else {
                throw JSONError.unexpectedEndOfFile
            }

            switch ascii {
            case 0x22: return "\""
            case 0x5C: return "\\"
            case 0x2F: return "/"
            case 0x62: return "\u{08}" // \b
            case 0x66: return "\u{0C}" // \f
            case 0x6E: return "\u{0A}" // \n
            case 0x72: return "\u{0D}" // \r
            case 0x74: return "\u{09}" // \t
            case 0x75:
                let character = try parseUnicodeSequence()
                return String(character)
            default:
                throw EscapedSequenceError.unexpectedEscapedCharacter(ascii: ascii, index: self.readerIndex - 1)
            }
        }

        private mutating func parseUnicodeSequence() throws -> Unicode.Scalar {
            // we build this for utf8 only for now.
            let bitPattern = try parseUnicodeHexSequence()

            // check if high surrogate
            let isFirstByteHighSurrogate = bitPattern & 0xFC00 // nil everything except first six bits
            if isFirstByteHighSurrogate == 0xD800 {
                // if we have a high surrogate we expect a low surrogate next
                let highSurrogateBitPattern = bitPattern
                guard let (escapeChar) = self.read(),
                      let (uChar) = self.read()
                else {
                    throw JSONError.unexpectedEndOfFile
                }

                guard escapeChar == UInt8(ascii: #"\"#), uChar == UInt8(ascii: "u") else {
                    throw EscapedSequenceError.expectedLowSurrogateUTF8SequenceAfterHighSurrogate(index: self.readerIndex - 1)
                }

                let lowSurrogateBitBattern = try parseUnicodeHexSequence()
                let isSecondByteLowSurrogate = lowSurrogateBitBattern & 0xFC00 // nil everything except first six bits
                guard isSecondByteLowSurrogate == 0xDC00 else {
                    // we are in an escaped sequence. for this reason an output string must have
                    // been initialized
                    throw EscapedSequenceError.expectedLowSurrogateUTF8SequenceAfterHighSurrogate(index: self.readerIndex - 1)
                }

                let highValue = UInt32(highSurrogateBitPattern - 0xD800) * 0x400
                let lowValue = UInt32(lowSurrogateBitBattern - 0xDC00)
                let unicodeValue = highValue + lowValue + 0x10000
                guard let unicode = Unicode.Scalar(unicodeValue) else {
                    throw EscapedSequenceError.couldNotCreateUnicodeScalarFromUInt32(
                        index: self.readerIndex, unicodeScalarValue: unicodeValue
                    )
                }
                return unicode
            }

            guard let unicode = Unicode.Scalar(bitPattern) else {
                throw EscapedSequenceError.couldNotCreateUnicodeScalarFromUInt32(
                    index: self.readerIndex, unicodeScalarValue: UInt32(bitPattern)
                )
            }
            return unicode
        }

        private mutating func parseUnicodeHexSequence() throws -> UInt16 {
            // As stated in RFC-8259 an escaped unicode character is 4 HEXDIGITs long
            // https://tools.ietf.org/html/rfc8259#section-7
            let startIndex = self.readerIndex
            guard let firstHex = self.read(),
                  let secondHex = self.read(),
                  let thirdHex = self.read(),
                  let forthHex = self.read()
            else {
                throw JSONError.unexpectedEndOfFile
            }

            guard let first = DocumentReader.hexAsciiTo4Bits(firstHex),
                  let second = DocumentReader.hexAsciiTo4Bits(secondHex),
                  let third = DocumentReader.hexAsciiTo4Bits(thirdHex),
                  let forth = DocumentReader.hexAsciiTo4Bits(forthHex)
            else {
                let hexString = String(decoding: [firstHex, secondHex, thirdHex, forthHex], as: Unicode.UTF8.self)
                throw JSONError.invalidHexDigitSequence(hexString, index: startIndex)
            }
            let firstByte = UInt16(first) << 4 | UInt16(second)
            let secondByte = UInt16(third) << 4 | UInt16(forth)

            let bitPattern = UInt16(firstByte) << 8 | UInt16(secondByte)

            return bitPattern
        }

        private static func hexAsciiTo4Bits(_ ascii: UInt8) -> UInt8? {
            switch ascii {
            case 48 ... 57:
                return ascii - 48
            case 65 ... 70:
                // uppercase letters
                return ascii - 55
            case 97 ... 102:
                // lowercase letters
                return ascii - 87
            default:
                return nil
            }
        }

        // MARK: Numbers

        private enum ControlCharacter {
            case operand
            case decimalPoint
            case exp
            case expOperator
        }

        private mutating func parseNumber() throws -> String {
            var pastControlChar: ControlCharacter = .operand
            var numbersSinceControlChar: UInt = 0
            var hasLeadingZero = false

            // parse first character

            guard let ascii = self.peek() else {
                preconditionFailure("Why was this function called, if there is no 0...9 or -")
            }
            switch ascii {
            case UInt8(ascii: "0"):
                numbersSinceControlChar = 1
                pastControlChar = .operand
                hasLeadingZero = true
            case UInt8(ascii: "1") ... UInt8(ascii: "9"):
                numbersSinceControlChar = 1
                pastControlChar = .operand
            case UInt8(ascii: "-"):
                numbersSinceControlChar = 0
                pastControlChar = .operand
            default:
                preconditionFailure("Why was this function called, if there is no 0...9 or -")
            }

            var numberchars = 1

            // parse everything else
            while let byte = self.peek(offset: numberchars) {
                switch byte {
                case UInt8(ascii: "0"):
                    if hasLeadingZero {
                        throw JSONError.numberWithLeadingZero(index: readerIndex + numberchars)
                    }
                    if numbersSinceControlChar == 0, pastControlChar == .operand {
                        // the number started with a minus. this is the leading zero.
                        hasLeadingZero = true
                    }
                    numberchars += 1
                    numbersSinceControlChar += 1
                case UInt8(ascii: "1") ... UInt8(ascii: "9"):
                    if hasLeadingZero {
                        throw JSONError.numberWithLeadingZero(index: readerIndex + numberchars)
                    }
                    numberchars += 1
                    numbersSinceControlChar += 1
                case UInt8(ascii: "."):
                    guard numbersSinceControlChar > 0, pastControlChar == .operand else {
                        throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: readerIndex + numberchars)
                    }

                    numberchars += 1
                    hasLeadingZero = false
                    pastControlChar = .decimalPoint
                    numbersSinceControlChar = 0

                case UInt8(ascii: "e"), UInt8(ascii: "E"):
                    guard numbersSinceControlChar > 0,
                          pastControlChar == .operand || pastControlChar == .decimalPoint
                    else {
                        throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: readerIndex + numberchars)
                    }

                    numberchars += 1
                    hasLeadingZero = false
                    pastControlChar = .exp
                    numbersSinceControlChar = 0
                case UInt8(ascii: "+"), UInt8(ascii: "-"):
                    guard numbersSinceControlChar == 0, pastControlChar == .exp else {
                        throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: readerIndex + numberchars)
                    }

                    numberchars += 1
                    pastControlChar = .expOperator
                    numbersSinceControlChar = 0
                case ._space, ._return, ._newline, ._tab, ._comma, ._closebracket, ._closebrace:
                    guard numbersSinceControlChar > 0 else {
                        throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: readerIndex + numberchars)
                    }
                    let numberStartIndex = self.readerIndex
                    self.moveReaderIndex(forwardBy: numberchars)

                    return String(decoding: self[numberStartIndex ..< self.readerIndex], as: Unicode.UTF8.self)
                default:
                    throw JSONError.unexpectedCharacter(ascii: byte, characterIndex: readerIndex + numberchars)
                }
            }

            guard numbersSinceControlChar > 0 else {
                throw JSONError.unexpectedEndOfFile
            }

            defer { self.readerIndex = self.array.endIndex }
            return String(decoding: self.array.suffix(from: readerIndex), as: Unicode.UTF8.self)
        }
    }
}

extension UInt8 {

    internal static let _space = UInt8(ascii: " ")
    internal static let _return = UInt8(ascii: "\r")
    internal static let _newline = UInt8(ascii: "\n")
    internal static let _tab = UInt8(ascii: "\t")

    internal static let _colon = UInt8(ascii: ":")
    internal static let _comma = UInt8(ascii: ",")

    internal static let _openbrace = UInt8(ascii: "{")
    internal static let _closebrace = UInt8(ascii: "}")

    internal static let _openbracket = UInt8(ascii: "[")
    internal static let _closebracket = UInt8(ascii: "]")

    internal static let _quote = UInt8(ascii: "\"")
    internal static let _backslash = UInt8(ascii: "\\")

}

extension Array where Element == UInt8 {

    internal static let _true = [UInt8(ascii: "t"), UInt8(ascii: "r"), UInt8(ascii: "u"), UInt8(ascii: "e")]
    internal static let _false = [UInt8(ascii: "f"), UInt8(ascii: "a"), UInt8(ascii: "l"), UInt8(ascii: "s"), UInt8(ascii: "e")]
    internal static let _null = [UInt8(ascii: "n"), UInt8(ascii: "u"), UInt8(ascii: "l"), UInt8(ascii: "l")]

}

enum JSONError: Swift.Error, Equatable {
    case cannotConvertInputDataToUTF8
    case unexpectedCharacter(ascii: UInt8, characterIndex: Int)
    case unexpectedEndOfFile
    case tooManyNestedArraysOrDictionaries(characterIndex: Int)
    case invalidHexDigitSequence(String, index: Int)
    case unexpectedEscapedCharacter(ascii: UInt8, in: String, index: Int)
    case unescapedControlCharacterInString(ascii: UInt8, in: String, index: Int)
    case expectedLowSurrogateUTF8SequenceAfterHighSurrogate(in: String, index: Int)
    case couldNotCreateUnicodeScalarFromUInt32(in: String, index: Int, unicodeScalarValue: UInt32)
    case numberWithLeadingZero(index: Int)
    case numberIsNotRepresentableInSwift(parsed: String)
    case singleFragmentFoundButNotAllowed
    case invalidUTF8Sequence(Data, characterIndex: Int)
}

enum JSONValue: Equatable {
    case null
    case array([JSONValue])
    case object(OrderedDictionary<String, JSONValue>)
    case bool(Bool)
    case string(String)
    case number(String)

    func unwrap() throws -> Any {
        switch self {
        case .null: return NSNull()
        case let .array(values): return try values.map { try $0.unwrap() }
        case let .object(object): return try object.mapValues { try $0.unwrap() }
        case let .bool(bool): return NSNumber(value: bool)
        case let .string(string): return string
        case let .number(string):
            let formatter = NumberFormatter()
            formatter.numberStyle = .decimal
            guard let number = formatter.number(from: string) else {
                throw JSONError.numberIsNotRepresentableInSwift(parsed: string)
            }
            return number
        }
    }
}
