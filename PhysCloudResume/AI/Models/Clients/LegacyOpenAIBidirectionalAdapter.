//
//  LegacyOpenAIBidirectionalAdapter.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 5/20/25.
//

import Foundation
import SwiftOpenAI

/// Bidirectional adapter that implements both OpenAIClientProtocol and AppLLMClientProtocol
/// This allows seamless transition between old and new interfaces
@available(*, deprecated, message: "Use AppLLMClientProtocol directly instead")
class LegacyOpenAIBidirectionalAdapter: LegacyOpenAIClientAdapter, AppLLMClientProtocol {
    // MARK: - AppLLMClientProtocol Implementation
    
    /// Executes a query expecting a single, non-streaming response (text or structured).
    /// - Parameter query: The query to execute
    /// - Returns: The response from the LLM
    func executeQuery(_ query: AppLLMQuery) async throws -> AppLLMResponse {
        // Convert AppLLMMessages to ChatMessages
        let chatMessages = query.messages.map { MessageConverter.chatMessageFrom(appMessage: $0) }
        
        // Handle structured output query
        if let responseType = query.desiredResponseType {
            // We need to use the StructuredOutput protocol for OpenAIClientProtocol
            // So we need to make sure the type conforms to StructuredOutput
            guard let structuredType = responseType as? any StructuredOutput.Type else {
                throw AppLLMError.clientError("Structured output type must conform to StructuredOutput protocol")
            }
            
            // Since we can't use the generic directly with type erasure, we'll use reflection
            // This is a bit hacky but necessary for the adapter pattern
            do {
                // Create a mirror of the responseType
                let typeName = String(describing: responseType)
                
                // Execute the appropriate method based on type
                if typeName.contains("RevisionsContainer") {
                    // Special case for RevisionsContainer
                    let result = try await sendChatCompletionWithStructuredOutput(
                        messages: chatMessages,
                        model: query.modelIdentifier,
                        temperature: query.temperature,
                        structuredOutputType: RevisionsContainer.self
                    )
                    let data = try JSONEncoder().encode(result)
                    return AppLLMResponse.structured(data)
                } 
                else {
                    // Generic case - try to encode raw response
                    let resultData = try await sendChatCompletionAsync(
                        messages: chatMessages,
                        model: query.modelIdentifier,
                        responseFormat: query.jsonSchema != nil ? .jsonObject : nil,
                        temperature: query.temperature
                    )
                    
                    // If we got JSON data, return it as structured
                    if let jsonData = resultData.content.data(using: .utf8) {
                        return AppLLMResponse.structured(jsonData)
                    } else {
                        return AppLLMResponse.text(resultData.content)
                    }
                }
            } catch {
                throw AppLLMError.clientError("Error executing structured query: \(error.localizedDescription)")
            }
        } 
        // Regular text query
        else {
            do {
                let result = try await sendChatCompletionAsync(
                    messages: chatMessages,
                    model: query.modelIdentifier,
                    responseFormat: nil,
                    temperature: query.temperature
                )
                return AppLLMResponse.text(result.content)
            } catch {
                throw AppLLMError.clientError("Error executing text query: \(error.localizedDescription)")
            }
        }
    }
}
