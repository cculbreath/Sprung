// ===== FILE: ./Models/ResumeModels/Resume.swift =====
import Foundation
import PDFKit
import SwiftData
import SwiftUI

@Model
class Resume: Identifiable, Hashable {
    @Attribute(.unique) var id: UUID = UUID()

    var needToTree: Bool = true
    var needToFont: Bool = true

    @Relationship(deleteRule: .cascade)
    var rootNode: TreeNode? // The top-level node
    var fontSizeNodes: [FontSizeNode] = []
    var keyLabels: [String: String] = [:]
    var importedEditorKeys: [String] = []
    func label(_ key: String) -> String {
        if let myLabel = keyLabels[key] {
            return myLabel
        } else {
            return key
        }
    }

    var nodes: [TreeNode] = []

    var dateCreated: Date = Date()
    weak var jobApp: JobApp?

    @Relationship(deleteRule: .nullify, inverse: \ResRef.enabledResumes)
    var enabledSources: [ResRef]

    var model: ResModel? = nil // Now properly annotated
    var createdDateString: String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "hh:mm a 'on' MM/dd/yy"
        return dateFormatter.string(from: dateCreated)
    }

    var textRes: String = ""

    var isUpdating: Bool = false
    var pdfData: Data?
    var jsonTxt: String {
        if let myRoot = rootNode, let json = TreeToJson(rootNode: myRoot)?.buildJsonString() {
            return json
        } else { return "" }
    }

    // Example function
    func getUpdatableNodes() -> [[String: String]] {
        if let node = rootNode {
            return TreeNode.traverseAndExportNodes(node: node)
        } else {
            return [[:]]
        }
    }

    var meta: String = "\"format\": \"FRESH@0.6.0\", \"version\": \"0.1.0\""

    // Updated initializer to require `resumeModel`
    init(
        jobApp: JobApp,
        enabledSources: [ResRef],
        model: ResModel // Added parameter
    ) {
        self.model = model // Set the required property
        self.jobApp = jobApp
        dateCreated = Date()
        self.enabledSources = enabledSources
    }

    func generateQuery() -> ResumeApiQuery {
        return ResumeApiQuery(resume: self)
    }

    func loadPDF(from fileURL: URL = FileHandler.pdfUrl()) {
        DispatchQueue.global(qos: .background).async { [weak self] in
            do {
                let data = try Data(contentsOf: fileURL)
                DispatchQueue.main.async {
                    self?.pdfData = data
                    self?.isUpdating = false
                }
            } catch {
                DispatchQueue.main.async {
                    print("Failed to load PDF file: \(error.localizedDescription)")
                    self?.isUpdating = false
                }
            }
        }
    }

    func displayPDF() -> PDFView? {
        guard let pdfData else { return nil }
        let pdfView = PDFView()
        DispatchQueue.main.async {
            if let document = PDFDocument(data: pdfData) {
                pdfView.document = document
                pdfView.autoScales = true
            }
        }
        return pdfView
    }

    @Transient private var exportWorkItem: DispatchWorkItem?

    func debounceExport() {
        print("pdf refresh")
        isUpdating = true
        exportWorkItem?.cancel()

        exportWorkItem = DispatchWorkItem { [weak self] in
            guard let self = self else { return }
            if let jsonFile = FileHandler.saveJSONToFile(jsonString: jsonTxt) {
                apiGenerateResFromJson(jsonPath: jsonFile, resume: self) { success in
                    DispatchQueue.main.async {
                        self.isUpdating = !success
                    }
                }
            }
        }

        // Delay half a second before exporting
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: exportWorkItem!)
    }

    // MARK: - Hashable

    static func == (lhs: Resume, rhs: Resume) -> Bool {
        lhs.id == rhs.id
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }
}


// ===== FILE: ./Models/ResumeModels/FontSizeNode.swift =====
//
//  FontSizeNode.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 2/2/25.
//
import Foundation
import SwiftData

@Model class FontSizeNode: Identifiable {
    var id = UUID().uuidString
    var key: String = ""
    static var counter: Int = 0
    var index: Int = -1
    var fontValue: Float
    var fontString: String {
        get {
            return "\(fontValue)pt"
        }
        set {
            fontValue = FontSizeNode.parseFontString(newValue)
        }
    }

    init(
        id: String = UUID().uuidString,
        key: String,
        fontString: String

    ) {
        let myIndex = FontSizeNode.counter + 1
        index = myIndex
        FontSizeNode.counter = myIndex
        self.id = id
        self.key = key
        fontValue = FontSizeNode.parseFontString(fontString)
    }

    /// Converts a "12pt" style string to a Float value
    private static func parseFontString(_ fontString: String) -> Float {
        let trimmed = fontString.trimmingCharacters(in: .whitespacesAndNewlines)
        return Float(trimmed.replacingOccurrences(of: "pt", with: "").trimmingCharacters(in: .whitespaces)) ?? 10
    }

    var keyToTitle: String {
        let lowercaseWords: Set<String> = ["and", "of", "or", "the", "a", "an", "in", "on", "at", "to", "for", "but", "nor", "so", "yet", "with", "by", "as", "from", "about", "into", "over", "after", "before", "between", "under", "without", "against", "during", "upon"]

        let words = key
            .replacingOccurrences(of: "-", with: " ")
            .split(separator: " ")
            .enumerated()
            .map { index, word in
                let lowercaseWord = word.lowercased()
                return (index == 0 || !lowercaseWords.contains(lowercaseWord)) ? lowercaseWord.capitalized : lowercaseWord
            }

        return words.joined(separator: " ")
    }
}


// ===== FILE: ./Models/ResRef Models/ResModel.swift =====
import Foundation
import SwiftData

@Model
class ResModel: Identifiable, Equatable, Hashable {
    static var defaultStyle: String = ""
    var id: UUID
    var dateCreated: Date = Date()
    @Relationship(deleteRule: .cascade, inverse: \Resume.model) var resumes: [Resume]
    var name: String
    var json: String
    var renderedResumeText: String
    var style: String

    // Override the initializer to set the type to '.jsonSource'
    init(
        resumes: [Resume] = [],
        name: String,
        json: String,
        renderedResumeText: String,
        style: String = ResModel.defaultStyle
    ) {
        id = UUID()
        self.resumes = resumes
        self.name = name
        self.json = json
        self.renderedResumeText = renderedResumeText
        self.style = style
    }
}


// ===== FILE: ./Models/ResRef Models/ResRef.swift =====
import Foundation
import SwiftData

@Model
class ResRef: Identifiable {
    var id: UUID // Change from String to UUID
    var content: String
    var name: String
    var enabledByDefault: Bool

    var enabledResumes: [Resume] = []

    init(
        name: String = "", content: String = "",
        enabledByDefault: Bool = false
    ) {
        id = UUID() // Ensure UUID is used correctly
        self.content = content
        self.name = name
        self.enabledByDefault = enabledByDefault
    }
}


// ===== FILE: ./Models/CoverRef Models/CoverRef.swift =====
import Foundation
import SwiftData

enum CoverRefType: String, Codable {
    case writingSample
    case backgroundFact
}

@Model
class CoverRef: Identifiable, Codable {
    var id: String
    var content: String
    var name: String
    var enabledByDefault: Bool
    var type: CoverRefType

    init(
        name: String = "", content: String = "",
        enabledByDefault: Bool = false, type: CoverRefType
    ) {
        id = UUID().uuidString
        self.content = content
        self.name = name
        self.enabledByDefault = enabledByDefault
        self.type = type
    }

    // Manual Codable implementation
    enum CodingKeys: String, CodingKey {
        case id
        case content
        case name
        case enabledByDefault
        case type
    }

    // Required initializer for Decodable
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        content = try container.decode(String.self, forKey: .content)
        name = try container.decode(String.self, forKey: .name)
        enabledByDefault = try container.decode(Bool.self, forKey: .enabledByDefault)
        type = try container.decode(CoverRefType.self, forKey: .type)
    }

    // Required function for Encodable
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(content, forKey: .content)
        try container.encode(name, forKey: .name)
        try container.encode(enabledByDefault, forKey: .enabledByDefault)
        try container.encode(type, forKey: .type)
    }
}


// ===== FILE: ./Models/JobAppModels/JobApp.swift =====
import Foundation
import SwiftData
import SwiftUI

enum Statuses: String, Codable, CaseIterable {
    case new = "New"
    case inProgress = "In Progress"
    case unsubmitted = "Unsubmitted"
    case submitted = "Submitted"
    case interview = "Interview Pending"
    case closed = "Closed"
    case followUp = "Follow up Required"
    case abandonned = "Abandonned"
    case rejected = "Rejected"
}

@Model class JobApp: Equatable, Identifiable, Decodable, Hashable {
    @Attribute(.unique) var id: UUID = UUID()

    static func == (lhs: JobApp, rhs: JobApp) -> Bool {
        lhs.id == rhs.id
    }

    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
    }

    @Relationship(deleteRule: .cascade, inverse: \Resume.jobApp)
    var resumes: [Resume] {
        didSet {
            objectWillChange.send()
            print("resumeAppendedToJobApp")
        }
    }

    @Relationship(deleteRule: .cascade, inverse: \CoverLetter.jobApp)
    var coverLetters: [CoverLetter] = []
    var selectedResId: UUID?
    var selectedCoverId: UUID?

    var selectedRes: Resume? {
        get {
            if let id = selectedResId {
                return resumes.first(where: { $0.id == id })
            } else if resumes.isEmpty {
                return nil
            } else { return resumes.last }
        }
        set {
            selectedResId = newValue?.id
        }
    }

    var selectedCover: CoverLetter? {
        get {
            if let id = selectedCoverId {
                return coverLetters.first(where: { $0.id == id })
            }
            return coverLetters.last
        }
        set {
            selectedCoverId = newValue?.id
        }
    }

    var job_position: String
    var job_location: String
    var company_name: String
    var company_linkedin_id: String = ""
    var job_posting_time: String = ""
    var job_description: String
    var seniority_level: String = ""
    var employment_type: String = ""
    var job_function: String = ""
    var industries: String = ""
    var job_apply_link: String = ""
    var posting_url: String = ""
    var status: Statuses = Statuses.new
    var notes: String = ""

    enum CodingKeys: String, CodingKey {
        case job_position
        case job_location
        case company_name
        case company_linkedin_id
        case job_posting_time
        case job_description
        case seniority_level
        case employment_type
        case job_function
        case industries
        case job_apply_link
        case resumes
        case coverLetters
        case selectedRes
        case status
        case posting_url
    }

    var jobListingString: String {
        var descriptionParts: [String] = []

        descriptionParts.append("Job Position: \(job_position)")
        descriptionParts.append("Job Location: \(job_location)")
        descriptionParts.append("Company Name: \(company_name)")

        if !company_linkedin_id.isEmpty {
            descriptionParts.append("Company LinkedIn ID: \(company_linkedin_id)")
        }

        if !job_posting_time.isEmpty {
            descriptionParts.append("Job Posting Time: \(job_posting_time)")
        }

        if !seniority_level.isEmpty {
            descriptionParts.append("Seniority Level: \(seniority_level)")
        }

        if !employment_type.isEmpty {
            descriptionParts.append("Employment Type: \(employment_type)")
        }

        if !job_function.isEmpty {
            descriptionParts.append("Job Function: \(job_function)")
        }

        if !industries.isEmpty {
            descriptionParts.append("Industries: \(industries)")
        }

        if !job_description.isEmpty {
            descriptionParts.append("Job Description: \(job_description)")
        }

        return descriptionParts.joined(separator: "\n")
    }

    @ViewBuilder
    var statusTag: some View {
        switch status {
        case .new:
            RoundedTagView(tagText: "New", backgroundColor: .green, foregroundColor: .white)
        case .inProgress:
            RoundedTagView(tagText: "In Progress", backgroundColor: .mint, foregroundColor: .white)
        case .unsubmitted:
            RoundedTagView(tagText: "Unsubmitted", backgroundColor: .cyan, foregroundColor: .white)
        case .submitted:
            RoundedTagView(tagText: "Submitted", backgroundColor: .indigo, foregroundColor: .white)
        case .interview:
            RoundedTagView(tagText: "Interview", backgroundColor: .pink, foregroundColor: .white)
        case .closed:
            RoundedTagView(tagText: "Closed", backgroundColor: .gray, foregroundColor: .white)
        case .followUp:
            RoundedTagView(tagText: "Follow Up", backgroundColor: .yellow, foregroundColor: .white)
        case .abandonned:
            RoundedTagView(tagText: "Abandoned", backgroundColor: .secondary, foregroundColor: .white)
        case .rejected:
            RoundedTagView(tagText: "Rejected", backgroundColor: .black, foregroundColor: .white)
        }
    }

    static func pillColor(_ myCase: String) -> Color {
        let myCase = myCase.lowercased()
        switch myCase {
        case "closed": return Color.gray
        case "follow up": return Color.yellow
        case "interview": return Color.pink
        case "submitted": return Color.indigo
        case "unsubmitted": return Color.cyan
        case "in progress": return Color.mint
        case "new": return Color.green
        case "abandonned": return .secondary
        case "rejected": return Color.black
        default: return Color.black
        }
    }

    init(
        job_position: String = "",
        job_location: String = "",
        company_name: String = "",
        company_linkedin_id: String = "",
        job_posting_time: String = "",
        job_description: String = "",
        seniority_level: String = "",
        employment_type: String = "",
        job_function: String = "",
        industries: String = "",
        job_apply_link: String = "",
        posting_url: String = ""
    ) {
        self.job_position = job_position
        self.job_location = job_location
        self.company_name = company_name
        self.company_linkedin_id = company_linkedin_id
        self.job_posting_time = job_posting_time
        self.job_description = job_description
        self.seniority_level = seniority_level
        self.employment_type = employment_type
        self.job_function = job_function
        self.industries = industries
        self.job_apply_link = job_apply_link
        self.posting_url = posting_url
        resumes = []
    }

    var hasAnyRes: Bool { return !resumes.isEmpty }
    func addResume(_ resume: Resume) {
        // Ensure uniqueness
        if !resumes.contains(where: { $0.id == resume.id }) {
            resumes.append(resume)
            selectedRes = resume
            print("JobApp resume added, jobApp.hasAnyResume is \(hasAnyRes ? "true" : "false")")
        } else {
            if resumes.isEmpty {
                print("Uniqueness test fails: resumes array is empty")
            } else {
                for (index, resume) in resumes.enumerated() {
                    print("resume array \(index): \(resume.createdDateString)")
                }
            }
        }

        if selectedRes == nil {
            selectedRes = resume
            print("selected res set to newly added res")
        }
    }

    func resumeDeletePrep(candidate: Resume) {
        if selectedRes == candidate {
            if resumes.count == 1 {
                selectedRes = nil
                print("SelREs nil")
            } else {
                selectedRes = resumes.first(where: { $0.id != candidate.id })
                print("sel res reassigned")
            }
        }
        print("no change to selRes required. It's another object")
    }

    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        job_position = try container.decode(String.self, forKey: .job_position)
        job_location = try container.decode(String.self, forKey: .job_location)
        company_name = try container.decode(String.self, forKey: .company_name)
        company_linkedin_id = try container.decodeIfPresent(String.self, forKey: .company_linkedin_id) ?? ""
        job_posting_time = try container.decodeIfPresent(String.self, forKey: .job_posting_time) ?? ""
        job_description = try container.decode(String.self, forKey: .job_description)
        seniority_level = try container.decodeIfPresent(String.self, forKey: .seniority_level) ?? ""
        employment_type = try container.decodeIfPresent(String.self, forKey: .employment_type) ?? ""
        job_function = try container.decodeIfPresent(String.self, forKey: .job_function) ?? ""
        industries = try container.decodeIfPresent(String.self, forKey: .industries) ?? ""
        job_apply_link = try container.decodeIfPresent(String.self, forKey: .job_apply_link) ?? ""
        status = try container.decodeIfPresent(Statuses.self, forKey: .status) ?? .new
        resumes = []
    }

    public func assignPropsFromForm(_ sourceJobAppForm: JobAppForm) {
        job_position = sourceJobAppForm.job_position
        job_location = sourceJobAppForm.job_location
        company_name = sourceJobAppForm.company_name
        company_linkedin_id = sourceJobAppForm.company_linkedin_id
        job_posting_time = sourceJobAppForm.job_posting_time
        job_description = sourceJobAppForm.job_description
        seniority_level = sourceJobAppForm.seniority_level
        employment_type = sourceJobAppForm.employment_type
        job_function = sourceJobAppForm.job_function
        industries = sourceJobAppForm.industries
        job_apply_link = sourceJobAppForm.job_apply_link
        posting_url = sourceJobAppForm.posting_url
    }
}


// ===== FILE: ./Models/CoverLetterModels/CoverLetter.swift =====
import Foundation
import SwiftData
import SwiftOpenAI

@Model
class CoverLetter: Identifiable, Hashable {
    var jobApp: JobApp? = nil
    @Attribute(.unique) var id: UUID = UUID() // Explicit id field
    var createdDate: Date = Date()
    var moddedDate: Date = Date()
    var content: String = ""
    var generated: Bool = false
    var includeResumeRefs: Bool = false
    var encodedEnabledRefs: Data? // Store as Data
    var encodedMessageHistory: Data? // Store as Data
    var currentMode: CoverAiMode? = CoverAiMode.none
    var editorPrompt: CoverLetterPrompts.EditorPrompts = CoverLetterPrompts.EditorPrompts.zissner
    var modDate: String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "hh:mm a 'on' MM/dd/yy"
        return dateFormatter.string(from: moddedDate)
    }

    // Computed properties to decode arrays
    var enabledRefs: [CoverRef] {
        get {
            guard let data = encodedEnabledRefs else { return [] }
            return (try? JSONDecoder().decode([CoverRef].self, from: data)) ?? []
        }
        set {
            encodedEnabledRefs = try? JSONEncoder().encode(newValue)
        }
    }

    var messageHistory: [MessageParams] {
        get {
            guard let data = encodedMessageHistory else {
                return []
            }
            do {
                return try JSONDecoder().decode([MessageParams].self, from: data)
            } catch {
                fatalError("Failed to decode messageHistory: \(error.localizedDescription)")
            }
        }
        set {
            do {
                encodedMessageHistory = try JSONEncoder().encode(newValue)

            } catch {
                fatalError("Failed to encode messageHistory: \(error.localizedDescription)")
            }
        }
    }

    init(
        enabledRefs: [CoverRef],
        jobApp: JobApp?
    ) {
        encodedEnabledRefs = try? JSONEncoder().encode(enabledRefs)
        self.jobApp = jobApp ?? nil
    }

    var backgroundItemsString: String {
        return enabledRefs.filter { $0.type == CoverRefType.backgroundFact }
            .map { $0.content }.joined(separator: "\n\n")
    }

    var writingSamplesString: String {
        return enabledRefs.filter { $0.type == CoverRefType.writingSample }
            .map { $0.content }.joined(separator: "\n\n")
    }
}

@Model
class MessageParams: Identifiable, Codable {
    var id: String = UUID().uuidString
    var content: String
    var role: MessageRole

    init(content: String, role: MessageRole) {
        self.content = content
        self.role = role
    }

    // Manual Codable implementation
    enum CodingKeys: String, CodingKey {
        case id
        case content
        case role
    }

    // Required initializer for Decodable
    required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        content = try container.decode(String.self, forKey: .content)
        role = try container.decode(MessageRole.self, forKey: .role)
    }

    // Required function for Encodable
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(content, forKey: .content)
        try container.encode(role, forKey: .role)
    }

    // Make MessageRole conform to Codable
    enum MessageRole: String, Codable {
        case user
        case assistant
        case system
        case none
    }
}


// ===== FILE: ./Models/ResumeTreeModels/TreeNodeModel.swift =====
import Foundation
import SwiftData
import SwiftUI

enum LeafStatus: String, Codable, Hashable {
    case isEditing
    case aiToReplace
    case disabled = "leafDisabled"
    case saved = "leafValueSaved"
    case isNotLeaf = "nodeIsNotLeaf"
}

// Example SwiftData model

@Model class TreeNode: Identifiable {
    var id = UUID().uuidString
    var name: String = ""
    var value: String
    var includeInEditor: Bool = false
    var myIndex: Int = -1
    var isEditing: Bool = false
    public static var childIndexer = 0
    @Relationship(deleteRule: .cascade) var children: [TreeNode]? = nil
    weak var parent: TreeNode?
    var label: String { return resume.label(name) }
    @Relationship(deleteRule: .noAction) var resume: Resume
    var status: LeafStatus
    private(set) var nodeDepth: Int
    var depth: Int {
        var current = self
        var depthCount = 0

        while let parent = current.parent {
            depthCount += 1
            current = parent
        }

        return depthCount
    }

    var hasChildren: Bool {
        return !(children?.isEmpty ?? true)
    }

    var aiStatusChildren: Int {
        var count = 0

        // Check if the current node has the desired status
        if status == .aiToReplace {
            count += 1
        }

        // Recursively count the descendants with the desired status
        if let children = children {
            for child in children {
                count += child.aiStatusChildren
            }
        }

        return count
    }

    init(
        name: String, value: String = "", children: [TreeNode]? = nil,
        parent: TreeNode? = nil, inEditor: Bool, status: LeafStatus = LeafStatus.disabled,
        resume: Resume
    ) {
        self.name = name
        self.value = value
        self.children = children
        self.parent = parent
        self.status = status
        includeInEditor = inEditor

        nodeDepth = 0
        self.resume = resume
        resume.nodes.append(self)
        // No need to set status again, it's already set by default.
    }

    @discardableResult
    func addChild(_ child: TreeNode) -> TreeNode {
        if children == nil {
            children = []
        }
        //    print(child.resume.id)
        child.parent = self
        child.myIndex = TreeNode.childIndexer
        child.nodeDepth = nodeDepth + 1
        children?.append(child)
        TreeNode.childIndexer += 1
        return child
    }

    var growDepth: Bool { return nodeDepth > 2 }
    static func traverseAndExportNodes(node: TreeNode, currentPath: String = "")
        -> [[String: String]]
    {
        var result: [[String: String]] = []
        var newPath: String
        // Construct the current tree path
        if node.parent == nil {
            newPath = "Resume"
        } else {
            newPath =
                currentPath.isEmpty ? node.name : "\(currentPath) > \(node.name)"
        }
        // If the node's status is .aiToReplace, add it to the result array
        if node.status == .aiToReplace {
            if node.name != "" && node.value != "" {}

            let nodeData: [String: String] = [
                "id": node.id,
                "value": node.value,
                "tree_path": newPath,
            ]
            result.append(nodeData)
        }

        // Recursively traverse the children
        for child in node.children ?? [] {
            let childResults = traverseAndExportNodes(
                node: child, currentPath: newPath
            )
            result.append(contentsOf: childResults)
        }

        return result
    }

    /// Updates the values of TreeNode objects based on the provided JSON file.
    /// - Parameters:
    ///   - jsonFileURL: The URL of the JSON file containing the array of {id: String, value: String} objects.
    ///   - context: The SwiftData context used to fetch and update the TreeNode objects.
    /// - Throws: An error if reading the JSON file, parsing JSON, or saving the context fails.
    static func updateValues(from jsonFileURL: URL, using context: ModelContext) throws {
        // Load JSON data from the provided file URL
        let jsonData = try Data(contentsOf: jsonFileURL)

        // Parse JSON data into an array of dictionaries
        guard let jsonArray = try JSONSerialization.jsonObject(
            with: jsonData, options: []
        ) as? [[String: String]] else {
            print("Failed to parse JSON.")
            return
        }

        // Iterate over the array and update corresponding TreeNodes
        for jsonObject in jsonArray {
            if let id = jsonObject["id"], let newValue = jsonObject["value"] {
                // Fetch the corresponding TreeNode from the SwiftData store manually
                let fetchRequest = FetchDescriptor<TreeNode>(
                    predicate: #Predicate { $0.id == id }
                )

                if let node = try context.fetch(fetchRequest).first {
                    // Update the value of the TreeNode
                    node.value = newValue
                } else {
                    print("TreeNode with id \(id) not found.")
                }
            } else {
                print("Invalid JSON object: \(jsonObject)")
            }
        }

        // Save the context to persist changes
        try context.save()
    }

    static func deleteTreeNode(node: TreeNode, context: ModelContext) {
        // Recursively delete children
        for child in node.children ?? [] {
            deleteTreeNode(node: child, context: context)
        }
        // Remove from parent's children array if necessary
        if let parent = node.parent, let index = parent.children?.firstIndex(of: node) {
            parent.children?.remove(at: index)
        }
        // Remove from resume.nodes
        if let index = node.resume.nodes.firstIndex(of: node) {
            node.resume.nodes.remove(at: index)
        }
        // Delete the node itself
        context.delete(node)

        // Save context to persist changes
        do {
            try context.save()
        } catch {
            print("Failed to delete TreeNode: \(error)")
        }
    }

    func deepCopy(newResume: Resume) -> TreeNode {
        // Create a copy of the current node with the new resume
        let copyNode = TreeNode(
            name: name,
            value: value,
            parent: nil, // The parent will be set during recursion
            inEditor: includeInEditor,
            status: status,
            resume: newResume
        )

        // Recursively copy the children
        if let children = children {
            for child in children {
                let childCopy = child.deepCopy(newResume: newResume)
                copyNode.addChild(childCopy) // Attach the child to the copied parent
            }
        }

        return copyNode
    }
}


