//
//  CoverLetterStore.swift
//  PhysCloudResume
//
//  Created by Christopher Culbreath on 9/12/24.
//

//
//  swift
//  PhysicsCloudResume
//
//  Created by Christopher Culbreath on 8/30/24.
//

import Foundation
import SwiftData

// Replaces handâ€‘rolled `saveContext()` duplication with a shared helper.
import SwiftUI // Needed only for `@Observable` macro, already available.

@Observable
@MainActor
final class CoverLetterStore: SwiftDataStore {
    // MARK: - Properties

    unowned let modelContext: ModelContext
    var coverRefStore: CoverRefStore
    var cL: CoverLetter? // This is the currently selected/active cover letter instance
    private let exportService: any CoverLetterExportService = LocalCoverLetterExportService()

    // MARK: - Initialiser

    init(context: ModelContext, refStore: CoverRefStore) {
        modelContext = context
        coverRefStore = refStore

        // Perform one-time migration for existing cover letters
        performMigrationForGeneratedFlag()
    }

    @discardableResult
    func addLetter(letter: CoverLetter, to jobApp: JobApp) -> CoverLetter {
        jobApp.coverLetters.append(letter)
        jobApp.selectedCover = letter // Set the newly added letter as selected
        modelContext.insert(letter)
        //    saveContext() // Context will be saved by the caller or at appropriate points
        return letter
    }

    func createBlank(jobApp: JobApp) {
        // Check if an ungenerated draft already exists
        if let existingUngenerated = jobApp.coverLetters.first(where: { !$0.generated }) {
            // Select the existing ungenerated draft instead of creating a new one
            jobApp.selectedCover = existingUngenerated
            Logger.debug("Found existing ungenerated draft, selecting it instead of creating new one")
            return
        }
        
        let letter = CoverLetter(
            enabledRefs: coverRefStore.defaultSources, // Start with default refs
            jobApp: jobApp
        )
        letter.generated = false // A blank letter is not yet generated
        // Do not set a name for a blank letter initially.
        // It will be named upon first generation or if the user manually edits and saves.
        jobApp.coverLetters.append(letter)
        jobApp.selectedCover = letter // Select the new blank letter

        modelContext.insert(letter)
        // saveContext() // Avoid saving context here; let higher-level operations manage saves.
    }

    @discardableResult
    func create(jobApp: JobApp) -> CoverLetter {
        let letter = CoverLetter(
            enabledRefs: coverRefStore.defaultSources,
            jobApp: jobApp
        )
        // Name will be set by processResults after AI generation.
        // includeResumeRefs will also be handled by the generation logic.
        modelContext.insert(letter)
        //      try? modelContext.save()
        return letter
    }

    func createDuplicate(letter: CoverLetter) -> CoverLetter {
        // Ensure the context has pending changes saved before duplicating
        saveContext() // From `SwiftDataStore` extension

        let newLetter = CoverLetter(
            enabledRefs: letter.enabledRefs, // Copy enabled references
            jobApp: letter.jobApp // Associate with the same job application
        )
        newLetter.includeResumeRefs = letter.includeResumeRefs // Preserve this flag
        newLetter.content = letter.content // Copy content for revision
        newLetter.generated = false // A duplicated letter for revision starts as not "freshly" generated by AI
        // It will be marked true by processResults after the revision.
        newLetter.encodedMessageHistory = letter.encodedMessageHistory // Copy message history for context
        newLetter.currentMode = letter.currentMode // Copy current mode

        // Get next available option letter for the new cover letter
        let nextOptionLetter = newLetter.getNextOptionLetter()

        // Extract the part after the colon from the existing name (if any)
        let nameBase = letter.editableName

        // Set the new name with the next option letter
        newLetter.name = "Option \(nextOptionLetter): \(nameBase)"

        if let jobApp = letter.jobApp {
            addLetter(letter: newLetter, to: jobApp) // This also sets it as selectedCover on jobApp
        }
        // saveContext() // Context will be saved by the caller or at appropriate points
        return newLetter
    }

    func deleteLetter(_ letter: CoverLetter) {
        if let jobApp = letter.jobApp {
            if let index = jobApp.coverLetters.firstIndex(of: letter) {
                jobApp.coverLetters.remove(at: index)
                modelContext.delete(letter)
                saveContext() // Save the deletion
            }
        } else {
            // If the letter is not associated with a jobApp, just delete it.
            // This case should ideally not happen if data integrity is maintained.
            modelContext.delete(letter)
            saveContext() // Save the deletion
        }
    }
    
    /// Deletes all ungenerated draft letters from the database, except the currently selected one
    func deleteUngeneratedDrafts(excludingSelected: Bool = true) {
        do {
            // Fetch all cover letters that are not generated
            let descriptor = FetchDescriptor<CoverLetter>(
                predicate: #Predicate<CoverLetter> { letter in
                    letter.generated == false
                }
            )
            let ungeneratedLetters = try modelContext.fetch(descriptor)
            
            var deletedCount = 0
            for letter in ungeneratedLetters {
                // Skip if this is the currently selected cover letter and we're excluding it
                if excludingSelected, let jobApp = letter.jobApp, jobApp.selectedCover == letter {
                    Logger.debug("ðŸ”’ Skipping deletion of currently selected ungenerated draft")
                    continue
                }
                
                if let jobApp = letter.jobApp {
                    if let index = jobApp.coverLetters.firstIndex(of: letter) {
                        jobApp.coverLetters.remove(at: index)
                    }
                }
                modelContext.delete(letter)
                deletedCount += 1
            }
            
            if deletedCount > 0 {
                Logger.debug("ðŸ§¹ Cleaned up \(deletedCount) ungenerated draft letters")
                saveContext()
            }
            
        } catch {
            Logger.error("Failed to clean up ungenerated drafts: \(error.localizedDescription)")
        }
    }
    
    /// Ensures only one ungenerated draft exists per job application
    func cleanupExtraUngeneratedDrafts(for jobApp: JobApp) {
        let ungeneratedDrafts = jobApp.coverLetters.filter { !$0.generated }
        
        // If there's more than one ungenerated draft
        if ungeneratedDrafts.count > 1 {
            // Keep the selected one if it's ungenerated, otherwise keep the most recent
            let draftsToKeep: CoverLetter?
            if let selected = jobApp.selectedCover, !selected.generated {
                draftsToKeep = selected
            } else {
                draftsToKeep = ungeneratedDrafts.sorted(by: { $0.moddedDate > $1.moddedDate }).first
            }
            
            // Delete all others
            var deletedCount = 0
            for draft in ungeneratedDrafts {
                if draft != draftsToKeep {
                    if let index = jobApp.coverLetters.firstIndex(of: draft) {
                        jobApp.coverLetters.remove(at: index)
                    }
                    modelContext.delete(draft)
                    deletedCount += 1
                }
            }
            
            if deletedCount > 0 {
                Logger.debug("ðŸ§¹ Cleaned up \(deletedCount) extra ungenerated drafts for job app")
                saveContext()
            }
        }
    }

    // `saveContext()` now provided by `SwiftDataStore` default implementation.

    // MARK: - PDF Export

    func exportPDF(from coverLetter: CoverLetter) -> Data {
        return exportService.exportPDF(from: coverLetter, applicant: Applicant())
    }

    // MARK: - Migration

    /// One-time migration to set generated = true for all existing cover letters with content
    @MainActor
    private func performMigrationForGeneratedFlag() {
        // Use AppStorage to track migration status
        let migrationKey = "CoverLetterGeneratedFlagMigrationCompleted"
        let defaults = UserDefaults.standard

        // Only run migration once
        if defaults.bool(forKey: migrationKey) {
            return
        }

        do {
            // Fetch all cover letters
            let descriptor = FetchDescriptor<CoverLetter>()
            let allCoverLetters = try modelContext.fetch(descriptor)

            var updatedCount = 0

            // Update only those with content but not marked as generated
            for letter in allCoverLetters {
                if !letter.content.isEmpty && !letter.generated {
                    letter.generated = true
                    updatedCount += 1
                }
            }

            if updatedCount > 0 {
                Logger.debug("Migration: Set generated=true for \(updatedCount) cover letters with content")
                saveContext()
            }

            // Mark migration as completed
            defaults.set(true, forKey: migrationKey)

        } catch {
            Logger.debug("Failed to perform cover letter migration: \(error.localizedDescription)")
        }
    }
}
